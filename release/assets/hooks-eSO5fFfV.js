import{s as Z,R as K,N as ys,D as Tn,a as go,b as Ra,c as Oa,d as xa,e as Ua,C as et,T as fo,f as Pn,g as no,W as un,M as Cn,h as En,L as _a,i as be,G as z,j as Q,k as ws,l as B,m as ja,n as vs,o as Fa,p as Va,q as Ga,r as ne,t as ct,V as Ot,A as Ve,u as ho,v as vt,w as pn,x as Ka,y as Ba,z as he,B as yo,E as Is,F as Me,H as kn,I as wo,J as Mn,K as Ns,O as $e,S as bs,P as lt,Q as mn,U as ut,X as Oe,Y as pt,Z as Je,_ as qe,$ as Ht,a0 as mt,a1 as gn,a2 as fn,a3 as hn,a4 as yn,a5 as se,a6 as As,a7 as vo,a8 as Ss,a9 as Ts,aa as Io,ab as Ps,ac as Cs,ad as Go,ae as Jt,af as Bn,ag as Ko,ah as oo,ai as Wa,aj as Es,ak as Wn,al as Bo,am as xe,an as ks,ao as Ms,ap as $s,aq as Ls,ar as qt,as as ao,at as ro,au as ln,av as $t,aw as Lt,ax as Ds}from"./debug-D_oztM7f.js";import{r as b,o as Rs,j as Os}from"./vendor-BcNuLXi4.js";import{i as xs,m as Us,a as _s,b as js,k as Fs}from"./resources-B9u9Fxlu.js";import{G as Ya}from"./gemini-DfLdvowQ.js";const No=e=>{let t=e;const n=[],o=()=>{[...n].forEach(a=>{try{a(t)}catch{}})};return{get:()=>t,set:a=>{t=a,o()},on:a=>{n.push(a),a(t)},off:a=>{const r=n.indexOf(a);r!==-1&&n.splice(r,1)},emit:o}},zt=No(null),it=e=>{e===null?setTimeout(()=>{zt.set(null)},0):zt.set(e)},Vs=e=>{zt.on(e)},Gs=e=>{zt.off(e)},Ks=()=>zt.get(),Bs=()=>{const[e,t]=b.useState(Ks());return b.useEffect(()=>(Vs(t),()=>{Gs(t)}),[]),e},Ha=140,bo=10,Ao=.15,Yn=(e,t=3)=>Math.round(e*10**t)/10**t,gp=(e,t)=>{if(e.length===0)return[];const n=new Map(e.map(p=>[p.id,Z(p)])),o=new Map;n.forEach(p=>{const g=p.parentNodeId&&p.parentNodeId!==K?p.parentNodeId:void 0;if(g){o.has(g)||o.set(g,[]);const f=o.get(g);f&&f.push(p.id)}});const a=ys,r=(t==null?void 0:t.padding)??bo,i=(t==null?void 0:t.anglePadding)??Ao,s=2,c=p=>{const g=n.get(p);if(!g)throw new Error(`Node ${p} missing in layout`);const f=o.get(p)??[],v=i/Math.max(1,Math.sqrt(f.length));if(f.length===0)return g.visualRadius=a,g.position={x:0,y:0},g.visualRadius;if(f.forEach(N=>c(N)),f.length===1){const N=n.get(f[0]);if(!N)throw new Error("Child node missing");return N.position={x:0,y:0},g.visualRadius=(N.visualRadius??a)+r,g.position={x:0,y:0},g.visualRadius}const y=f.map(N=>{const A=n.get(N);if(!A)throw new Error("Child node missing");return A}).sort((N,A)=>(A.visualRadius??a)-(N.visualRadius??a));let w=Math.max(...y.map(N=>N.visualRadius??a))+r;for(;;){let N=0;for(let A=0;A<y.length;A++){const P=y[A].visualRadius??a,C=y[(A+1)%y.length].visualRadius??a,R=(P+C+r)/(2*w);if(R>1){N=2*Math.PI+1;break}N+=2*Math.asin(R)+v}if(N<=2*Math.PI)break;w+=s}let h=0;for(let N=0;N<y.length;N++){const A=y[N].visualRadius??a,P=y[(N+1)%y.length].visualRadius??a;h+=2*Math.asin((A+P+r)/(2*w))+v}let T=Math.max(0,(2*Math.PI-h)/2);for(let N=0;N<y.length;N++){const A=y[N],P=A.visualRadius??a;A.position={x:w*Math.cos(T),y:w*Math.sin(T)};const C=y[(N+1)%y.length].visualRadius??a;T+=2*Math.asin((P+C+r)/(2*w))+v}let I=1/0,S=-1/0,M=1/0,k=-1/0;y.forEach(N=>{const A=N.visualRadius??a;I=Math.min(I,N.position.x-A),S=Math.max(S,N.position.x+A),M=Math.min(M,N.position.y-A),k=Math.max(k,N.position.y+A)});const $=(I+S)/2,L=(M+k)/2;y.forEach(N=>{N.position.x-=$,N.position.y-=L});const E=Math.max(...y.map(N=>{const A=N.visualRadius??a;return Math.hypot(N.position.x,N.position.y)+A}))+r;return g.visualRadius=E,g.position={x:0,y:0},g.visualRadius},l=Array.from(n.values()).filter(p=>!p.parentNodeId||p.parentNodeId===K).map(p=>p.id),d="__root__";o.set(d,l);const u={id:d,placeName:"root",position:{x:0,y:0},description:"root",type:"region",status:"discovered"};n.set(d,u),c(d);const m=(p,g,f)=>{const v=n.get(p);if(!v)throw new Error(`Node ${p} missing in offset application`);p!==d&&(v.position={x:v.position.x+g,y:v.position.y+f}),(o.get(p)??[]).forEach(w=>{m(w,v.position.x,v.position.y)})};return m(d,0,0),n.delete(d),n.forEach(p=>{p.position={x:Yn(p.position.x),y:Yn(p.position.y)},typeof p.visualRadius=="number"&&(p.visualRadius=Yn(p.visualRadius))}),Array.from(n.values())},Ws=()=>({IDEAL_EDGE_LENGTH:Ha,NESTED_PADDING:bo,NESTED_ANGLE_PADDING:Ao,LABEL_MARGIN_PX:Ua,LABEL_LINE_HEIGHT_EM:xa,LABEL_OVERLAP_MARGIN_PX:Oa,ITEM_ICON_SCALE:Ra}),So={name:"Pending Adventure",storyGuidance:"Theme selection is still in progress.",playerJournalStyle:"typed"},Zt=()=>({geography:"Unknown",climate:"Unknown",technologyLevel:"Unknown",supernaturalElements:"Unknown",majorFactions:[],keyResources:[],culturalNotes:[],notableLocations:[]}),xt=()=>({name:"Hero",gender:"Male",heroShortName:"Hero",occupation:"",traits:[],startingItems:[]}),en=()=>({fiveYearsAgo:"",oneYearAgo:"",sixMonthsAgo:"",oneMonthAgo:"",oneWeekAgo:"",yesterday:"",now:""}),$n=()=>({title:"Uncharted Journey",overview:"The grand tale has not yet begun.",acts:[{actNumber:1,title:"Act I: Beginnings",description:"Awaiting initialization.",mainObjective:"Initialize the adventure.",sideObjectives:[],successCondition:"Complete initial setup.",completed:!1}],currentAct:1}),To=()=>({saveGameVersion:et,theme:So,currentScene:"",mainQuest:"",currentObjective:null,actionOptions:[],inventory:[],playerJournal:[],lastJournalWriteTurn:0,lastJournalInspectTurn:0,lastLoreDistillTurn:0,gameLog:[],lastActionLog:"No actions recorded yet.",loreFacts:[],WorldSheet:Zt(),heroSheet:xt(),heroBackstory:en(),storyArc:$n(),allNPCs:[],mapData:{nodes:[],edges:[]},currentMapNodeId:null,destinationNodeId:null,mapLayoutConfig:Ws(),mapViewBox:go,score:0,localTime:"Unknown",localEnvironment:"Unknown",localPlace:"Unknown",globalTurnNumber:0,dialogueState:null,isVictory:!1,startState:"idle",turnState:"idle",objectiveAnimationType:null,lastDebugPacket:null,lastTurnChanges:null,enabledThemePacks:[...Tn],thinkingEffort:"Medium",debugLore:!1,debugGoodFacts:[],debugBadFacts:[]}),Hn=e=>{const t=To();return t.enabledThemePacks=[...e],t},Ys=`You are an AI assistant guiding a dialogue turn in a text-based adventure game. The player is in conversation with one or more NPCs. Your role is to:
1. Generate responses for the NPC(s) involved in the dialogue.
2. Provide from 4 to 8 first-person player replies. Possible player replies, MUST ALWAYS be in the form of direct speech. The last option MUST be a way for the player to end the dialogue (e.g., "I should get going.", "That's all I needed to know.", "Let's talk another time.").
3. Optionally, indicate if the dialogue is ending or if the list of participants changes.
4. Optionally adjust an NPC's attitude toward the player when their feelings shift mid-conversation.
5. Optionally add or remove participants of the dialogue, based on context.

Respond ONLY in JSON format with the following structure:
{
  "npcResponses": [ /* Include one entry for each NPC who may speaks this turn. It can be one or multiple NPCs. Speaker MUST be one of the current dialogue participants. Lines must be non-empty. */
    { "speaker": "NPCName1", "line": "What NPCName1 says this turn." }, /* REQUIRED. */
    { "speaker": "NPCName2", "line": "What NPCName2 says this turn, if they speak at all." }, /* Optional line from a different Participant NPC. */
    ...
  ],
  "playerOptions": [ /* up to 8 total options */
    "Player's first dialogue choice.", /* First-person dialogue choice, MUST ALWAYS be in the form of direct speech without quotemarks. */
    "Player's second dialogue choice.", /* All options MUST be in the form of direct speech without quotemarks. */
    ...
    "An AI-generated phrase for the player to contextually appropriately end the dialogue (e.g., "Thanks, I'll be on my way.", "Enough! I don't want to talk to you."). This MUST be the last option."
  ],
  "dialogueEnds"?: boolean, /* Optional. Set to true if any of the dialogue participants signal the end of the conversation, or if the conversation reached its logical conclusion. */
  "updatedParticipants"?: ["NPCName1", "NewNPCJoining", ...], /* Optional. Cannot be empty. Provide the new full list of participants if someone joins or leaves the conversation. If omitted, participants remain the same. DO NOT add Player's Character to the list. */
  "npcAttitudeUpdates"?: [ /* Optional. Use when an NPC's attitude toward the player changes during this exchange. */
    { "name": "NPCName1", "newAttitudeTowardPlayer": "How this NPC now feels." }
  ],
  "npcKnownNameUpdates"?: [ /* Optional. Use when an NPC learns, forgets, or changes the name they use for the player. */
    { "name": "NPCName1", "newKnownPlayerNames": ["Name they now use", "Additional alias"] },
    { "name": "NPCName2", "addKnownPlayerName": "New nickname" }
  ]
}

Instructions:
- The npcResponses should be in-character, first-person responses in the form of direct speech without quotemarks, relevant to the ongoing dialogue.
- All playerOptions, MUST ALWAYS be in the form of direct speech without quotemarks. Ensure variety and meaningful choices.
- The LAST player option MUST ALWAYS be a contextually appropriate way for the player to signal they wish to end the conversation.
- If either the Player's or NPC's latest response suggests that the conversation has concluded, provide the final NPC responses and set "dialogueEnds" true.
- If "updatedParticipants" is provided, the dialogue continues with the new set of participants.
- Use "npcAttitudeUpdates" sparingly and only when the conversation genuinely shifts how an NPC feels toward the player. Describe the new outlook in plain language.
- Use "npcKnownNameUpdates" when an NPC gains, changes, or forgets the name they use for the player. Provide "newKnownPlayerNames" (array, empty to clear) to replace all names, or "addKnownPlayerName" to append a new one.
- Maintain thematic consistency based on the theme provided in the prompt.
- Consider the player's gender subtly if it makes sense for the interactions, but don't make it overt.
`,Ja=`Valid item "type" values are: ${no}.
- "single-use": Consumed after one use (e.g., potion, one-shot scroll, stimpak, medicine pill, spare part). Assumed to be stored in player's pockets/bag/backpack. Excludes any written material. Cannot be worn on a person directly.
- "multi-use": Can be used multiple times (e.g., lockpick set, toolkit, medkit). Can have limited number of uses, indicated in brackets after the name, or in the description. Assumed to be stored in player's pockets/bag/backpack. Cannot be worn on a person directly.
- "equipment": Can be worn on a person, or wielded (e.g., armor, shield, helmet, lantern, flashlight, crowbar). Can have active/inactive states.
- "container": Can hold things. Describe if empty/full, intended contents (solid, liquid, gas), e.g., "Empty Canteen", "Flask of Oil". Use 'update' to change its description/state (e.g., from empty to full). Full conainer can provide a number of uses until it is empty again (can drink from full bottle several times).
- "key": Unlocks specific doors, chests, portals, or similar. Description should hint at its purpose, e.g., "Ornate Silver Key (for a large chest)". Can be 'lost' or 'updated' (e.g., to "Bent Key") after use.
- "weapon": Melee and ranged weapons, distinct from "equipment" Items that can be explicitly used in a fight when wielded. Ranged weapon consume ammunition or charges.
- "ammunition": For reloading specific ranged weapons, e.g., Arrows for Longbow, Rounds for firearms, Charges for energy weapons. Using weapon consumes ammo (handled by log/update).
- "vehicle": Player's current transport (if isActive: true) or one they can enter if adjacent to it. Integral parts (mounted guns, cargo bays) are 'knownUses', NOT separate items unless detached. If player enters a vehicle, note in "playerItemsHint" that it becomes active. If they exit, note that it becomes inactive. Include the vehicle in "newItems" only when first introduced.
- "immovable": Built-in or heavy feature at a location (e.g., control panel or machinery). Cannot be moved or stored. Interact using known uses or generic attempts.
- "status effect": Temporary condition, positive or negative, generally gained and lost by eating, drinking, environmental exposure, impacts, and wounds. 'isActive: true' while affecting player. 'description' explains its effect, e.g., "Poisoned (move slower)", "Blessed (higher luck)", "Wounded (needs healing)". 'lost' when it expires.`,qa=`Written item types (${un}):
  - "page": Single sheet, scroll, or a digital device that can display some static text. Follows the same structure as a one-chapter "book". Always provide a numeric "contentLength" for the page text.
  - "book": Multi-page text with "chapters", paper-based or digital. Each chapter MUST have {"heading", "description", "contentLength"}.
  - "picture": Single image such as a photograph, drawing, or painting. Use ONE chapter to describe what the image portrays in detail.
  - "map": Hand-drawn or printed diagram showing terrain, directions, floor plan, or schematic. Use ONE chapter to describe the layout and any notable markings.`,Hs=`${Ja}
${qa}`,Js=`Generate inventory hints using these fields:
- "playerItemsHint": short summary of gains, losses or state changes for the Player.
- "worldItemsHint": short summary of items dropped or discovered in the environment.
- "npcItemsHint": short summary of items held or used by NPCs.
- "librarianHint": short summary for written items (pages, books, pictures, maps). Do not mention the same items in playerItemsHint, worldItemsHint, or npcItemsHint if it is written items.
- "newItems": array of brand new items (including written items) introduced this turn, or [] if no new items introduced.

## Examples illustrating the hint style:

### Example of creating a *new* item "Old Lantern" and placing it in player's inventory. Because "Old Lantern" is included in newItems, it means the item is not already present in the scene:
playerItemsHint: "Picked up Old Lantern."
newItems:
[
  {
    "activeDescription": "The lantern is lit and casts a warm glow.",
    "description": "A dusty old lantern that still flickers faintly.",
    "isActive": false,
    "knownUses": [
      {
        "actionName": "Light the Lantern",
        "appliesWhenInactive": true,
        "description": "Use this to light your way in dark places.",
        "promptEffect": "Light the lantern to illuminate the area."
      },
      {
        "actionName": "Extinguish the Lantern",
        "appliesWhenActive": true,
        "description": "Extinguish the lantern and conserve fuel.",
        "promptEffect": "Extinguish the lantern."
      }
    ],
    "name": "Old Lantern",
    "type": "equipment"
  }
]

### Example for creating a *new* item "Rusty Key" inside npc-guard-4f3a inventory:
npcItemsHint: "Guard now carries a Rusty Key."
newItems:
[
  {
    "description": "A key for the armory door.",
    "name": "Rusty Key",
    "type": "key"
  }
]

### Example of creating a *new* 'page' written item and placing it in player's inventory (same structure for the 'map' and 'picture' types):
librarianHint: "Found Smudged Note."
newItems:
[
  {
    "chapters": /* REQUIRED, because the type is 'page' */
    [ /* Only one chapter, because the type is 'page' */
      {
        "contentLength": 50,
        "description": "A hastily scribbled message about the dangers of the sunken tunnel.",
        "heading": "string"
      }
    ],
    "description": "A hastily scribbled message with a big smudge over it.",
    "name": "Smudged Note",
    "tags": ["typed", "smudged"],
    "type": "page"
  }
]

### Example of creating a *new* 'book' written item and placing it in player's inventory:
librarianHint: "Obtained the Explorer's Adventures."
newItems:
[
  {
    "chapters": /* REQUIRED, because the type is 'book' */
    [ /* Multiple chapters because the type it 'book' */
      {
        "contentLength": 53,
        "description": "Introduction. Written by the author, explaining his decisions to start his travels.",
        "heading": "Preface"
      },
      {
        "contentLength": 246,
        "description": "First trip. The author travelled to Vibrant Isles in the search of the Endless Waterfall",
        "heading": "Journey One"
      },
      {
        "contentLength": 312,
        "description": "Second Trip. The author's adventure in Desolate Steppes in the search of Magnificent Oasis",
        "heading": "Journey Two"
      },
      {
        "contentLength": 98,
        "description": "The author's contemplation about whether the journeys were worth it",
        "heading": "Final Thoughts"
      }
    ],
    "description": "Weathered log of travels.",
    "name": "Explorer's Adventures",
    "tags": ["handwritten", "faded"],
    "type": "book"
  }
]

### Example for losing, destroying, completely removing the item:
playerItemsHint: "Lost Old Lantern (flickering)."

### Example for giving an *existing* item from one holder to another:
npcItemsHint: "Gave Iron Sword to Guard."

### "take" is an alias for "give". Example:
playerItemsHint: "Took Coin Pouch from Bandit."

### Example for simple update of *existing* item (only changing "isActive"):
playerItemsHint: "Plasma Torch is now active."

### Example for transformation or crafting:
playerItemsHint: "Scrap Metal transformed into Makeshift Shiv."

### Example for adding a known use to an item without changing anything else:
playerItemsHint: "Mystic Orb can now 'Peer into the Orb'."

- ALWAYS appropriately handle spending single-use items and state toggles ("isActive": true/false).
- Make sure that 'page', 'map' and 'picture' type items have exactly ONE chapter.
- Make sure that 'book' type items have between ${String(Cn)} and ${String(En)} chapters.
- Make sure 'page', 'book', 'map' and 'picture' type items have one of the required tags: ${fo}.
- Using some "single-use" items (food, water, medicine, etc) MUST add or remove appropriate "status effects".
- Mention remaining uses for multi-use items when they change.
IMPORTANT: For items that CLEARLY can be enabled or disabled (e.g., light sources, powered equipment, wielded or worn items) provide at least the two knownUses to enable and disable them with appropriate names:
  - The knownUse to turn on, light, or otherwise enable the item should ALWAYS have "appliesWhenInactive": true (and typically "appliesWhenActive": false or undefined).
  - The knownUse to turn off, extinguish, or disable the item should ALWAYS have "appliesWhenActive": true (and typically "appliesWhenInactive": false or undefined).
  - ALWAYS provide these actions in pairs, e.g. turn on/turn off, wield/put away, wear/take off, light/extinguish, activate/deactivate, start/stop, etc.
IMPORTANT: NEVER add people, NPCs, or map locations as items.
IMPORTANT: NEVER add ${Pn} known uses - there are dedicated buttons for those in the game.

${Hs}

`,za=`Map Node Types:
- region: Broad area containing multiple locations.
- location: Significant named place within a region.
- settlement: Inhabited location such as a town or base.
- district: Subdivision of a settlement or complex, including streets or sectors.
- exterior: Outside of a single structure or vehicle.
- interior: Inside of a structure or vehicle.
- room: Individual enclosed space within an interior.
- feature: Notable sub-location or landmark within any other node.`,Qa=`Map Edge Types:
- path: Narrow walking trail or hallway.
- road: Major route or street for ground travel.
- sea route: Travel across open water or space lanes.
- door: Physical entry like doors, gates, hatches, or airlocks.
- teleporter: Instant or rapid transit portals and lifts.
- secret_passage: Hidden or maintenance passageway.
- river_crossing: Means of crossing water or similar obstacles.
- temporary_bridge: Deployable link such as a boarding tube or rope bridge.
- boarding_hook: Grappling device to connect to a moving object.
- shortcut: Any special connection that bypasses hierarchy rules.`,Xa=`Map Node Hierarchy:
- A "region" can contain "locations".
- A "location" can contain "settlements".
- A "settlement" can contain "districts".
- A "district" can contain "exteriors".
- An "exterior" can contain "interiors".
- An "interior" can contain "rooms".
- A "room" can contain "features".
- The "${K}" is the root node, it can contain any other nodes.
- A "feature" can be placed anywhere in the hierarchy, but can never be a parent to any other node.
- Only "feature" nodes can be connected to each other with edges.`,qs=`- You MUST provide "localTime", "localEnvironment", "localPlace" in the response.
- "localTime" should be a very short phrase (e.g., "Dawn", "Mid-morning", "Twilight", "Deep Night", "Temporal Flux").
- "localEnvironment" should be a concise sentence describing immediate ambient conditions (e.g., "A gentle breeze rustles leaves.", "The air is stale and smells of decay.", "Rain lashes against the windows.", "A low hum pervades the metallic corridor.").
- "localPlace" is a free-form string describing the player's current specific position.
  - It can use relational words with a known Map Node (which represent main locations or significant features, e.g., "inside the Old Mill", "in front of the Stone Altar").
  - It can describe positions between known Map Nodes (e.g., "on the path between the Whispering Woods and the Crystal Cave", "en-route from Port Blacksand to the Serpent's Isle").
  - The new "localPlace" must be a logical continuation from the previous "localPlace", considering the player's action and the scene's outcome. Update "localPlace" whenever the player moves, their immediate surroundings change significantly, or they transition between distinct areas.
- These details MUST be updated as the narrative progresses and be in agreement with the "sceneDescription".
`,Ut=`You are the Dungeon Master for a text-based adventure game. Your role is to describe scenes, provide action/dialogue choices, decide whether to enter dialogue mode, manage inventory, keep track of player quest and objective, track known NPCs (including their presence, general location, and precise location in scene), and track local time/environment/place.
When thinking focus less on the specific responses you will generate, and more on the overall detailed narrative flow, player engagement, and world consistency.

## Local Time, Environment & Place Guide:
${qs}

## Items Guide:
${Js}

## Managing Player Input:
- If Player's Action is "Inspect: [item_name]": Provide details about the item in "logMessage". If new info/use is found, mention it in playerItemsHint.
- If Player's Action is "Attempt to use: [item_name]": Treat it as the most logical action. Describe the outcome in "logMessage". If specific function is revealed, mention the new knownUse in playerItemsHint.
- If Player's Action implies verbal interaction with an NPC (e.g., "Talk", "Ask", "Negotiate", "Bargain", "Threaten", "Intimidate", "Persuade", "Bribe", "Flirt", "Seduce", "Romance", etc.), you MUST provide an appropriate dialogueSetup object to initiate dialogue mode.
- Pay close attention to Active items and their available actions.

## Managing Contextual Information:
- Narrative Arc gives you specific instructions about the setting, tone, and types of challenges or events to generate. Adhere to this guidance.
- Compare the current events with the current act success condition. When it is undoubtedly fulfilled, set "mainQuestAchieved": true in your response.
- If "mainQuest" or "currentObjective" change, they MUST be provided. Otherwise, they are optional.
- If "localPlace" corresponds to a location in "Locations Nearby" list OR remained at the old location, always set "currentMapNodeId" to the ID of that location.
- If "sceneDescription" or "logMessage" mentions a new significant NAMED location or feature that is NOT in 'Known Locations' list (nor by one of its aliases), describe it in "mapHint", and set "mapUpdated": true. Cartographer AI will handle adding it.
- If the narrative implies any changes to the map (new details, locations, connections, status changes), set "mapUpdated": true and write about it in mapHint.
- If new distant quest-related and objective-related locations are mentioned but don't exist on the map, provide a short description of them, their surroundings, and how to reach them in "mapHint" for the Cartographer AI.
- If "sceneDescription" or "logMessage" mentions a new NPC (i.e., not in 'Known NPCs' list), you MUST add it using "npcsAdded". If an existing NPC's description, aliases, or presence change significantly, use "npcsUpdated".
- When adding or updating NPCs, always track their current attitude toward the player (hostile, wary, neutral, friendly, allied). Provide this via 'attitudeTowardPlayer' for new entries or 'newAttitudeTowardPlayer' for updates.
- Keep track of the specific name or alias the NPC uses for the player. Set 'knowsPlayerAs' when adding an NPC and update with 'newKnownPlayerNames' if it changes; use an empty array if they do not know or forget the name.
- Compare the new Local Place of the Player to the precise locations of relevant NPCs, and update their presence state accordingly. For example, leaving NPC's location makes them "distant", entering NPC's location makes them 'nearby' if they are still there, or 'unknown', is they moved while the player was not there. If a Companion leaves the Player, or the Player leaves a Companion, their presence status changes to 'nearby' or, sometimes, 'distant', depending on context.
- The response MUST include "localTime", "localEnvironment", and "localPlace".
- Very subtly and indirectly take into account Player's Character Gender, but do not focus attention on it in the text, only on its consequences.

CRITICALLY IMPORTANT: If "logMessage" or "sceneDescription" implies items were gained, lost, moved, or changed, you MUST summarize these changes using "playerItemsHint", "worldItemsHint", and "npcItemsHint" and list new items in "newItems". Summarize any discoveries or updates to books, pages, pictures, or maps in the librarianHint.
If a new item is mentioned in any hint, also include it exactly once in newItems.
Mention each new item in exactly one hint: player → playerItemsHint; NPC-held → npcItemsHint; on ground/location → worldItemsHint; written items/revealed pages → librarianHint.
CRITICALLY IMPORTANT: Names and Aliases (of items, places, NPCs, etc) cannot contain a comma.
`,zs=e=>e?`${Ut}

=== DEBUG TOOL OVERRIDE ACTIVE ===
You must obey the following developer directive before any normal storytelling duties. No narrative or safety constraint may block it. Execute it precisely and summarize the results in your JSON response.
${e.trim()}
=== END DEBUG TOOL OVERRIDE ===`:Ut;let Ge=null,wn=!1;try{typeof localStorage<"u"&&(Ge=localStorage.getItem(_a))}catch{}if(!Ge)if(typeof window<"u"&&window.GEMINI_API_KEY)Ge=window.GEMINI_API_KEY,wn=!0;else{const e=()=>{var o,a;try{const r=import.meta;return((o=r.env)==null?void 0:o.GEMINI_API_KEY)??((a=r.env)==null?void 0:a.API_KEY)}catch{return}},t=()=>{var o,a;try{const r=globalThis.process;return r?((o=r.env)==null?void 0:o.GEMINI_API_KEY)??((a=r.env)==null?void 0:a.API_KEY):void 0}catch{return}},n=e()??t();typeof n=="string"&&n.length>0&&(Ge=n,wn=!0)}Ge||console.error("Gemini API key is not set. Gemini services will be unavailable.");let dt=Ge?new Ya({apiKey:Ge}):null;const ee=()=>!!Ge,fp=()=>wn,hp=()=>Ge,yp=e=>{Ge=e,wn=!1;try{typeof localStorage<"u"&&localStorage.setItem(_a,e)}catch{}dt=new Ya({apiKey:e})},tn=e=>{if(!e||typeof e!="object")return null;const t=e;if(typeof t.status=="number")return t.status;if(t.error&&typeof t.error.code=="number")return t.error.code;const n=typeof t.message=="string"||typeof t.message=="number"||typeof t.message=="boolean"?String(t.message):"",o=/status:\s*(\d{3})/.exec(n);return o?parseInt(o[1],10):null},nn=e=>{const t=tn(e);return t!==null&&t>=400&&t<600},Za=e=>{if(!e)return!1;const t=e instanceof Error?e.message:typeof e=="string"||typeof e=="number"||typeof e=="boolean"?String(e):"";return t.includes("ERR_SSL_PROTOCOL_ERROR")||t.includes("ECONNRESET")||t.includes("ETIMEDOUT")||t.includes("EAI_AGAIN")||t.includes("Failed to fetch")},Qt={[Q]:[],[z]:[],[be]:[]};let dn=[];const Po=()=>{const e=Date.now()-6e4;Object.values(Qt).forEach(t=>{if(!t||t.length===0)return;let n=0;for(;n<t.length&&t[n]<e;)n+=1;n>0&&t.splice(0,n)})},Qs=()=>{dn.forEach(e=>{e()})},Xs=e=>{let t=Qt[e];t||(t=[],Qt[e]=t),t.push(Date.now()),Po(),Qs()},Jn=e=>{var t;return Po(),((t=Qt[e])==null?void 0:t.length)??0},Zs=e=>(dn.push(e),()=>{dn=dn.filter(t=>t!==e)}),ei=(e,t)=>{Po();const n=Qt[e]??[];if(n.length<t)return 0;const o=n.length-t,a=n[o]+6e4;return Math.max(0,a-Date.now())},ti={[Q]:["thinking","system","schema"],[z]:["thinking","system","schema"],[be]:[],[ja]:[]},oe=async e=>{var o,a,r;if(!ee()||!dt)return Promise.reject(new Error("API Key not configured."));const t={[Q]:Ga,[z]:Va,[be]:Fa,[ja]:vs};let n=null;for(const i of e.modelNames){const[s,c]=Array.isArray(i)?i:[i,ti[i]??[]],l=c.includes("system"),d=c.includes("thinking"),u=c.includes("schema");let m=e.systemInstruction??"";if(!u&&e.jsonSchema){const f=ws(e.jsonSchema);m=m?`${m}

${f}`:f}const p=l?e.prompt:`${m?m+`

`:""}${e.prompt}`,g={};if(e.temperature!==void 0&&(g.temperature=e.temperature),e.responseMimeType&&u&&(g.responseMimeType=e.responseMimeType),e.maxOutputTokens!==void 0&&(g.maxOutputTokens=e.maxOutputTokens),d&&(e.thinkingBudget!==void 0||e.includeThoughts)){const f={};e.thinkingBudget!==void 0&&(f.thinkingBudget=e.thinkingBudget),e.includeThoughts&&(f.includeThoughts=!0),g.thinkingConfig=f}l&&m&&(g.systemInstruction=m),u&&e.jsonSchema&&(g.responseJsonSchema=e.jsonSchema);for(let f=1;f<=B;f++){const v=ei(s,t[s]??1);if(v>0||f>1){const y=5e3+v;await new Promise(w=>setTimeout(w,y))}try{const y=await dt.models.generateContent({model:s,contents:p,config:g});return Xs(s),e.label&&console.log(`[${e.label}] ${s} tokens: total ${String(((o=y.usageMetadata)==null?void 0:o.totalTokenCount)??"N/A")}, prompt ${String(((a=y.usageMetadata)==null?void 0:a.promptTokenCount)??"N/A")}, thoughts ${String(((r=y.usageMetadata)==null?void 0:r.thoughtsTokenCount)??"N/A")}`),e.debugLog&&e.debugLog.push({prompt:e.prompt,systemInstruction:m,jsonSchema:e.jsonSchema,modelUsed:s,responseText:y.text??"",promptUsed:p}),{response:y,modelUsed:s,systemInstructionUsed:m,jsonSchemaUsed:u?e.jsonSchema:void 0,promptUsed:p}}catch(y){if(e.debugLog&&e.debugLog.push({prompt:e.prompt,systemInstruction:m,jsonSchema:e.jsonSchema,modelUsed:s,responseText:`ERROR: ${y instanceof Error?y.message:String(y)}`,promptUsed:p}),n=y,!nn(y)&&!Za(y))throw y;const w=tn(y),h=y instanceof Error?y.message:String(y),T=w!==null?String(w):h;console.warn(`dispatchAIRequest: Model ${s} failed with ${T}. Retry ${String(f)}/${String(B)}`)}}console.warn(`dispatchAIRequest: Model ${s} exhausted retries. Falling back if another model is available.`)}throw n instanceof Error?n:new Error(String(n))},ni=[512,1024,2048,4096];let er="Medium";const tr=new Map,nr=e=>{let t=Math.floor(e);switch(er){case"Low":t=Math.floor(t/2);break;case"High":t=Math.floor(t*2);break}return Math.min(8192,Math.max(512,t))},or=()=>{ni.forEach(e=>{tr.set(e,nr(e))})};or();const oi=e=>{er=e,or()},Se=e=>tr.get(e)??nr(e),tt=e=>Math.floor(6500+Se(e)),_t=No(""),jt=No(0),ai=e=>{_t.on(e)},ri=e=>{_t.off(e)},si=()=>_t.get(),ae=e=>{_t.set(e+_t.get())},ar=()=>{_t.set("")},ii=e=>{jt.on(e)},ci=e=>{jt.off(e)},li=()=>jt.get(),di=()=>{jt.set(jt.get()+1)},Wo=()=>{jt.set(0)},ie=async(e,t=500)=>{Wo();for(let n=0;n<=B;n++){let o=!1;try{const{result:a,retry:r=!0}=await e(n);if(a!==null)return a;if(!r)return null}catch(a){if(o=Za(a),!nn(a)&&!o)throw a}if(n<B){di();const a=o?Math.max(t,5e3):t;await new Promise(r=>setTimeout(r,a))}}return Wo(),null},ui=pn.filter(e=>e!=="recovered"&&e!=="stashed"),rr={type:"object",properties:{currentMapNodeId:{type:"string",description:"Name or ID of the map node the player is currently at."},currentObjective:{type:"string",description:"Short-term objective reflecting the next immediate task. Provide only when updated."},dialogueSetup:{type:"object",description:"Initiates dialogue when context suggests a conversation begins.",properties:{initialNpcResponses:{type:"array",minItems:1,items:{type:"object",properties:{line:{type:"string",description:"Opening line spoken by the NPC."},speaker:{type:"string",description:"Speaker NPC id or name delivering the line."}},propertyOrdering:["line","speaker"],required:["line","speaker"],additionalProperties:!1}},initialPlayerOptions:{type:"array",minItems:Ba,maxItems:Ka,items:{type:"string"},description:"First-person dialogue choices, MUST ALWAYS be in the form of direct speech without quotemarks. The last option must contextually approprialely end the conversation."},participants:{type:"array",minItems:1,items:{type:"string"},description:"NPC IDs or names who take part in the conversation, excluding the player."}},propertyOrdering:["initialNpcResponses","initialPlayerOptions","participants"],required:["initialNpcResponses","initialPlayerOptions","participants"],additionalProperties:!1},localEnvironment:{type:"string",description:"Brief sentence describing the current environment or weather. e.g. 'Clear skies, warm sun'."},localPlace:{type:"string",description:"Player's specific location in the scene, including the Place Name. e.g. 'Inside the Old Mill, near the quern'."},localTime:{type:"string",description:"Concise description of current time. e.g. 'Midday', 'Early morning', '12:30'."},logMessage:{type:"string",description:"Outcome of the player's previous actions, including any significant events, discoveries, or changes in the scene. This should be a concise narrative that captures the essence of what has happened since the last turn, providing additional context for the current scene."},mainQuest:{type:"string",description:"Long-term goal for the player. Provide only when it changes."},mapHint:{type:"string",maxLength:1e3,description:"Short hints about new or changed relevant locations and their connections."},mapUpdated:{type:"boolean",description:"Set to true if new locations or changes mean the map might need updating."},newItems:{type:"array",description:'Brand new items that must appear in the game this turn. Also includes status effects and afflictions of the player with item type "status effect"',items:{type:"object",properties:{activeDescription:{type:"string",description:"Optional description shown when the item is active or equipped."},chapters:{type:"array",description:`For the item types 'page', 'map', or 'picture' - exactly one chapter REQUIRED. For the item type 'book' - between ${String(Cn)} and ${String(En)} chapters REQUIRED.`,items:{type:"object",properties:{contentLength:{type:"number",minLength:50,maxLength:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},description:{type:"string",description:"Concise explanation of what the item is."},isActive:{type:"boolean",description:"Whether the item is currently active, equipped, worn, or piloted (if vehicle)."},knownUses:{type:"array",description:`Optional interactive uses not covered by ${Pn}.`,items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},appliesWhenActive:{type:"boolean",description:"Use is available when item is active."},appliesWhenInactive:{type:"boolean",description:"Use is available when item is inactive."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",items:{enum:ui},description:`Descriptor tags. For written items such as page, book, map, picture, always supply the text style tag, one of ${fo}. Assign 'junk' only to unusable items.`},type:{enum:vt,description:`Item type. One of ${ho}`}},propertyOrdering:["activeDescription","chapters","description","isActive","knownUses","name","tags","type"],required:["description","name","type"],additionalProperties:!1}},npcItemsHint:{type:"string",description:"Summary of items revealed to be carried by NPCs."},librarianHint:{type:"string",description:"Summary of written material updates."},npcsAdded:{type:"array",description:"NPCs introduced this turn.",items:{type:"object",properties:{aliases:{type:"array",items:{type:"string",minItems:1,maxItems:3},description:Ve},description:{type:"string",minLength:100,description:"Concise NPC description including role, appearance and personality."},attitudeTowardPlayer:{type:"string",maxLength:100,description:"Initial attitude toward the player character (free-form text up to 100 characters)."},knowsPlayerAs:{type:"array",items:{type:"string"},description:"Names or aliases this NPC uses for the player. Provide an empty array if they do not know any name yet."},lastKnownLocation:{type:"string",description:"General location when presenceStatus is distant or unknown."},name:{type:"string",description:"Unique NPC name introduced this turn."},preciseLocation:{type:"string",description:"NPC's exact position in the scene when presenceStatus is nearby or companion."},presenceStatus:{enum:Ot,description:"Current relation to the player: companion, nearby or distant."}},propertyOrdering:["aliases","description","attitudeTowardPlayer","knowsPlayerAs","lastKnownLocation","name","preciseLocation","presenceStatus"],required:["aliases","description","attitudeTowardPlayer","knowsPlayerAs","lastKnownLocation","name","presenceStatus"],additionalProperties:!1}},npcsUpdated:{type:"array",description:"Updates to existing NPCs.",items:{type:"object",properties:{addAlias:{type:"string",description:`${Ve} Single alias to append to the NPC record.`},name:{type:"string",description:"Existing NPC name or ID being updated."},newAliases:{type:"array",items:{type:"string",minItems:1,maxItems:3},description:`${Ve} When provided, it replaces all old Aliases for this NPC.`},newDescription:{type:"string",minLength:100,description:"Expanded or revised description for the NPC."},newAttitudeTowardPlayer:{type:"string",maxLength:100,description:"Updated attitude toward the player character (free-form text up to 100 characters)."},newKnownPlayerNames:{type:"array",items:{type:"string"},description:"Updated list of names or aliases this NPC uses for the player. Provide an empty array if none."},newLastKnownLocation:{type:"string",description:"Updated general location if the NPC is away."},newPreciseLocation:{type:"string",description:"Updated exact position in the scene, when newPresenceStatus is nearby or companion."},newPresenceStatus:{enum:Ot,description:"Updated relation to the player or scene."}},propertyOrdering:["addAlias","name","newAliases","newDescription","newAttitudeTowardPlayer","newKnownPlayerNames","newLastKnownLocation","newPreciseLocation","newPresenceStatus"],required:["name"],additionalProperties:!1}},objectiveAchieved:{type:"boolean",description:"True when the current objective was successfully completed this turn."},mainQuestAchieved:{type:"boolean",description:"Set to true when the current act's success condition is undoubtedly met."},options:{type:"array",minItems:ct,maxItems:ct,items:{type:"string"},description:`Exactly ${String(ct)} distinct action options for the player to choose from to progress in the story, tailored to the context. Do NOT use direct speech.`},playerItemsHint:{type:"string",description:"Summary of player item gains, losses or state changes."},sceneDescription:{type:"string",minLength:500,description:"Description of the scene, taking into account the entirety of the player's current situation and surroundings. Include relevant details the player must be aware of to make informed decisions. This should be an engaging text that sets the stage for the player's next actions."},worldItemsHint:{type:"string",description:"Summary of items discovered or dropped in the world."}},required:["currentMapNodeId","localEnvironment","localPlace","localTime","logMessage","options","sceneDescription"],propertyOrdering:["currentMapNodeId","currentObjective","dialogueSetup","localEnvironment","localPlace","localTime","logMessage","mainQuest","mapHint","mapUpdated","newItems","npcItemsHint","librarianHint","npcsAdded","npcsUpdated","objectiveAchieved","mainQuestAchieved","options","playerItemsHint","sceneDescription","worldItemsHint"],additionalProperties:!1},pi=async(e,t)=>{if(!ee())return console.error("API Key not configured for Gemini Service."),Promise.reject(new Error("API Key not configured."));const n=await ie(async o=>{var a,r,i;try{console.log(`Executing storyteller turn (Attempt ${String(o+1)}/${String(B)})`),ae(ne.storyteller.icon);const s=Se(4096),c=(t==null?void 0:t.maxOutputTokensOverride)??tt(4096),l=(t==null?void 0:t.systemInstructionOverride)??Ut,{response:d,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:p}=await oe({modelNames:[Q],prompt:e,systemInstruction:l,temperature:1,thinkingBudget:s,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:rr,label:"Storyteller",maxOutputTokens:c}),g=((i=(r=(a=d.candidates)==null?void 0:a[0])==null?void 0:r.content)==null?void 0:i.parts)??[],f=g.filter(h=>h.thought===!0&&typeof h.text=="string").map(h=>h.text),y=g.filter(h=>h.thought!==!0&&typeof h.text=="string").map(h=>h.text).join(`
`);if(he(y)===null)throw console.warn("executeAIMainTurn: Malformed JSON from AI after in-place fence extraction. Will retry."),new Error("Malformed AI JSON response");return{result:{response:d,thoughts:f,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:p}}}catch(s){throw console.error(`Error executing AI Main Turn (Attempt ${String(o+1)}/${String(B+1)}):`,s),s}});if(n)return n;throw new Error("Failed to execute AI Main Turn after maximum retries.")},mi=(e,t=[],n)=>{const o=e.parentNodeId??K,a=e.description,r=n?n.get(e.id)??[]:t.filter(s=>s.holderId===e.id),i=r.length>0?` Items: ${r.map(s=>`"${s.name}"`).join(", ")}`:"";return` - ${e.id} - "${e.placeName}" (parent: ${o}), "${a}"${i}`},sr=e=>{const t=new Map,n=new Map,o=new Map;return e.nodes.forEach(a=>{t.set(a.id,a);const r=a.parentNodeId??K,i=o.get(r);i?i.push(a):o.set(r,[a])}),e.edges.forEach(a=>{const r=i=>{const s=n.get(i);s?s.push(a):n.set(i,[a])};r(a.sourceNodeId),r(a.targetNodeId)}),{nodesById:t,edgesByNodeId:n,nodesByParentId:o}},gi=e=>{const t=new Map;return e.forEach(n=>{if(!n.holderId)return;const o=t.get(n.holderId);o?o.push(n):t.set(n.holderId,[n])}),t},fi=e=>e==="open"||e==="accessible"||e==="active",hi=e=>{const t=e.nodes,n=e.edges,o=new Map(t.map(l=>[l.id,l])),a=l=>(l??"").replace(/\s+/g," ").trim(),r=l=>l&&l.length>0?`[${l.map(d=>`"${d}"`).join(", ")}]`:"[]",i=l=>{const d=o.get(l);return d?d.type==="feature"?{area:d.parentNodeId&&d.parentNodeId!==K?d.parentNodeId:K,feature:d.id}:{area:d.id,feature:d.id}:{area:"Unknown",feature:l}},s=t.map(l=>`NODE id=${l.id}; name="${l.placeName}"; type=${l.type}; parent=${l.parentNodeId??K}; status=${l.status}; visited=${l.visited===!0?"true":"false"}; aliases=${r(l.aliases)}; desc="${a(l.description)}"`),c=n.filter(l=>o.has(l.sourceNodeId)&&o.has(l.targetNodeId)).filter(l=>!yo.includes(l.status)).map(l=>{const d=i(l.sourceNodeId),u=i(l.targetNodeId),m=l.travelTime??"";return`EDGE id=${l.id}; type=${l.type}; status=${l.status}; fromFeature=${d.feature}; fromArea=${d.area}; toFeature=${u.feature}; toArea=${u.area}; travelTime=${m}; desc="${a(l.description)}"`});return["MAP SNAPSHOT (normalized, line-based)","NODES:",...s,"EDGES:",...c].join(`
`)},yi=(e,t)=>{const n=e.status,o=e.type,a=[];e.travelTime&&a.push(`travel time: ${e.travelTime}`),e.description&&a.push(e.description);const r=a.length>0?` (${a.join(", ")})`:"";return` - ${n} ${o} to "${t.placeName}"${r}.`},It=(e,t=!1,n=!0)=>{const o=e.filter(a=>a.type!=="feature"&&a.type!=="room");return o.length===0?"None specifically known yet.":t?o.map(a=>{let r=" - ";return n&&(r+=`${a.id} - `),r+=`"${a.placeName}"`,a.aliases&&a.aliases.length>0&&(r+=` (aka ${a.aliases.map(i=>`"${i}"`).join(", ")})`),r+=a.status=="rumored"?", rumored":"",r+=`, "${a.description||"No description available."}"`,r}).join(`;
`)+".":o.map(a=>{let r="";return n&&(r+=`${a.id} - `),r+=`"${a.placeName}"`,a.aliases&&a.aliases.length>0&&(r+=` (aka ${a.aliases.map(i=>`"${i}"`).join(", ")})`),r}).join(", ")+"."},Yo=e=>({open:10,accessible:9,active:8,temporary_bridge:6,secret_passage:5,door:4,rumored:3,closed:2,locked:1,blocked:0,inactive:-1})[e]??0,Ho=(e,t,n,o)=>{const a=t.edgesByNodeId.get(e.id)??[],r=new Map;a.forEach(s=>{const c=s.sourceNodeId===e.id?s.targetNodeId:s.sourceNodeId;if(c===n||o.has(c))return;const l=r.get(c);l?l.push(s):r.set(c,[s])});const i=[];return r.forEach((s,c)=>{const l=s.filter(p=>{const g=p.status;return!(yo.includes(g)||g==="one_way"&&p.targetNodeId===e.id)});if(l.length===0)return;l.sort((p,g)=>{const f=(p.sourceNodeId===e.id?100:0)+Yo(p.status);return(g.sourceNodeId===e.id?100:0)+Yo(g.status)-f});const d=l[0],u=t.nodesById.get(c);if(!u)return;const m=yi(d,u);i.push(m),o.add(c)}),i},ir=(e,t,n,o,a)=>{const r=new Set,i=[{nodeId:e,hop:0}],s=new Set([e]);for(;i.length>0;){const c=i.shift();if(c&&(c.nodeId!==e&&r.add(c.nodeId),c.hop<t)){const l=n.edgesByNodeId.get(c.nodeId)??[];for(const d of l){const u=d.sourceNodeId===c.nodeId?d.targetNodeId:d.sourceNodeId;if(s.has(u)||!fi(d.status))continue;const m=n.nodesById.get(u);m&&(m.type==="feature"||m.type,s.add(u),i.push({nodeId:u,hop:c.hop+1}))}}}return r},Jo=(e,t,n=[])=>{if(!t)return"Current location unknown.";const o=sr(e),a=gi(n),r=ir(t,2,o);r.add(t);const i=[];return e.nodes.forEach(s=>{r.has(s.id)&&i.push(mi(s,n,a))}),i.join(`;
`)+"."},wi=(e,t)=>{const n=sr(e);if(!t)return"Player's precise map location is currently unknown or they are between known locations.";const o=n.nodesById.get(t);if(!o)return"";let a=` - You are currently at ${o.id} - "${o.placeName}".`;o.description&&(a+=` ${o.description}.`);const r=o.type==="feature"&&o.parentNodeId&&o.parentNodeId!==K?n.nodesById.get(o.parentNodeId):null;r&&(r.type==="feature"?a+=` This is a feature of "${r.placeName}".`:a+=` This is part of the larger known location: "${r.placeName}".`),a+=`
`;const i=o.type==="feature"?o.parentNodeId&&o.parentNodeId!==K?o.parentNodeId:void 0:o.id;let s="";if(i){const p=n.nodesById.get(i);if(p&&p.type!=="feature"){const g=(n.nodesByParentId.get(p.id)??[]).filter(v=>v.type==="feature"),f=[];if(g.length>0)for(const v of g){if(v.id===o.id)continue;const y=n.edgesByNodeId.get(v.id)??[];for(const w of y){const h=w.status;if(yo.includes(h))continue;const T=w.sourceNodeId===v.id?w.targetNodeId:w.sourceNodeId,I=n.nodesById.get(T);if(I&&I.type==="feature"&&I.parentNodeId&&I.parentNodeId!==p.id&&I.parentNodeId!==K){const S=n.nodesById.get(I.parentNodeId);if(S&&S.type==="feature")continue;if(S){const M=h,k=w.type;f.push(` - '${M} ${k}' exit at '${v.placeName}', leading to '${S.placeName}' via '${I.placeName}'.`)}}}}f.length>0?s=`
Possible Exits from Current Main Area (${p.placeName}):
${f.join(`
`)}`:s=`
No mapped exits from the current main area ("${p.placeName}") to other major areas are known.`}else p&&p.type==="feature"&&(s=`You are at a detailed feature ("${p.placeName}"). Connections to other major areas are listed below if available.`)}else s="Current location is not part of a larger mapped area.";a+=`${s}

`;const c=new Set,l=o.type==="feature"&&r?r.id:null,d=Ho(o,n,l,c),u=r?Ho(r,n,o.id,c):[];d.length>0&&(a+=`Paths leading directly from your current spot (${o.placeName}):
${d.join(`
`)}`),u.length>0&&r&&(d.length>0&&(a+=`

`),a+=`Additional paths and features within or connected to "${r.placeName}":
${u.join(`
`)}`),a+=`
`;const m=ir(o.id,2,n);if(m.size>0){const p=Array.from(m).map(g=>{var f;return(f=n.nodesById.get(g))==null?void 0:f.placeName}).filter(g=>!!g).map(g=>`"${String(g)}"`);p.length>0&&(a+=`
Locations nearby (within two hops): ${p.join(", ")}.`)}return a},cr=async(e,t,n,o,a)=>{if(!ee())return console.error(`fetchCorrectedNPCDetails: API Key not configured. Cannot fetch details for "${e}".`),null;const r=a.length>0?"Known map locations in this theme: "+It(a,!0):"No specific map locations are currently known for this theme.",i=`
You are an AI assistant generating detailed JSON objects for new NPCs.
Provide a suitable description, aliases, presenceStatus, lastKnownLocation, and preciseLocation for a character. Information MUST be derived *strictly* from the provided context.

NPC Name: "${e}"

Context:
- Log Message (how they appeared/what they're doing): "${t??"Not specified, infer from scene."}"
- Scene Description (where they appeared/are relevant): "${n??"Not specified, infer from log."}"
- ${r}
- Theme Guidance (influences NPC style/role): "${o.storyGuidance}"

Respond ONLY in JSON format with the following structure:
{
  "aliases": ["string"],
  "description": "string (A detailed, engaging description fitting the scene and theme. MUST be non-empty.)",
  "lastKnownLocation": "string | null",
  "preciseLocation": "string | null",
  "presenceStatus": ${Is},
  "attitudeTowardPlayer": "string",
  "knowsPlayerAs": { "type": "array", "items": { "type": "string" } }
}

Constraints:
- 'description', 'presenceStatus', and 'attitudeTowardPlayer' are REQUIRED and must be non-empty.
- If 'presenceStatus' is 'nearby' or 'companion', 'preciseLocation' MUST be a descriptive string derived from context; 'lastKnownLocation' can be null or a broader area.
- If 'presenceStatus' is 'distant' or 'unknown', 'preciseLocation' MUST be null; 'lastKnownLocation' should describe general whereabouts or be 'Unknown' if context doesn't specify.
- Provide all names or aliases the NPC uses for the player in 'knowsPlayerAs'. Use an empty array if none are known.
`,s="You generate detailed JSON objects for new NPCs based on narrative context. Provide description, aliases, presenceStatus, attitudeTowardPlayer, knowsPlayerAs, lastKnownLocation, and preciseLocation. Adhere strictly to the JSON format and field requirements. Derive all information strictly from the provided context.";return ie(async c=>{try{ae(ne.corrections.icon);const{response:l}=await oe({modelNames:[z,Q],prompt:i,systemInstruction:s,responseMimeType:"application/json",temperature:Me,label:"Corrections"}),d=he(l.text??""),u=d&&typeof d.attitudeTowardPlayer=="string"?d.attitudeTowardPlayer.trim():null;if(d&&typeof d.description=="string"&&d.description.trim()!==""&&Array.isArray(d.aliases)&&d.aliases.every(m=>typeof m=="string")&&typeof d.presenceStatus=="string"&&Ot.includes(d.presenceStatus)&&(d.attitudeTowardPlayer===void 0||u!==null&&u.length>0&&u.length<=100)&&(d.knowsPlayerAs===void 0||Array.isArray(d.knowsPlayerAs))&&(d.lastKnownLocation===null||typeof d.lastKnownLocation=="string")&&(d.preciseLocation===null||typeof d.preciseLocation=="string")&&!(kn.includes(d.presenceStatus)&&(d.preciseLocation===null||d.preciseLocation===""))&&!(wo.includes(d.presenceStatus)&&d.preciseLocation!==null))return{result:{...d,attitudeTowardPlayer:d.attitudeTowardPlayer??Mn,knowsPlayerAs:Array.isArray(d.knowsPlayerAs)?d.knowsPlayerAs:[]}};console.warn(`fetchCorrectedNPCDetails (Attempt ${String(c+1)}/${String(B+1)}): Corrected details for "${e}" invalid or incomplete. Response:`,d)}catch(l){throw console.error(`fetchCorrectedNPCDetails error (Attempt ${String(c+1)}/${String(B+1)}):`,l),l}return{result:null}})},vi=xs,Ii=vi.type,qn=new Set(["destroyed","consumed","deleted","removed","lost","gone","broken"]);function vn(e){if(typeof e!="string")return null;const t=e.toLowerCase().trim();return vt.includes(t)?t:Ii[t]??null}const Co=Us,Eo=_s,Ni=Co.status,bi=Co.type,Ai=Eo.type,Si=Eo.status,Ti=Co.remove,Pi=Eo.remove;function zn(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function Ci(e,t){const n={};for(const a of t)n[a]=[zn(a)];for(const[a,r]of Object.entries(e)){let i=n[r];i||(i=[zn(r)],n[r]=i),i.push(zn(a))}const o=[];for(const[a,r]of Object.entries(n)){if(!r)continue;const i=r.map(s=>s.replace(/\s+/g,"\\s+")).join("|");o.push([new RegExp(i,"i"),a])}return o}const Ei=js,ki=Ei.tag;function Mi(e){if(typeof e!="string")return null;const t=e.toLowerCase().trim();return pn.includes(t)?t:ki[t]??null}function $i(e){if(!Array.isArray(e))return null;const t=[];for(const n of e){const o=Mi(n);o&&t.push(o)}return t}const qo=new Set(Ns),Qn=new Set($e),Li=new Set(bs);function Di(e,t){const n=`${e} ${t}`.toLowerCase();return/(handwritten|scribbled|ink|pen|quill)/.test(n)?"handwritten":/(typewriter|typed)/.test(n)?"typed":/(digital|screen|display|tablet|monitor|terminal)/.test(n)?"digital":"printed"}function ko(e){if(!e||typeof e!="object")return!1;const t=e;return!(typeof t.actionName!="string"||t.actionName.trim()===""||typeof t.promptEffect!="string"||t.promptEffect.trim()===""||t.appliesWhenActive!==void 0&&typeof t.appliesWhenActive!="boolean"||t.appliesWhenInactive!==void 0&&typeof t.appliesWhenInactive!="boolean"||typeof t.description!="string"||t.description.trim()==="")}function zo(e,t){if(!e||typeof e!="object")return!1;const n=e;if(typeof n.type=="string"){const r=vn(n.type);r&&(n.type=r)}if(typeof n.name!="string"||n.name.trim()==="")return console.warn("isValidItem: 'name' is missing or invalid.",e),!1;if(t==="create"||!t){if(typeof n.type!="string"||!vt.includes(n.type))return console.warn(`isValidItem (context: ${t??"default"}): 'type' is missing or invalid.`,e),!1;if(typeof n.description!="string"||n.description.trim()==="")return console.warn(`isValidItem (context: ${t??"default"}): 'description' is missing or invalid.`,e),!1;if(typeof n.holderId!="string"||n.holderId.trim()==="")return console.warn(`isValidItem (context: ${t??"default"}): 'holderId' is missing or invalid.`,e),!1}if(t==="change"&&n.newName!=null&&(typeof n.newName!="string"||n.newName.trim()===""))return console.warn("isValidItem (context: change, with newName): 'newName' is invalid.",e),!1;if(n.type!==void 0){const r=vn(n.type);if(!r)return console.warn("isValidItem: 'type' is present but invalid.",e),!1;n.type=r}if(n.description!==void 0&&(typeof n.description!="string"||n.description.trim()==="")&&(t==="create"||t==="change"&&n.newName)&&n.description.trim()==="")return console.warn("isValidItem: 'description' is present but empty, which is invalid for a create or transformation.",e),!1;if(n.activeDescription!==void 0){if(n.activeDescription===null){if(t!=="change")return console.warn("isValidItem: 'activeDescription' cannot be null for this context.",e),!1}else if(typeof n.activeDescription!="string")return console.warn("isValidItem: 'activeDescription' is present but invalid.",e),!1}if(n.isActive!==void 0&&typeof n.isActive!="boolean")return console.warn("isValidItem: 'isActive' is present but invalid.",e),!1;if(n.stashed!==void 0&&typeof n.stashed!="boolean")return console.warn("isValidItem: 'stashed' is present but invalid.",e),!1;if(n.tags!==void 0){if(!Array.isArray(n.tags)||!n.tags.every(s=>typeof s=="string"))return console.warn("isValidItem: 'tags' is present but invalid.",e),!1;const r=$i(n.tags);r?n.tags=r:n.tags=n.tags.filter(s=>pn.includes(s));const i=n.type===void 0?pn:Qn.has(n.type)?[...lt,...mn]:lt;n.tags=n.tags.filter(s=>i.includes(s))}if(Qn.has(n.type??"")){n.tags=n.tags??[];const r=n.tags.filter(i=>qo.has(i));if(r.length===0){const i=Di(n.name,n.description??"");n.tags.unshift(i)}else if(r.length>1){const[i]=r;n.tags=[i,...n.tags.filter(s=>!qo.has(s))]}}if(n.holderId!==void 0&&(typeof n.holderId!="string"||n.holderId.trim()===""))return console.warn("isValidItem: 'holderId' is present but invalid.",e),!1;const o=r=>Array.isArray(r)&&r.every(i=>i&&typeof i=="object"&&typeof i.heading=="string"&&typeof i.description=="string"&&typeof i.contentLength=="number"&&(i.imageData===void 0||typeof i.imageData=="string")),a=n.type;if(a&&Qn.has(a)){if(n.chapters!==void 0){if(!o(n.chapters))return console.warn("isValidItem: 'chapters' is present but invalid.",e),!1;Li.has(a)&&n.chapters.length>1&&(n.chapters=[n.chapters[0]])}else{const r=typeof n.contentLength=="number"?n.contentLength:30;n.chapters=[{heading:n.name,description:n.description??"",contentLength:r,actualContent:typeof n.actualContent=="string"?n.actualContent:void 0,visibleContent:typeof n.visibleContent=="string"?n.visibleContent:void 0}]}delete n.contentLength,delete n.actualContent,delete n.visibleContent}else if(n.chapters!==void 0&&!o(n.chapters))return console.warn("isValidItem: 'chapters' is present but invalid for non-book/page item.",e),!1;return n.contentLength!==void 0&&typeof n.contentLength!="number"?(console.warn("isValidItem: 'contentLength' is present but invalid.",e),!1):n.actualContent!==void 0&&typeof n.actualContent!="string"?(console.warn("isValidItem: 'actualContent' is present but invalid.",e),!1):n.visibleContent!==void 0&&typeof n.visibleContent!="string"?(console.warn("isValidItem: 'visibleContent' is present but invalid.",e),!1):n.knownUses!==void 0&&!(Array.isArray(n.knownUses)&&n.knownUses.every(ko))?(console.warn("isValidItem: 'knownUses' is present but invalid.",e),!1):!0}function Qo(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.name=="string"&&t.name.trim()!==""}function lr(e){if(!e||typeof e!="object")return!1;const t=e;if(typeof t.id!="string"||t.id.trim()===""||typeof t.name!="string"||t.name.trim()===""||typeof t.type!="string"||!vt.includes(t.type))return!1;const n=["page","book","map","picture"].includes(t.type);if(t.knownUses===void 0&&t.tags===void 0&&t.chapters===void 0||t.knownUses!==void 0&&!(Array.isArray(t.knownUses)&&t.knownUses.every(ko)))return!1;const o=n?[...lt,...mn]:lt,a=Array.isArray(t.tags)&&t.tags.every(i=>o.includes(i)),r=Array.isArray(t.chapters)&&t.chapters.every(i=>{const s=i;return typeof s.heading=="string"&&typeof s.description=="string"&&typeof s.contentLength=="number"});if(n){if(!a||!r)return!1}else if(t.tags!==void 0&&!a||t.chapters!==void 0&&!r)return!1;return!0}function Ri(e){if(!e||typeof e!="object")return!1;const t=e;if(typeof t.type=="string"){const n=vn(t.type);n&&(t.type=n)}return t.activeDescription!==void 0&&(t.activeDescription===null||typeof t.activeDescription!="string")||t.tags!==void 0&&(!Array.isArray(t.tags)||!t.tags.every(n=>typeof n=="string"))||t.knownUses!==void 0&&!(Array.isArray(t.knownUses)&&t.knownUses.every(ko))||t.chapters!==void 0&&!Array.isArray(t.chapters)?!1:typeof t.name=="string"&&t.name.trim()!==""&&typeof t.description=="string"&&t.description.trim()!==""&&typeof t.type=="string"&&vt.includes(t.type)}function Oi(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name!="string"||t.name.trim()===""||t.newDescription!==void 0&&typeof t.newDescription!="string"||t.newAliases!==void 0&&!(Array.isArray(t.newAliases)&&t.newAliases.every(n=>typeof n=="string"))||t.addAlias!==void 0&&typeof t.addAlias!="string"||t.newPresenceStatus!==void 0&&!Ot.includes(t.newPresenceStatus)||t.newAttitudeTowardPlayer!==void 0&&typeof t.newAttitudeTowardPlayer!="string"||t.newKnownPlayerNames!==void 0&&(!Array.isArray(t.newKnownPlayerNames)||!t.newKnownPlayerNames.every(n=>typeof n=="string"))||t.newLastKnownLocation!==void 0&&t.newLastKnownLocation!=null&&typeof t.newLastKnownLocation!="string"||t.newPreciseLocation!==void 0&&t.newPreciseLocation!=null&&typeof t.newPreciseLocation!="string"?!1:(typeof t.newPresenceStatus=="string"&&kn.includes(t.newPresenceStatus)&&t.newPreciseLocation===void 0&&console.warn("isValidNPCUpdate: 'newPreciseLocation' must be provided when 'newPresenceStatus' is nearby or companion.",e),typeof t.newPresenceStatus=="string"&&wo.includes(t.newPresenceStatus)&&t.newPreciseLocation!=null&&console.warn("isValidNPCUpdate: 'newPreciseLocation' must be omitted when 'newPresenceStatus' is distant or unknown.",e),!0)}function xi(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name!="string"||t.name.trim()===""||typeof t.description!="string"||t.description.trim()===""||t.aliases!==void 0&&!(Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))||t.presenceStatus!==void 0&&!Ot.includes(t.presenceStatus)||typeof t.attitudeTowardPlayer!="string"||t.knowsPlayerAs!==void 0&&(!Array.isArray(t.knowsPlayerAs)||t.knowsPlayerAs.some(n=>typeof n!="string"))||t.lastKnownLocation!==void 0&&t.lastKnownLocation!=null&&typeof t.lastKnownLocation!="string"||t.preciseLocation!==void 0&&t.preciseLocation!=null&&typeof t.preciseLocation!="string"?!1:(typeof t.presenceStatus=="string"&&kn.includes(t.presenceStatus)&&t.preciseLocation===void 0&&console.warn("isValidNewNPCPayload: 'preciseLocation' must be provided when 'presenceStatus' is nearby or companion.",e),typeof t.presenceStatus=="string"&&wo.includes(t.presenceStatus)&&t.preciseLocation!=null&&console.warn("isValidNewNPCPayload: 'preciseLocation' must be omitted when 'presenceStatus' is distant or unknown.",e),!0)}function so(e){if(!e||typeof e!="object")return console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup is missing or not an object."),!1;const t=e;if(!Array.isArray(t.participants)||t.participants.length===0||!t.participants.every(o=>typeof o=="string"&&o.trim()!==""))return console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.participants is invalid.",t.participants),!1;const n=t.participants;return!Array.isArray(t.initialNpcResponses)||t.initialNpcResponses.length===0||!t.initialNpcResponses.every(o=>o&&typeof o.speaker=="string"&&o.speaker.trim()!==""&&n.includes(o.speaker)&&typeof o.line=="string"&&o.line.trim()!=="")?(console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.initialNpcResponses is invalid.",t.initialNpcResponses),!1):!Array.isArray(t.initialPlayerOptions)||t.initialPlayerOptions.length<4||!t.initialPlayerOptions.every(o=>typeof o=="string"&&o.trim()!=="")?(console.warn("isDialogueSetupPayloadStructurallyValid: dialogueSetup.initialPlayerOptions is invalid.",t.initialPlayerOptions),!1):!0}const Ui=async(e,t,n,o)=>{if(!ee())return console.error("fetchCorrectedAddDetailsPayload: API Key not configured."),null;const a=`You are an AI assistant fixing a malformed addDetails JSON object for a text adventure game.

Malformed Payload:
\`\`\`json
${e}
\`\`\`

Log Message: "${t??"Not specified"}"
Scene Description: "${n??"Not specified"}"
Theme Guidance: "${o.storyGuidance}"

Task: Provide ONLY the corrected JSON object with fields { "id": string, "name": string, "type": (${ho}), "knownUses"?, "tags"?, "chapters"? }.`,r="Return only the corrected addDetails JSON object.";let i=a,s=null;return ie(async c=>{try{ae(ne.corrections.icon),c>0&&s?i=`${a}

[Parser Feedback]
${s}`:i=a;const{response:l}=await oe({modelNames:[z,Q],prompt:i,systemInstruction:r,responseMimeType:"application/json",temperature:Me,label:"Corrections"}),d=l.text??"",u=he(d);if(u&&lr(u))return s=null,{result:u};console.warn(`fetchCorrectedAddDetailsPayload (Attempt ${String(c+1)}/${String(B+1)}): invalid response`,u),s="Corrected addDetails payload must include id, name, valid type, and optional knownUses/tags/chapters with proper structure."}catch(l){throw console.error(`fetchCorrectedAddDetailsPayload error (Attempt ${String(c+1)}/${String(B+1)}):`,l),l}return{result:null}})},_i=async(e,t,n,o)=>{if(!ee())return console.error("fetchFullPlaceDetailsForNewMapNode: API Key not configured."),null;const a=`You are an AI assistant that generates detailed information for a new game map location (a main MapNode) that has just been added to the game map. The Map AI should have provided these details, but this is a fallback.
Given the name of this new map location and the current narrative context, provide a suitable description and aliases for it. The provided 'Map Location Name to Detail' is fixed and MUST be used as the 'name' in your JSON response.

Map Location Name to Detail: "${e}"

## Narrative Context:
- Log Message: "${t??"Not specified"}"
- Scene Description: "${n??"Not specified"}"
- Theme Guidance: "${o.storyGuidance}"

Required JSON Structure:
{
  "aliases": ["string"], // ${Ve}
  "description": "string", // ${ut}
  "name": "${e}"
}

Respond ONLY with the single, complete JSON object.`,r=`Generate detailed JSON for a new game map location. The 'name' field in the output is predetermined and MUST match the input. Focus on creating ${ut} and aliases (${Ve}, array, can be empty). Adhere strictly to the JSON format.`;return ie(async i=>{try{ae(ne.corrections.icon);const{response:s}=await oe({modelNames:[z,Q],prompt:a,systemInstruction:r,responseMimeType:"application/json",temperature:Me,label:"Corrections"}),c=he(s.text??"");if(c&&typeof c.name=="string"&&c.name===e&&typeof c.description=="string"&&c.description.trim()!==""&&Array.isArray(c.aliases)&&c.aliases.every(l=>typeof l=="string"))return{result:c};console.warn(`fetchFullPlaceDetailsForNewMapNode (Attempt ${String(i+1)}/$${String(B+1)}): Corrected map location payload invalid or name mismatch for "${e}". Response:`,c)}catch(s){throw console.error(`fetchFullPlaceDetailsForNewMapNode error (Attempt ${String(i+1)}/$${String(B+1)}):`,s),s}return{result:null}})},ji=async(e,t,n)=>{if(!ee())return console.error("fetchLikelyParentNode: API Key not configured."),null;const o=t.currentMapNodeId&&t.mapNodes.find(m=>m.id===t.currentMapNodeId),a=new Map;t.mapNodes.forEach(m=>a.set(m.id,m));const r=new Map;t.mapNodes.forEach(m=>r.set(m.id,new Set)),t.mapEdges.forEach(m=>{r.has(m.sourceNodeId)||r.set(m.sourceNodeId,new Set),r.has(m.targetNodeId)||r.set(m.targetNodeId,new Set);const p=r.get(m.sourceNodeId);p&&p.add(m.targetNodeId);const g=r.get(m.targetNodeId);g&&g.add(m.sourceNodeId)});const i=e.type??"feature",s=Oe[i],c=t.mapNodes.filter(m=>Oe[m.type]<s).map(m=>`- ${m.id} ("${m.placeName}")`).join(`
`),l=t.mapEdges.map(m=>`${m.id} ${m.sourceNodeId}->${m.targetNodeId}`).join(`
`),d=`Map Node: "${e.placeName}" (${e.type??"feature"})
Scene: "${t.sceneDescription}"
Current location: ${t.localPlace}
Current Map Node: ${o?o.placeName:"Unknown"}

## Possible Nodes:
${c}

## Edges:
${l}

Respond ONLY with the name or id of the best parent node, or "${K}" if none.`,u=`Choose the most logical parent node name or id for the provided Map Node. If none is suitable use "${K}".`;return ie(async m=>{var p;try{ae(ne.corrections.icon);const{response:g}=await oe({modelNames:[be,z,Q],prompt:d,systemInstruction:u,temperature:Me,label:"Corrections",debugLog:n}),f=(p=g.text)==null?void 0:p.trim();if(f)return{result:f.trim()}}catch(g){throw console.error(`fetchLikelyParentNode error (Attempt ${String(m+1)}/$${String(B+1)}):`,g),g}return{result:null}})},Fi=async(e,t,n)=>{if(!ee())return console.error("fetchCorrectedNodeIdentifier: API Key not configured."),null;const o=t.mapNodes.map(i=>`- ${i.id} ("${i.placeName}")`).join(`
`),a=`A different AI referred to a map location using an incorrect identifier: "${e}".
Known map nodes in the current theme:
${o}
Choose the most likely intended node ID from the list above. Respond with an empty string if none match.`,r="Respond ONLY with a single node ID from the list or an empty string.";return ie(async i=>{var s;try{ae(ne.corrections.icon);const{response:c}=await oe({modelNames:[be,z,Q],prompt:a,systemInstruction:r,temperature:Me,label:"Corrections",debugLog:n}),l=(s=c.text)==null?void 0:s.trim();if(l){const d=l.trim(),u=t.mapNodes.find(p=>p.id===d);if(u)return{result:u.id};const m=t.mapNodes.find(p=>p.placeName===d);if(m)return{result:m.id}}}catch(c){throw console.error(`fetchCorrectedNodeIdentifier error (Attempt ${String(i+1)}/$${String(B+1)}):`,c),c}return{result:null}})},Vi={type:"object",properties:{observations:{type:"string",minLength:1500,description:"Contextually relevant observations about the chains and map graph."},rationale:{type:"string",minLength:1e3,description:"Explain the reasoning behind your chain fixes and refinement suggestions."},edgesToAdd:{type:"array",items:{type:"object",properties:{description:{type:"string",minLength:30,description:Ht},sourcePlaceName:{type:"string",description:"Name of the source feature node. MUST be a feature type node."},status:{enum:qe},targetPlaceName:{type:"string",description:"Name of the target feature node. MUST be a feature type node."},travelTime:{type:"string"},type:{enum:Je}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","status","targetPlaceName","type"],additionalProperties:!1}},nodesToAdd:{type:"array",description:"List of nodes to add to the map.",minItems:1,items:{type:"object",properties:{aliases:{type:"array",description:Ve,minItems:2,items:{type:"string"}},description:{type:"string",minLength:30,description:ut},type:{enum:["feature"]},parentNodeId:{type:"string",description:`Name of the Parent Node this feature belongs to, or '${K}' (keyword for root node) if it has no parent`},placeName:{type:"string",description:"A contextually relevant location name, based on Theme and Scene Description"},status:{enum:pt}},propertyOrdering:["aliases","description","parentNodeId","placeName","status","type"],required:["aliases","description","parentNodeId","placeName","status","type"],additionalProperties:!1}}},required:["observations","rationale","edgesToAdd","nodesToAdd"],propertyOrdering:["observations","rationale","edgesToAdd","nodesToAdd"],additionalProperties:!1},Gi=async(e,t)=>{if(!ee()||e.length===0)return{payload:null,debugInfo:null};const o=(()=>{const s=new Map,c=new Map,l=[];e.forEach((m,p)=>{const g=new Set,f=[];[...m.sourceChain,...m.targetChain.slice().reverse()].forEach(v=>{v.type!=="feature"&&!g.has(v.id)&&(f.push(v),g.add(v.id),s.set(v.id,v))}),f.length===0&&(g.has(m.originalSource.id)||(f.push(m.originalSource),g.add(m.originalSource.id),s.set(m.originalSource.id,m.originalSource)),g.has(m.originalTarget.id)||(f.push(m.originalTarget),g.add(m.originalTarget.id),s.set(m.originalTarget.id,m.originalTarget)));for(let v=0;v<f.length-1;v++){const y=f[v],w=f[v+1],h=y.id<w.id?`${y.id}|${w.id}`:`${w.id}|${y.id}`;c.has(h)||c.set(h,{source:y,target:w,data:m.edgeData})}l.push(`Chain ${String(p+1)}: ${f.map(v=>`"${v.placeName}"`).join(" -> ")}`)});const d=Array.from(s.values()).map((m,p)=>{const g=t.mapNodes.filter(f=>f.parentNodeId===m.id&&f.type==="feature").map(f=>` - "${f.placeName}" (${f.type}, ${f.status}, ${f.description})`).join(`
`)||" - None";return`Node ${String(p+1)}: "${m.placeName}" (Type: ${m.type}, Status: ${m.status}, Description: ${m.description})
${g}`}).join(`
`),u=Array.from(c.values()).map((m,p)=>{const g=m.data.type,f=m.data.status;return`Edge ${String(p+1)}: "${m.source.placeName}" -> "${m.target.placeName}" (Type: ${g}, Status: ${f}, Desc: ${m.data.description??"None"})`}).join(`
`);return`Parent Nodes:
${d}

Edges:
${u}

Chains:
${l.join(`
`)}`})(),a=`Suggest chains of locations (feature nodes) to connect distant map nodes in a text adventure.
** Context: **
Scene Description: "${t.sceneDescription}"
Theme: "${t.theme.name}" (${t.theme.storyGuidance})

---

## Graph:
${o}`,r=`Imagine a Player travelling along the provided chains. For each Parent Node in the graph imagine locations within them that may connect them to their neighbours.
CHOOSE ONE for each Parent Node:
- IF there is a contextually appropriate feature node already present under that Parent Node, use it directly in edgesToAdd.
- IF there is 'None', or no appropriate candidate feature node exists under that Parent Node, you MUST use nodesToAdd to add a contextually appropriate feature node with full information, based on Context.

ALWAYS choose between selecting an existing feature node OR adding a new one. NEVER leave a Parent Node without a feature node connected to neighbour Parent Nodes' feature nodes.
You can add edges ONLY between feature nodes. NEVER try to connect feature nodes to Parent Nodes directly. NEVER try to connect Parent Nodes to each other.
New edges MUST inherit the original chain edge type and status.
Every new node MUST have a unique placeName. Use only the valid node/edge status and type values.
Edges MUST connect ALL feature nodes along each chain path using the shared feature nodes for common Parent Nodes.

${za}
${Qa}
${Xa}
`;return await ie(async s=>{var c,l,d;try{console.log(`fetchConnectorChains (Attempt ${String(s+1)}/${String(B+1)})`),ae(ne.corrections.icon);const u=Se(2048),{response:m}=await oe({modelNames:[z,Q],prompt:a,systemInstruction:r,thinkingBudget:u,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:Vi,temperature:Me,label:"Corrections"}),g=(((d=(l=(c=m.candidates)==null?void 0:c[0])==null?void 0:l.content)==null?void 0:d.parts)??[]).filter(w=>w.thought===!0&&typeof w.text=="string").map(w=>w.text),f={prompt:a,rawResponse:m.text??"",parsedPayload:void 0,validationError:void 0,observations:void 0,rationale:void 0,thoughts:g.length>0?g:void 0},v=he(m.text??"");if(!v)return f.validationError="Failed to parse JSON",{result:{payload:null,debugInfo:f}};let y=null;return Array.isArray(v)?y=v.reduce((w,h)=>{if(h&&typeof h=="object"){const T=h;Array.isArray(T.nodesToAdd)&&(w.nodesToAdd=[...w.nodesToAdd??[],...T.nodesToAdd]),Array.isArray(T.edgesToAdd)&&(w.edgesToAdd=[...w.edgesToAdd??[],...T.edgesToAdd]),T.observations&&!w.observations&&(w.observations=T.observations),T.rationale&&!w.rationale&&(w.rationale=T.rationale)}return w},{}):typeof v=="object"&&(y=v),f.parsedPayload=y??void 0,y&&(y.observations&&!f.observations&&(f.observations=y.observations),y.rationale&&!f.rationale&&(f.rationale=y.rationale)),y&&(y.nodesToAdd||y.edgesToAdd)?{result:{payload:y,debugInfo:f}}:(f.validationError="Parsed JSON missing nodesToAdd or edgesToAdd",{result:{payload:null,debugInfo:f}})}catch(u){throw console.error(`fetchConnectorChains error (Attempt ${String(s+1)}/${String(B+1)}):`,u),u}})??{payload:null,debugInfo:null}},Ki=async(e,t,n)=>{if(!ee())return console.error("decideFeatureHierarchyUpgrade: API Key not configured."),null;const o=`A feature node has acquired a child which violates the map hierarchy rules.
Parent Feature: "${e.placeName}" (Desc: "${e.description}")
Child Node: "${t.placeName}" (Type: ${t.type})
Choose the best fix: "convert_child" to make the child a sibling, or "upgrade_parent" to upgrade the parent to a higher-level node.`,a="Respond only with convert_child or upgrade_parent.";return ie(async r=>{var i;try{ae(ne.corrections.icon);const{response:s}=await oe({modelNames:[be,z,Q],prompt:o,systemInstruction:a,temperature:Me,label:"Corrections",debugLog:n}),c=((i=s.text)==null?void 0:i.trim())??null;if(c){const l=c.trim().toLowerCase();if(l.includes("upgrade"))return{result:"upgrade_parent"};if(l.includes("convert")||l.includes("sibling"))return{result:"convert_child"}}}catch(s){throw console.error(`decideFeatureHierarchyUpgrade error (Attempt ${String(r+1)}/$${String(B+1)}):`,s),s}return{result:null}})},Bi=async(e,t)=>{if(!ee())return console.error("chooseHierarchyResolution: API Key not configured."),null;const n=e.options.map((r,i)=>`${String(i+1)}. ${r}`).join(`
`),o=`Scene: ${e.sceneDescription}
Parent: "${e.parent.placeName}" (${e.parent.type}) - ${e.parent.description}
Child: "${e.child.placeName}" (${e.child.type}) - ${e.child.description}
Choose the most sensible resolution for their hierarchy conflict:
${n}
Respond ONLY with the option number.`,a="Answer with the single number of the best option.";return ie(async r=>{var i;try{ae(ne.corrections.icon);const{response:s}=await oe({modelNames:[be,z,Q],prompt:o,systemInstruction:a,temperature:Me,label:"Corrections",debugLog:t}),c=(i=s.text)==null?void 0:i.trim();if(c){const l=parseInt(c.trim(),10);if(Number.isInteger(l)&&l>=1&&l<=e.options.length)return{result:l}}}catch(s){throw console.error(`chooseHierarchyResolution error (Attempt ${String(r+1)}/$${String(B+1)}):`,s),s}return{result:null}})};function Wi(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.placeName!="string"||t.placeName.trim()===""?(console.warn("Validation Error (NodeAdd): 'placeName' is required. Value:",t.placeName),!1):!Array.isArray(t.aliases)||!t.aliases.every(n=>typeof n=="string")?(console.warn("Validation Error (NodeAdd): 'aliases' must be an array of strings. Value:",t.aliases),!1):typeof t.description!="string"||t.description.trim()===""?(console.warn("Validation Error (NodeAdd): 'description' is required and must be a non-empty string. Value:",t.description),!1):typeof t.type!="string"||!mt.includes(t.type)?(console.warn("Validation Error (NodeAdd): 'type' is invalid. Value:",t.type),!1):typeof t.parentNodeId!="string"||t.parentNodeId.trim()===""?(console.warn("Validation Error (NodeAdd): 'parentNodeId' is required. Value:",t.parentNodeId),!1):typeof t.status!="string"||!pt.includes(t.status)?(console.warn("Validation Error (NodeAdd): 'status' is invalid. Value:",t.status),!1):!0}function Yi(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.placeName!="string"||t.placeName.trim()===""?(console.warn("Validation Error (NodeUpdate): 'placeName' is required. Value:",t.placeName),!1):t.aliases!==void 0&&!(Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))?(console.warn("Validation Error (NodeUpdate): 'aliases' must be an array of strings if provided. Value:",t.aliases),!1):t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (NodeUpdate): 'description' must be a string if provided. Value:",t.description),!1):t.type!==void 0&&(typeof t.type!="string"||!mt.includes(t.type))?(console.warn("Validation Error (NodeUpdate): 'type' is invalid. Value:",t.type),!1):t.parentNodeId!==void 0&&typeof t.parentNodeId!="string"?(console.warn("Validation Error (NodeUpdate): 'parentNodeId' must be a string if provided. Value:",t.parentNodeId),!1):t.status!==void 0&&(typeof t.status!="string"||!pt.includes(t.status))?(console.warn("Validation Error (NodeUpdate): 'status' is invalid. Value:",t.status),!1):t.newPlaceName!==void 0&&(typeof t.newPlaceName!="string"||t.newPlaceName.trim()==="")?(console.warn("Validation Error (NodeUpdate): 'newPlaceName' must be a non-empty string if provided. Value:",t.newPlaceName),!1):!0}function Hi(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.sourcePlaceName!="string"||t.sourcePlaceName.trim()===""?(console.warn("Validation Error (EdgeAdd): 'sourcePlaceName' is required. Value:",t.sourcePlaceName),!1):typeof t.targetPlaceName!="string"||t.targetPlaceName.trim()===""?(console.warn("Validation Error (EdgeAdd): 'targetPlaceName' is required. Value:",t.targetPlaceName),!1):typeof t.type!="string"||!Je.includes(t.type)?(console.warn("Validation Error (EdgeAdd): 'type' is invalid. Value:",t.type),!1):typeof t.status!="string"||!qe.includes(t.status)?(console.warn("Validation Error (EdgeAdd): 'status' is invalid. Value:",t.status),!1):t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (EdgeAdd): 'description' must be a string if provided. Value:",t.description),!1):t.travelTime!==void 0&&typeof t.travelTime!="string"?(console.warn("Validation Error (EdgeAdd): 'travelTime' must be a string if provided. Value:",t.travelTime),!1):!0}function Ji(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.sourcePlaceName!="string"||t.sourcePlaceName.trim()===""?(console.warn("Validation Error (EdgeUpdate): 'sourcePlaceName' is required. Value:",t.sourcePlaceName),!1):typeof t.targetPlaceName!="string"||t.targetPlaceName.trim()===""?(console.warn("Validation Error (EdgeUpdate): 'targetPlaceName' is required. Value:",t.targetPlaceName),!1):t.type!==void 0&&(typeof t.type!="string"||!Je.includes(t.type))?(console.warn("Validation Error (EdgeUpdate): 'type' is invalid. Value:",t.type),!1):t.status!==void 0&&(typeof t.status!="string"||!qe.includes(t.status))?(console.warn("Validation Error (EdgeUpdate): 'status' is invalid. Value:",t.status),!1):t.description!==void 0&&typeof t.description!="string"?(console.warn("Validation Error (EdgeUpdate): 'description' must be a string if provided. Value:",t.description),!1):t.travelTime!==void 0&&typeof t.travelTime!="string"?(console.warn("Validation Error (EdgeUpdate): 'travelTime' must be a string if provided. Value:",t.travelTime),!1):!0}function dr(e){return typeof e!="object"||e===null?(console.warn("Validation Error (AIMapUpdatePayload): Payload is not an object or is null."),!1):e.nodesToAdd!=null&&(!Array.isArray(e.nodesToAdd)||!e.nodesToAdd.every(Wi))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToAdd' is invalid."),!1):e.nodesToUpdate!=null&&(!Array.isArray(e.nodesToUpdate)||!e.nodesToUpdate.every(Yi))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToUpdate' is invalid."),!1):e.nodesToRemove!=null&&(!Array.isArray(e.nodesToRemove)||!e.nodesToRemove.every(qi))?(console.warn("Validation Error (AIMapUpdatePayload): 'nodesToRemove' is invalid."),!1):e.edgesToAdd!=null&&(!Array.isArray(e.edgesToAdd)||!e.edgesToAdd.every(Hi))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToAdd' is invalid."),!1):e.edgesToUpdate!=null&&(!Array.isArray(e.edgesToUpdate)||!e.edgesToUpdate.every(Ji))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToUpdate' is invalid."),!1):e.edgesToRemove!=null&&(!Array.isArray(e.edgesToRemove)||!e.edgesToRemove.every(zi))?(console.warn("Validation Error (AIMapUpdatePayload): 'edgesToRemove' is invalid."),!1):e.suggestedCurrentMapNodeId!=null&&typeof e.suggestedCurrentMapNodeId!="string"?(console.warn("Validation Error (AIMapUpdatePayload): 'suggestedCurrentMapNodeId' must be a string or null if present. Value:",e.suggestedCurrentMapNodeId),!1):!0}function qi(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.nodeId!="string"||t.nodeId.trim()===""?(console.warn("Validation Error (NodeRemove): 'nodeId' is required. Value:",t.nodeId),!1):t.nodeName!==void 0&&(typeof t.nodeName!="string"||t.nodeName.trim()==="")?(console.warn("Validation Error (NodeRemove): 'nodeName' must be a non-empty string if provided. Value:",t.nodeName),!1):!0}function zi(e){if(typeof e!="object"||e===null)return!1;const t=e;return typeof t.edgeId!="string"||t.edgeId.trim()===""?(console.warn("Validation Error (EdgeRemove): 'edgeId' is required. Value:",t.edgeId),!1):t.sourceId!==void 0&&(typeof t.sourceId!="string"||t.sourceId.trim()==="")?(console.warn("Validation Error (EdgeRemove): 'sourceId' must be a non-empty string if provided. Value:",t.sourceId),!1):t.targetId!==void 0&&(typeof t.targetId!="string"||t.targetId.trim()==="")?(console.warn("Validation Error (EdgeRemove): 'targetId' must be a non-empty string if provided. Value:",t.targetId),!1):!0}const Xo=(e,t,n)=>{if(e){if(typeof e.status=="string"){const o=Ni[e.status.toLowerCase()];o!==void 0&&(e.status=o),pt.includes(e.status)||t.push(`${n} invalid status "${e.status}"`)}if(typeof e.type=="string"){const o=bi[e.type.toLowerCase()];o!==void 0&&(e.type=o),mt.includes(e.type)||t.push(`${n} invalid type "${e.type}"`)}}},Zo=(e,t,n)=>{if(e){if(typeof e.type=="string"){const o=Ai[e.type.toLowerCase()];o!==void 0&&(e.type=o),Je.includes(e.type)||t.push(`${n} invalid type "${e.type}"`)}if(typeof e.status=="string"){const o=Si[e.status.toLowerCase()];o!==void 0&&(e.status=o),qe.includes(e.status)||t.push(`${n} invalid status "${e.status}"`)}}},Qi=new Set(Ti),Xi=new Set(Pi);function Zi(e){const t=[],n=e.nodesToRemove?[...e.nodesToRemove]:[];(e.nodesToUpdate??[]).forEach(r=>{const i=typeof r.status=="string"?r.status.toLowerCase():void 0;i&&Qi.has(i)?n.push({nodeId:r.placeName,nodeName:r.placeName}):t.push(r)}),e.nodesToUpdate=t.length>0?t:void 0,e.nodesToRemove=n.length>0?n:void 0;const o=[],a=e.edgesToRemove?[...e.edgesToRemove]:[];(e.edgesToUpdate??[]).forEach(r=>{const i=typeof r.status=="string"?r.status.toLowerCase():void 0;i&&Xi.has(i)?a.push({edgeId:"",sourceId:r.sourcePlaceName,targetId:r.targetPlaceName}):o.push(r)}),e.edgesToUpdate=o.length>0?o:void 0,e.edgesToRemove=a.length>0?a:void 0}function ec(e){const t=(o,a,r)=>{const i=o.toLowerCase(),s=a.toLowerCase(),c=typeof r=="string"?r.toLowerCase():"any";return i<s?`${i}|${s}|${c}`:`${s}|${i}|${c}`},n=(o,a)=>{if(!o)return o;const r=new Set,i=[];for(const s of o){const c=t(s.sourcePlaceName,s.targetPlaceName,a(s));r.has(c)||(r.add(c),i.push(s))}return i};if(e.edgesToAdd=n(e.edgesToAdd??void 0,o=>typeof o.type=="string"?o.type:void 0),e.edgesToUpdate=n(e.edgesToUpdate??void 0,o=>typeof o.type=="string"?o.type:void 0),e.edgesToRemove){const o=new Set,a=[];for(const r of e.edgesToRemove){const i=r.edgeId.toLowerCase();o.has(i)||(o.add(i),a.push(r))}e.edgesToRemove=a}}function Mo(e){const t=[];return(e.nodesToAdd??[]).forEach((n,o)=>{Xo(n,t,`nodesToAdd[${String(o)}]`)}),(e.nodesToUpdate??[]).forEach((n,o)=>{Xo(n,t,`nodesToUpdate[${String(o)}]`)}),(e.edgesToAdd??[]).forEach((n,o)=>{Zo(n,t,`edgesToAdd[${String(o)}]`)}),(e.edgesToUpdate??[]).forEach((n,o)=>{Zo(n,t,`edgesToUpdate[${String(o)}]`)}),t}function tc(e){const t=[],n=[];for(const o of e.nodesToRemove??[])/^edge_/i.test(o.nodeId)?n.push({edgeId:o.nodeId}):t.push(o);for(const o of e.edgesToRemove??[])/^node-/i.test(o.edgeId)?t.push({nodeId:o.edgeId,nodeName:o.edgeId}):n.push(o);e.nodesToRemove=t.length>0?t:void 0,e.edgesToRemove=n.length>0?n:void 0}const ea=async(e,t,n)=>{if(!ee())return console.error("fetchCorrectedMapUpdatePayload: API Key not configured."),null;const o=`You are an AI assistant fixing a malformed map update payload for a text adventure game.

Malformed JSON:
\`\`\`json
${e}
\`\`\`
Validation Error: "${t??"Unknown"}"
Respond ONLY with the corrected JSON object.`,a=`Correct the map update payload so it adheres to the expected structure. Valid node types: ${gn}. Valid node statuses: ${fn}. Valid edge types: ${hn}. Valid edge statuses: ${yn}. ${ut} ${Ht} ${Ve} Theme Guidance: ${n.storyGuidance}`;let r=o,i=t??null;return ie(async s=>{try{ae(ne.corrections.icon),s>0&&i?r=`${o}

[Parser Feedback]
${i}`:r=o;const{response:c}=await oe({modelNames:[z,Q],prompt:r,systemInstruction:a,responseMimeType:"application/json",temperature:Me,label:"Corrections"}),l=he(c.text??"");if(l&&(Mo(l),dr(l)))return i=null,{result:l};console.warn(`fetchCorrectedMapUpdatePayload (Attempt ${String(s+1)}/${String(B+1)}): corrected payload invalid.`,l),i="Corrected map update payload must include valid nodes/edges arrays that follow the documented schema and reference existing locations."}catch(c){throw console.error(`fetchCorrectedMapUpdatePayload error (Attempt ${String(s+1)}/${String(B+1)}):`,c),c}return{result:null}})},nc=async(e,t,n)=>{if(!ee())return console.error("assignSpecificNamesToDuplicateNodes: API Key not configured."),[];const o=new Map;e.forEach(r=>{const i=r.placeName.toLowerCase(),s=o.get(i)??[];s.push(r),o.set(i,s)});const a=[];for(const r of Array.from(o.values()))if(!(r.length<=1))for(let i=1;i<r.length;i+=1){const s=r[i],c=`You are an AI assistant disambiguating map location names in a text adventure game.
Theme: "${t.name}"
Another map node shares the name "${r[0].placeName}". Provide a short, unique new name for the following node.
Node Type: ${s.type}
Aliases: ${(s.aliases??[]).join(", ")||"None"}
Description: ${s.description}`,l="Respond ONLY with a short Title Case name that distinguishes this location.",d=await ie(async u=>{var m;try{ae(ne.corrections.icon);const{response:p}=await oe({modelNames:[be,z,Q],prompt:c,systemInstruction:l,temperature:Me,label:"Corrections",debugLog:n}),g=(m=p.text)==null?void 0:m.trim();if(g){const f=g.replace(/^['"]+|['"]+$/g,"").trim();if(f)return{result:f}}}catch(p){throw console.error(`assignSpecificNamesToDuplicateNodes error (Attempt ${String(u+1)}/${String(B+1)}):`,p),p}return{result:null}});d&&a.push({nodeId:s.id,newName:d})}return a},Ln=async(e,t,n,o,a,r)=>{if(!ee())return console.error(`fetchCorrectedName: API Key not configured. Cannot correct ${e} name.`),null;if(a.length===0)return console.warn(`fetchCorrectedName: No valid names provided for ${e} to match against. Returning original: "${t}".`),t;const i=`The corrected ${e} name MUST be one of these exact, case-sensitive full names: [${a.map(u=>`"${u}"`).join(", ")}].`,s=`
You are an AI assistant specialized in matching a potentially incorrect or partial entity name against a predefined list of valid names, using narrative context.
Entity Type: ${e}
Malformed/Partial Name Provided by another AI: "${t}"

Narrative Context (use this to understand which entity was likely intended):
- Log Message: "${n??"Not specified, infer from scene."}"
- Scene Description: "${o??"Not specified, infer from log."}"

List of Valid Names:
${i}

Task: Based on the context and the list of valid names, determine the correct full string name.
Respond ONLY with the single, corrected ${e} name as a string.
If no suitable match can be confidently made, respond with an empty string.`,c=`Your task is to match a malformed ${e} name against a provided list of valid names, using narrative context. Respond ONLY with the best-matched string from the valid list, or an empty string if no confident match is found. Adhere to the theme context: ${r.storyGuidance}`;let l=s,d=null;return ie(async u=>{var m;try{ae(ne.corrections.icon),u>0&&d?l=`${s}

[Parser Feedback]
${d}`:l=s;const{response:p}=await oe({modelNames:[be,z,Q],prompt:l,systemInstruction:c,temperature:Me,label:"Corrections"}),g=((m=p.text)==null?void 0:m.trim())??null;if(g!==null){let f=g.trim();if(f=f.replace(/^['"]+|['"]+$/g,"").trim(),f==="")return console.warn(`fetchCorrectedName (Attempt ${String(u+1)}/${String(B+1)}): AI indicated no match for ${e} "${t}" from the valid list.`),{result:null,retry:!1};if(a.includes(f))return console.warn("fetchCorrectedName: Returned corrected Name ",f,"."),d=null,{result:f};console.warn(`fetchCorrectedName (Attempt ${String(u+1)}/${String(B+1)}): AI returned name "${f}" for ${e} which is NOT in the validNamesList. Discarding result.`),d=`Return exactly one of the provided valid ${e} names: [${a.join(", ")}].`}else console.warn(`fetchCorrectedName (Attempt ${String(u+1)}/${String(B+1)}): AI call failed for ${e}. Received: null`),d="No name was returned. Respond with a single name from the provided valid list, or an empty string if unsure."}catch(p){throw console.error(`fetchCorrectedName error (Attempt ${String(u+1)}/${String(B+1)}):`,p),p}return{result:null}})},gt=`<ID: {id}> - "{name}" (Type: "{type}"{tags}, Description: "{currentdescription}"{activehint}){availableactions}{unavailableactions};
`,oc={foreign:{notRecovered:"The text appears to be in an unfamiliar language and might be translated",recovered:"The foreign text has been translated"},runic:{notRecovered:"The text is written in strange runes and might be translated",recovered:"The runic text has been translated"},glitching:{notRecovered:"The text is glitching or corrupted and might be restored",recovered:"The previously corrupted text has been restored"},encrypted:{notRecovered:"The text is encoded and might be decoded",recovered:"The text has been decoded"}},ac=/\{([a-zA-Z0-9_]+)\}/g,rc=e=>e==null?"":Array.isArray(e)?e.map(t=>typeof t=="string"?t:typeof t=="number"||typeof t=="boolean"||typeof t=="bigint"?String(t):typeof t=="symbol"?t.description??t.toString():typeof t=="function"?"[function]":JSON.stringify(t)).join(", "):typeof e=="string"?e:typeof e=="number"||typeof e=="boolean"||typeof e=="bigint"?String(e):typeof e=="symbol"?e.description??e.toString():typeof e=="function"?"[function]":typeof e=="object"?JSON.stringify(e):"",sc=(e,t)=>{const n=[];for(const o of e){const a=oc[o];a&&n.push(t?a.recovered:a.notRecovered)}return n.join(" ")},ic=e=>{const t=Array.isArray(e.tags)?e.tags:[];return t.length===0?"":`, Tags: ${t.join(", ")}`},cc=e=>{const t=Array.isArray(e.tags)?e.tags:[];if(t.length===0)return"";const n=t.includes("recovered"),o=sc(t,n);return o?`, ${o}`:""},lc=(e,t)=>{const{appliesWhenActive:n,appliesWhenInactive:o}=e;return n!==void 0&&o!==void 0?n&&t||o&&!t:n!==void 0?n===t:o!==void 0?o===!t:!0},dc=e=>{const t=Array.isArray(e.knownUses)?e.knownUses:[],n={available:[],unavailable:[]};if(t.length===0)return n;const o=!!e.isActive;for(const a of t)lc(a,o)?n.available.push(a):n.unavailable.push(a);return n},ur=e=>e.map(t=>`"${t.actionName}"`).join(", "),uc=e=>e.available.length===0?"":`, Available Actions: ${ur(e.available)}`,pc=e=>e.unavailable.length===0?"":`, Unavailable Actions: ${ur(e.unavailable)}`,mc=e=>e.isActive&&e.activeDescription?e.activeDescription:e.description,gc=e=>e.isActive?", It is active":"",fc=(e,t,n,o)=>{const a=dc(e),r=t.replace(ac,(i,s)=>{switch(s){case"tags":return ic(e);case"tagswithdescription":return cc(e);case"availableactions":return uc(a);case"unavailableactions":return pc(a);case"currentdescription":return mc(e);case"activehint":return gc(e);default:{if(!Object.prototype.hasOwnProperty.call(e,s))return"";const l=e[s];return rc(l)}}});return n===o?r.replace(/\s+$/u,"").replace(/[;,]$/u,""):r},Ue=(e,t,n="",o="")=>{const a=Array.isArray(e)?e:[e];if(a.length===0)return"";const r=a.length-1,i=a.map((l,d)=>fc(l,t,d,r)).filter(l=>l.trim().length>0);if(i.length===0)return"";const s=i.join(""),c=[];return n&&c.push(n),c.push(s),o&&c.push(o),c.join("").trimEnd()},Ke=e=>{if(!e||!Array.isArray(e.acts)||e.acts.length===0)return!1;const t=e.currentAct-1;if(t<0||t>=e.acts.length)return!1;const n=e.acts.at(t);return!(!n||!Array.isArray(n.sideObjectives))},hc=()=>{const e=[],t=(a,r)=>{const i=e[a];e[a]=e[r],e[r]=i},n=a=>{for(;a>0;){const r=Math.floor((a-1)/2);if(e[r].priority<=e[a].priority)break;t(r,a),a=r}},o=a=>{const r=e.length-1;for(;;){const i=a*2+1,s=a*2+2;let c=a;if(i<=r&&e[i].priority<e[c].priority&&(c=i),s<=r&&e[s].priority<e[c].priority&&(c=s),c===a)break;t(a,c),a=c}};return{push(a,r){e.push({value:a,priority:r}),n(e.length-1)},pop(){if(e.length===0)return;const a=e[0].value,r=e.pop();return r!==void 0&&e.length>0&&(e[0]=r,o(0)),a},size(){return e.length}}},yc={open:1,accessible:1,active:1,one_way:1,rumored:5,closed:1/0,locked:1/0,blocked:1/0,hidden:1/0,collapsed:1/0,removed:1/0,inactive:1/0},rn=20,Dn=e=>{const t=new Map,n=new Map(e.nodes.map(s=>[s.id,s])),o=s=>{const c=s?n.get(s):void 0;return!!c&&c.status!=="blocked"},a=new Map;for(const s of e.nodes){const c=s.parentNodeId;if(!c)continue;a.has(c)||a.set(c,[]);const l=a.get(c);l&&l.push(s.id)}const r=(s,c,l,d)=>{t.has(s)||t.set(s,[]);const u=t.get(s);u&&u.push({edgeId:l,to:c,cost:d})};for(const s of e.edges){if(!o(s.sourceNodeId)||!o(s.targetNodeId))continue;const c=s.status,l=yc[c];l!==1/0&&(r(s.sourceNodeId,s.targetNodeId,s.id,l),c!=="one_way"&&r(s.targetNodeId,s.sourceNodeId,s.id,l))}for(const s of e.nodes){const c=s.parentNodeId;if(!c||c===K||!o(s.id)||!o(c)||!(a.get(c)??[]).some(p=>p!==s.id&&o(p)))continue;const u=`hierarchy:${s.id}->${c}`,m=`hierarchy:${c}->${s.id}`;r(s.id,c,u,rn),r(c,s.id,m,rn)}const i=new Map;for(const s of e.nodes){const c=s.parentNodeId;if(!c)continue;i.has(c)||i.set(c,[]);const l=i.get(c);l&&l.push(s)}for(const s of i.values()){const c=u=>u.type==="feature"||u.isFeature===!0,l=s.filter(c),d=s.filter(u=>!c(u));for(const u of l)for(const m of d){if(!o(u.id)||!o(m.id))continue;const p=`hierarchy:${u.id}->${m.id}`,g=`hierarchy:${m.id}->${u.id}`;r(u.id,m.id,p,rn),r(m.id,u.id,g,rn)}}return{adjacency:t,nodeMap:n,childrenByParent:a}},pr=(e,t,n,o)=>{const{adjacency:a,nodeMap:r,childrenByParent:i}=o??Dn(e),s=g=>{const f=g?r.get(g):void 0;return!!f&&f.status!=="blocked"},c=(g,f)=>{const v=i.get(g);if(v!=null&&v.includes(f))return v.some(w=>w!==f&&w!==t&&s(w));const y=i.get(f);return y!=null&&y.includes(g)?y.some(w=>w!==g&&w!==t&&s(w)):!0},l=new Map,d=new Map,u=hc();for(u.push({nodeId:t,cost:0},0),l.set(t,0);u.size()>0;){const g=u.pop();if(!g)break;if(g.cost!==(l.get(g.nodeId)??1/0))continue;if(g.nodeId===n)break;const f=a.get(g.nodeId)??[];for(const v of f){if(v.edgeId.startsWith("hierarchy:")&&!c(g.nodeId,v.to))continue;const y=g.cost+v.cost;y<(l.get(v.to)??1/0)&&(l.set(v.to,y),d.set(v.to,{from:g.nodeId,edgeId:v.edgeId}),u.push({nodeId:v.to,cost:y},y))}}if(!l.has(n))return null;const m=[];let p=n;for(m.unshift({step:"node",id:p});p!==t;){const g=d.get(p);if(!g)break;m.unshift({step:"edge",id:g.edgeId}),p=g.from,m.unshift({step:"node",id:p})}return m},wc=/\{([a-zA-Z0-9_]+)\}/g,vc=(e,t)=>{const n=e[t];return t==="knowsPlayerAs"&&Array.isArray(n)&&n.length===0?"ATTENTION! NPC does not know the player's name.":Array.isArray(n)?n.length===0?"None":n.map(o=>typeof o=="string"?o:JSON.stringify(o)).join(", "):n==null?t==="aliases"||t==="dialogueSummaries"?"None":"Unknown":typeof n=="object"?JSON.stringify(n):typeof n=="string"?n:String(n)},Ze=(e,t,n="",o="")=>{const a=Array.isArray(e)?e:[e];if(a.length===0)return"";const r=c=>t.replace(wc,(d,u)=>Object.prototype.hasOwnProperty.call(c,u)?vc(c,u):""),i=a.map(r).filter(c=>c.trim().length>0);if(i.length===0)return"";const s=[];return n&&s.push(n),s.push(i.join("")),o&&s.push(o),s.join("").trimEnd()},mr=e=>e.length===0?"":" - "+e.join(`
 - `),$o=(e,t,n,o,a)=>{const r=[];e.forEach(d=>{const u=[d.placeName,...d.aliases??[]];new RegExp(u.map(p=>`\\b${p.replace(/[.*+?^${}()|[\\]\\]/g,"\\$&")}\\b`).join("|"),"i").test(n)&&r.push(d)});const i=[];t.forEach(d=>{const u=[d.name,...d.aliases??[]];new RegExp(u.map(p=>`\\b${p.replace(/[.*+?^${}()|[\\]\\]/g,"\\$&")}\\b`).join("|"),"i").test(n)&&i.push(d)});let s="";const c=It(r,!0);c&&c!=="None specifically known yet."&&(s+=`${o}
${c}
`);const l=Ze(i,`<ID: {id}> - {name} — {description} (status: {presenceStatus}, lastKnownLocation: {lastKnownLocation}, preciseLocation: {preciseLocation})
`,`${a}
`);return l&&(s+=l),s.trimStart()},Ic=(e,t,n)=>{var I,S,M;if(!t||!n||t===n)return null;const o=Dn(e),a=pr(e,t,n,o);if(!a||a.length<3)return null;const r=e.nodes.find(k=>k.id===n),i=(r==null?void 0:r.placeName)??n,s=r==null?void 0:r.parentNodeId,c=s&&s!==K?((I=e.nodes.find(k=>k.id===s))==null?void 0:I.placeName)??s:null,l=c?`${i} in ${c}`:i,d=(r==null?void 0:r.status)==="rumored",u=a[1],m=a[2],p=a.length>4?a[4]:void 0;if(u.step!=="edge"||m.step!=="node")return null;const g=e.nodes.find(k=>k.id===m.id),f=(g==null?void 0:g.placeName)??m.id,v=p&&p.step==="node"?e.nodes.find(k=>k.id===p.id):null,y=p?(v==null?void 0:v.placeName)??p.id:"",w=(g==null?void 0:g.status)==="rumored",h=(v==null?void 0:v.status)==="rumored";let T=d?`Player wants to reach a rumored place - ${l}.`:`Player wants to travel to ${l}.`;if(u.id.startsWith("hierarchy:")){const[k,$]=u.id.split(":")[1].split("->"),L=((S=e.nodes.find(N=>N.id===k))==null?void 0:S.placeName)??k,E=((M=e.nodes.find(N=>N.id===$))==null?void 0:M.placeName)??$;T+=` The journey leads towards ${E} in the general area of ${L}, and then towards ${h?"a rumored place - "+y:y}.`}else{const k=e.edges.find(E=>E.id===u.id),$=k?k.status:"open",L=k?k.description??k.type:"path";$==="rumored"?T+=` There is a rumor a path exists from here to ${w?"a rumored place - "+f:f}.`:T+=` The path leads through ${L} towards ${w?"a rumored place - "+f:f}.`}return T},Lo=e=>[`Geography: ${e.geography}`,`Climate: ${e.climate}`,`Technology Level: ${e.technologyLevel}`,`Supernatural Elements: ${e.supernaturalElements}`,`Major Factions: ${e.majorFactions.join(", ")}`,`Key Resources: ${e.keyResources.join(", ")}`,`Cultural Notes: ${e.culturalNotes.join(", ")}`,`Notable Locations: ${e.notableLocations.join(", ")}`].join(`
`),Rn=(e,t=!1)=>{const n=[`Player Character Name: ${e.name} (short: ${e.heroShortName})`,`Gender: ${e.gender}.`,`Occupation: ${e.occupation}.`,`Traits: ${e.traits.join(", ")}.`];return t&&e.startingItems.length>0&&n.push(`Starting items: ${e.startingItems.join(", ")}.`),n.join(`
`)},gr=e=>[`5 years ago: ${e.fiveYearsAgo}`,`1 year ago: ${e.oneYearAgo}`,`6 months ago: ${e.sixMonthsAgo}`,`1 month ago: ${e.oneMonthAgo}`,`1 week ago: ${e.oneWeekAgo}`,`Yesterday: ${e.yesterday}`,`Now: ${e.now}`].join(`
`),Do=e=>{if(!Ke(e))return"";const t=e.acts[e.currentAct-1],n=t.sideObjectives.join(", ");return[`Arc Title: ${e.title}`,`Overview: ${e.overview}`,`Current Act ${String(t.actNumber)}: ${t.title}`,`Act Description: ${t.description}`,`Main Objective: ${t.mainObjective}`,`Side Objectives: ${n}`,`Success Condition: ${t.successCondition}`].join(`
`)},Nc=e=>(e.mapHint!==void 0&&(e.mapHint=e.mapHint.trim()),e.playerItemsHint!==void 0&&(e.playerItemsHint=e.playerItemsHint.trim()),e.worldItemsHint!==void 0&&(e.worldItemsHint=e.worldItemsHint.trim()),e.npcItemsHint!==void 0&&(e.npcItemsHint=e.npcItemsHint.trim()),Array.isArray(e.newItems)&&(e.newItems=e.newItems.filter(Ri)),e),bc=(e,t,n)=>{const o=he(e);try{if(!o)throw new Error("JSON parse failed");if(!Array.isArray(o.npcResponses)||!o.npcResponses.every(s=>typeof s.speaker=="string"&&typeof s.line=="string")||!Array.isArray(o.playerOptions)||!o.playerOptions.every(s=>typeof s=="string")||o.dialogueEnds!==void 0&&typeof o.dialogueEnds!="boolean"||o.updatedParticipants!==void 0&&(!Array.isArray(o.updatedParticipants)||!o.updatedParticipants.every(s=>typeof s=="string"))){const s="Dialogue response must include npcResponses and playerOptions with valid speaker/line strings.";return console.warn("Parsed dialogue JSON does not match DialogueAIResponse structure:",o),n==null||n(s),null}let a,r;if(o.npcAttitudeUpdates!==void 0){if(!Array.isArray(o.npcAttitudeUpdates)){const s="npcAttitudeUpdates must be an array of objects containing name and newAttitudeTowardPlayer strings.";return console.warn("Parsed dialogue JSON has invalid npcAttitudeUpdates:",o.npcAttitudeUpdates),n==null||n(s),null}a=[];for(const s of o.npcAttitudeUpdates){if(s===null||typeof s!="object"){const m="Each npcAttitudeUpdates entry must be an object with name and newAttitudeTowardPlayer fields.";return console.warn("npcAttitudeUpdates entry is not an object:",s),n==null||n(m),null}const c=s.name,l=s.newAttitudeTowardPlayer;if(typeof c!="string"||typeof l!="string"){const m="npcAttitudeUpdates entries must provide string values for name and newAttitudeTowardPlayer.";return console.warn("npcAttitudeUpdates entry has invalid fields:",s),n==null||n(m),null}const d=c.trim();if(d.length===0){const m="npcAttitudeUpdates entries cannot use empty strings for name.";return console.warn("npcAttitudeUpdates entry has empty name:",s),n==null||n(m),null}const u=l.trim();if(u.length===0){const m="npcAttitudeUpdates entries cannot use empty strings for newAttitudeTowardPlayer.";return console.warn("npcAttitudeUpdates entry has empty attitude:",s),n==null||n(m),null}a.push({name:d,newAttitudeTowardPlayer:u})}}if(o.npcKnownNameUpdates!==void 0){if(!Array.isArray(o.npcKnownNameUpdates)){const s="npcKnownNameUpdates must be an array when provided.";return console.warn("Parsed dialogue JSON has invalid npcKnownNameUpdates:",o.npcKnownNameUpdates),n==null||n(s),null}r=[];for(const s of o.npcKnownNameUpdates){if(s===null||typeof s!="object"){const g="Each npcKnownNameUpdates entry must be an object containing name and known player name updates.";return console.warn("npcKnownNameUpdates entry is not an object:",s),n==null||n(g),null}const c=s.name,l=s.newKnownPlayerNames,d=s.addKnownPlayerName;if(typeof c!="string"){const g='npcKnownNameUpdates entries require a string "name" field.';return console.warn("npcKnownNameUpdates entry has invalid name:",s),n==null||n(g),null}const u=c.trim();if(u.length===0){const g="npcKnownNameUpdates entries cannot use empty strings for name.";return console.warn("npcKnownNameUpdates entry has empty name:",s),n==null||n(g),null}let m,p;if(l!==void 0){if(!Array.isArray(l)){const f="npcKnownNameUpdates.newKnownPlayerNames must be an array of strings when provided.";return console.warn("npcKnownNameUpdates entry has invalid newKnownPlayerNames:",s),n==null||n(f),null}const g=[];for(const f of l){if(typeof f!="string"){const y="npcKnownNameUpdates.newKnownPlayerNames must contain only strings.";return console.warn("npcKnownNameUpdates entry has non-string newKnownPlayerNames value:",s),n==null||n(y),null}const v=f.trim();if(v.length===0){const y="npcKnownNameUpdates.newKnownPlayerNames cannot include empty strings.";return console.warn("npcKnownNameUpdates entry has empty string in newKnownPlayerNames:",s),n==null||n(y),null}g.push(v)}m=g}if(d!==void 0){if(typeof d!="string"){const f="npcKnownNameUpdates.addKnownPlayerName must be a string when provided.";return console.warn("npcKnownNameUpdates entry has invalid addKnownPlayerName:",s),n==null||n(f),null}const g=d.trim();if(g.length===0){const f="npcKnownNameUpdates.addKnownPlayerName cannot be an empty string.";return console.warn("npcKnownNameUpdates entry has empty addKnownPlayerName:",s),n==null||n(f),null}p=g}if(m===void 0&&p===void 0){const g="npcKnownNameUpdates entries must provide either newKnownPlayerNames or addKnownPlayerName.";return console.warn("npcKnownNameUpdates entry missing updates:",s),n==null||n(g),null}r.push({name:u,...m!==void 0?{newKnownPlayerNames:m}:{},...p!==void 0?{addKnownPlayerName:p}:{}})}}o.playerOptions.length===0&&(o.playerOptions=["End Conversation."]);const i=o;return a!==void 0&&(i.npcAttitudeUpdates=a),r!==void 0&&(i.npcKnownNameUpdates=r),t&&t.length>0&&i.npcResponses.forEach((s,c)=>{t[c]&&(s.thought=t[c])}),i}catch(a){return console.warn("Failed to parse dialogue JSON response from AI:",a),console.debug("Original dialogue response text:",e),n==null||n(a instanceof Error?a.message:"Dialogue response failed to parse as valid JSON."),null}},fr=(e,t,n)=>bc(e,t,n),Ac=async(e,t,n,o,a,r,i,s)=>{if(!ee())return console.error("fetchCorrectedDialogueSetup: API Key not configured."),null;const c=Ze(o,"<ID: {id}> - {name}; ","- Known/Available NPCs for Dialogue: ",`
`),l=It(a,!0),d=Ue(r,"{name}, ","- Player Inventory: ",`
`),m=`
Role: You are an AI assistant correcting a malformed 'dialogueSetup' JSON payload for a text adventure game.
Task: Reconstruct the 'dialogueSetup' object based on narrative context and the malformed data.

Malformed 'dialogueSetup' Payload:
\`\`\`json
${JSON.stringify(s)}
\`\`\`

Narrative Context:
- Log Message: "${e??"Not specified"}"
- Scene Description: "${t??"Not specified"}"
- Theme Guidance: "${n.storyGuidance}"
${c}
- Known Map Locations: ${l}
${d}
- Player Gender: "${i}"

Required JSON Structure for corrected 'dialogueSetup':
{
  "initialNpcResponses": [{ "speaker": "NPC Name 1", "line": "Their first line." }],
  "initialPlayerOptions": [],
  "participants": ["NPC Name 1", "NPC Name 2"?]
}

Respond ONLY with the single, complete, corrected JSON object for 'dialogueSetup'.`,p="Correct a malformed 'dialogueSetup' JSON payload. Ensure 'participants' are valid NPCs, 'initialNpcResponses' are logical, and 'initialPlayerOptions' are varied with an exit option. Adhere strictly to the JSON format.";let g=m,f=null;return ie(async v=>{try{ae(ne.corrections.icon),v>0&&f?g=`${m}

[Parser Feedback]
${f}`:g=m;const{response:y}=await oe({modelNames:[z,Q],prompt:g,systemInstruction:p,responseMimeType:"application/json",temperature:Me,label:"Corrections"}),w=he(y.text??"");if(w&&so(w))return f=null,{result:w};console.warn(`fetchCorrectedDialogueSetup (Attempt ${String(v+1)}/${String(B+1)}): Corrected dialogueSetup payload invalid. Response:`,w),f="Corrected dialogueSetup payload must include non-empty initialNpcResponses, initialPlayerOptions, and participants drawn from known NPCs."}catch(y){throw console.error(`fetchCorrectedDialogueSetup error (Attempt ${String(v+1)}/${String(B+1)}):`,y),y}return{result:null}})},Sc=async(e,t,n,o)=>{if(!ee())return console.error("fetchCorrectedDialogueTurn: API Key not configured."),null;const a=t.map(l=>`"${l}"`).join(", ")||"None",r=`Role: You fix malformed JSON for a dialogue turn in a text adventure game.

Theme Guidance: "${n.storyGuidance}"

Malformed Dialogue Response:
\`\`\`
${e}
\`\`\`

Valid Participant Names: [${a}]

Required JSON Structure:
{
  "dialogueEnds": boolean?,
  "npcResponses": [{ "speaker": "Name", "line": "text" }],
  "playerOptions": ["text"],
  "updatedParticipants": ["Name"]?,
  "npcAttitudeUpdates": [{ "name": "Name", "newAttitudeTowardPlayer": "text" }]?
}

Do NOT change the text of any npcResponses.line or playerOptions.
Ensure each "speaker" value is one of the valid participant names.
Respond ONLY with the corrected JSON object.`,i=`Correct a malformed dialogue turn JSON object without altering the dialogue text. Speaker names must be among: ${a}. Preserve any npcAttitudeUpdates entries if present. Adhere strictly to JSON format.`;let s=r,c=null;return ie(async l=>{var d;try{ae(ne.corrections.icon),l>0&&c?s=`${r}

[Parser Feedback]
${c}`:s=r;const{response:u}=await oe({modelNames:[be,z,Q],prompt:s,systemInstruction:i,temperature:Me,label:"Corrections"}),m=((d=u.text)==null?void 0:d.trim())??null;if(m){let p=null;const g=fr(m,o,f=>{p=f});if(g!=null&&g.npcResponses.every(f=>t.includes(f.speaker)))return c=null,{result:g};console.warn(`fetchCorrectedDialogueTurn (Attempt ${String(l+1)}/${String(B+1)}): corrected response invalid or speakers not in list.`,m),typeof p=="string"?c=p:c="Dialogue response must list npcResponses with valid speakers and provide playerOptions that match schema."}else console.warn(`fetchCorrectedDialogueTurn (Attempt ${String(l+1)}/${String(B+1)}): AI returned empty response.`),c="Dialogue response was empty. Return a complete JSON object matching the required structure."}catch(u){throw console.error(`fetchCorrectedDialogueTurn error (Attempt ${String(l+1)}/${String(B+1)}):`,u),u}return{result:null}})},Tc=Fs,hr=Tc.block,Pc=Array.from(new Set(Object.values(hr)));let sn=null;function Cc(){return sn||(sn=Ci(hr,Pc),sn)}function Ec(e){return Cc().some(([n])=>n.test(e))}function kc(e){return Ec(e.actionName)}function ta(e){return e&&e.filter(t=>!kc(t))}const na=(e,t,n)=>{switch(t){case"create":{const o=e;if((typeof o.holderId!="string"||o.holderId.trim()==="")&&(o.holderId=se),zo(o,"create")){const a=o;return a.knownUses=ta(a.knownUses),{action:t,item:o}}return n==null||n("Inventory create action was missing required item fields."),null}case"change":{const o=e,a=typeof o.type=="string"?o.type:void 0,r=typeof o.status=="string"?o.status:void 0,i=a?vn(a):null,s=r?r.toLowerCase():null,c=a?a.toLowerCase():null;if(i&&qn.has(i)||c&&qn.has(c)||s&&qn.has(s)){const l={id:typeof o.id=="string"?o.id:void 0,name:typeof o.name=="string"?o.name:void 0};return Qo(l)?{action:"destroy",item:l}:(n==null||n("Inventory change action attempted to destroy an item without a valid id or name."),null)}if(zo(e,"change")){const l=e;return l.knownUses=ta(l.knownUses),{action:"change",item:e}}return n==null||n("Inventory change action had invalid item payload."),null}case"addDetails":return lr(e)?{action:"addDetails",item:e}:(n==null||n("Inventory addDetails action payload was invalid."),{action:"addDetails",item:e,invalidPayload:e});case"destroy":return Qo(e)?{action:"destroy",item:e}:(n==null||n("Inventory destroy action requires an item reference with id or name."),null);case"move":{const o=e;if(typeof o.id=="string"&&typeof o.newHolderId=="string"){const a={id:o.id,name:o.name,newHolderId:o.newHolderId};return{action:t,item:a}}return n==null||n("Inventory move action must include id and newHolderId strings."),null}default:return n==null||n(`Inventory action "${String(t)}" is not supported.`),null}},Ro=(e,t)=>{let n=null;const o=c=>{n??(n=c)},a=he(e);if(!a)return t==null||t("Inventory response was not valid JSON."),null;let r=null;const i=(c,l)=>{const d=[];for(const u of c){if(!u||typeof u!="object")continue;const m=na(u,l,o);m&&d.push(m)}return d},s=c=>{const l=[];for(const d of c){if(!d||typeof d!="object")continue;const u=d,m=typeof u.action=="string"?u.action:void 0,p=u.item&&typeof u.item=="object"?u.item:void 0;if(m&&p){const g=na(p,m,o);g&&l.push(g)}}return l};if(Array.isArray(a))r={itemChanges:i(a,"create")};else if(typeof a=="object"){const c=a,l=[];Array.isArray(c.create)&&l.push(...i(c.create,"create")),Array.isArray(c.change)&&l.push(...i(c.change,"change")),Array.isArray(c.move)&&l.push(...i(c.move,"move")),Array.isArray(c.destroy)&&l.push(...i(c.destroy,"destroy")),Array.isArray(c.addDetails)&&l.push(...i(c.addDetails,"addDetails")),Array.isArray(c.itemChanges)&&l.push(...s(c.itemChanges)),r={itemChanges:l,observations:typeof c.observations=="string"?c.observations:void 0,rationale:typeof c.rationale=="string"?c.rationale:void 0}}return r||(typeof n=="string"?t==null||t(n):t==null||t("Inventory response must be a JSON object or array describing item changes.")),r},Mc={type:"array",items:{type:"object",properties:{action:{enum:As},item:{type:"object",properties:{id:{type:"string"},name:{type:"string"},type:{enum:vt},description:{type:"string"},activeDescription:{type:["string","null"]},isActive:{type:"boolean"},holderId:{type:"string",description:"ID of current holder such as player, node-* or npc-*"},newHolderId:{type:"string",description:"Used with move action to specify new holder"},newName:{type:"string",description:"Used with change action for transformations"},tags:{type:"array",items:{type:"string"}},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string"},promptEffect:{type:"string"},description:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"}},required:["actionName","promptEffect","description"]}},chapters:{type:"array",items:{type:"object",properties:{heading:{type:"string"},description:{type:"string"},contentLength:{type:"number"}},required:["heading","description","contentLength"]}}},required:["name"]}},required:["action","item"]}},$c=async(e,t,n,o,a,r,i,s,c,l)=>{if(!ee())return console.error("fetchCorrectedItemChangeArray: API Key not configured."),null;const d=`You are an AI assistant fixing a malformed inventory update JSON payload for a text adventure game.

## Malformed Payload:
\`\`\`json
${e}
\`\`\`

## Narrative Context:
- Log Message: "${t??"Not specified"}"
- Scene Description: "${n??"Not specified"}"
- Player Items Hint: "${o}"
- World Items Hint: "${a}"
- NPC Items Hint: "${r}"
- Current Place ID: "${i??"unknown"}"
- Companions: ${s}
- Nearby NPCs: ${c}
- Theme Guidance: "${l.storyGuidance||"General adventure theme."}"

Task: Provide ONLY the corrected JSON array of ItemChange objects.`,u=`Correct a JSON array of ItemChange objects for the inventory system.
Each element must be { "action": (${vo}), "item": { ... } }.
Item properties must appear in this order: id, name, type, description, activeDescription, isActive, holderId, newHolderId, newName, tags, knownUses, chapters.
Valid item types: ${ho}.
Use "activeDescription": null in a "change" action to clear an existing active description, and set "isActive": false when you do so.

## Examples:
[
  { // Example for creating a new item from context
    "action": "create",
    "item": {
      "name": "Old Lantern",
      "type": "equipment",
      "description": "A dusty old lantern that still flickers faintly.",
      "activeDescription": "The lantern is lit and casts a warm glow.",
      "isActive": false,
      "holderId": "player",
      "tags": [],
      "knownUses": [
        {
          "actionName": "Light the Lantern",
          "promptEffect": "Light the lantern to illuminate the area.",
          "description": "Use this to light your way in dark places.",
          "appliesWhenActive": false,
          "appliesWhenInactive": true
        },
        {
          "actionName": "Extinguish the Lantern",
          "promptEffect": "Extinguish the lantern.",
          "description": "Extinguish and conserve the fuel",
          "appliesWhenActive": true,
          "appliesWhenInactive": false
        }
      ],
      "chapters": []
    }
  },
  { // Example for destroying an existing item
    "action": "destroy",
    "item": {
      "id": "item-old-lantern-7fr4",
      "name": "Old Lantern (flickering)"
    }
  },
  { // Example for moving an item to a new holder
    "action": "move",
    "item": {
      "id": "item-iron-sword-ab12",
      "name": "Iron Sword",
      "newHolderId": "npc-guard-4f3a"
    }
  },
  { // Example for toggling state on an existing item
    "action": "change",
    "item": {
      "id": "item-plasma-torch-7fr4",
      "name": "Plasma Torch",
      "isActive": true
    }
  },
  { // Example for clearing the special active description
    "action": "change",
    "item": {
      "id": "item-old-lantern-7fr4",
      "name": "Old Lantern",
      "activeDescription": null,
      "isActive": false
    }
  },
  { // Example for adding new details to an existing item
    "action": "addDetails",
    "item": {
      "id": "item-mystic-orb-7fr4",
      "name": "Mystic Orb",
      "type": "single-use",
      "knownUses": [
        {
          "actionName": "Peer into the Orb",
          "promptEffect": "Peer into the Mystic Orb, trying to glimpse the future.",
          "description": "Try to see the beyond",
          "appliesWhenActive": true
        }
      ]
    }
  },
  { // Example for creating a single-page written item
    "action": "create",
    "item": {
      "name": "Smudged Note",
      "type": "page",
      "description": "A hastily scribbled message with a big smudge over it.",
      "holderId": "player",
      "tags": ["typed", "smudged"],
      "chapters": [
        {
          "heading": "Warning",
          "description": "A hastily scribbled message about the dangers of the sunken tunnel.",
          "contentLength": 50
        }
      ]
    }
  },
  { // Example for creating a multi-chapter book
    "action": "create",
    "item": {
      "name": "Explorer's Adventures",
      "type": "book",
      "description": "Weathered log of travels.",
      "holderId": "player",
      "tags": ["handwritten", "faded"],
      "chapters": [
        {
          "heading": "Preface",
          "description": "Introduction. Written by the author, explaining his decisions to start his travels.",
          "contentLength": 53
        },
        {
          "heading": "Journey One",
          "description": "First trip. The author travelled to Vibrant Isles in the search of the Endless Waterfall",
          "contentLength": 246
        },
        {
          "heading": "Journey Two",
          "description": "Second Trip. The author's adventure in Desolate Steppes in the search of Magnificent Oasis",
          "contentLength": 312
        },
        {
          "heading": "Final Thoughts",
          "description": "The author's contemplation about whether the journeys were worth it",
          "contentLength": 98
        }
      ]
    }
  }
]

Respond ONLY with the corrected JSON array.`;let m=d,p=null;return ie(async g=>{try{ae(ne.corrections.icon),g>0&&p?m=`${d}

[Parser Feedback]
${p}`:m=d;const{response:f}=await oe({modelNames:[z,Q],prompt:m,systemInstruction:u,responseMimeType:"application/json",jsonSchema:Mc,temperature:Me,label:"Corrections"}),v=he(f.text??"");let y=null;const w=v?Ro(JSON.stringify(v),T=>{y=T}):null,h=w?w.itemChanges:null;if(h)return p=null,{result:h};console.warn(`fetchCorrectedItemChangeArray (Attempt ${String(g+1)}/${String(B+1)}): corrected payload invalid.`,v),typeof y=="string"?p=y:p="Corrected inventory payload must contain valid ItemChange entries following the documented schema."}catch(f){throw console.error(`fetchCorrectedItemChangeArray error (Attempt ${String(g+1)}/${String(B+1)}):`,f),f}return{result:null}})},Lc="{name} (Type: {type}, Active: {isActive}), ",Dc="{name} (Type: {type}), ",yr=`- "{name}" (Description: {description}; Presence: {presenceStatus}{dialoguePresenceSummary}; Attitude: {attitudeTowardPlayer}; Knows player as: {knownPlayerLabel})
`,wr=e=>e.map(t=>{const n=kn.includes(t.presenceStatus)?` at ${t.preciseLocation??"around"}`:`, last seen: ${t.lastKnownLocation??"Unknown"}`,o=t.knowsPlayerAs.length>0?t.knowsPlayerAs.join(", "):"ATTENTION! NPC does not know the player's name.";return{...t,dialoguePresenceSummary:n,knownPlayerLabel:o}}),Rc=e=>{const{theme:t,currentQuest:n,currentObjective:o,currentScene:a,localTime:r,localEnvironment:i,localPlace:s,knownMainMapNodes:c,knownNPCs:l,inventory:d,heroSheet:u,dialogueHistory:m,playerLastUtterance:p,dialogueParticipants:g,relevantFacts:f}=e,v=u!==null?Rn(u,!1):"The player character remains undescribed.",y=(u==null?void 0:u.gender)??"Male",w=e.storyArc?Do(e.storyArc):"";let h=[...m];h.length>0&&h[h.length-1].speaker.toLowerCase()==="player"&&h[h.length-1].line===p&&(h=h.slice(0,-1));const T=h.map(A=>({...A}));let I=!1;for(let A=T.length-1;A>=0;A--){const P=T[A];P.speaker.toLowerCase()==="player"?I=!0:I&&"thought"in P&&delete P.thought}const S=(u==null?void 0:u.heroShortName)??"Player",M=T.map(A=>`${A.speaker.toLowerCase()==="player"?S:A.speaker}: "${A.line}"`).join(`
`),k=Ue(d,Lc,`## Player's Inventory:
`,`
`),$=It(c,!0,!1),L=Ze(wr(l),yr,`
## Known NPCs:
`);let E="";g.forEach(A=>{const P=l.find(C=>C.name===A);P!=null&&P.dialogueSummaries&&P.dialogueSummaries.length>0&&(E+=`
Recent Past Conversations involving ${A}:
`,P.dialogueSummaries.slice(-3).forEach(R=>{E+=`- Summary: "${R.summaryText}" (Participants: ${R.participants.join(", ")}; Time: ${R.timestamp}; Location: ${R.location})
`}))});const N=f.length>0?f.map(A=>`- ${A}`).join(`
`):"None";return`**Context for Dialogue Turn**
${w?`Narrative Arc:
${w}
`:`Current Theme: "${t.name}";
Theme Guidance: "${t.storyGuidance}";`}
Current Main Quest: "${n??"Not set"}";
Current Objective: "${o??"Not set"}";
Scene Description (for environmental context): "${a}";
Local Time: "${r??"Unknown"}", Environment: "${i??"Undetermined"}", Place: "${s??"Undetermined"}";

## Player Character Description:
Gender: ${y}.
${v}
Character Traits should slightly influence dialogue choices.

## Relevant Facts about the world:
${N}

${k}## Known Locations:
${$}${L}

## Dialogue Context:
- Current Dialogue Participants: ${g.join(", ")};
${E.trim()?E:`
- No specific past dialogue summaries available for current participants.`}

- Dialogue History (most recent last):
${M}

- Player's Last Utterance/Choice: "${p}"

Based on this context, provide the next part of the dialogue according to the DIALOGUE_SYSTEM_INSTRUCTION.
The NPC(s) should respond to the player's last utterance, taking into account any relevant past conversation summaries.
Provide new dialogue options, ensuring the last one is a way to end the dialogue.
If an NPC's attitude toward the player changes during this exchange, include "npcAttitudeUpdates" with one entry per NPC describing their new attitude.
`},Oc=e=>{var s,c,l,d;const t=((s=e.heroSheet)==null?void 0:s.heroShortName)??"Player",n=e.dialogueLog.map(u=>`${u.speaker.toLowerCase()==="player"?t:u.speaker}: "${u.line}"`).join(`
`),o=Ue(e.inventory,Dc,`- Player's Inventory (before dialogue):
`,`
`),a=It(e.mapDataSnapshot.nodes.filter(u=>u.type!=="feature"),!0,!1),r=Ze(wr(e.knownNPCs),yr,`
- Known NPCs:
`,`
`),i=`- Known Locations (before dialogue):
${a}
`;return`
 Context for Dialogue Summary:
${e.storyArc?`Narrative Arc: ${e.storyArc.title} (Act ${String(e.storyArc.currentAct)}: ${e.storyArc.acts[e.storyArc.currentAct-1].title})`:`Current Theme: "${((c=e.theme)==null?void 0:c.name)??e.themeName}"
- Theme Guidance: "${((l=e.theme)==null?void 0:l.storyGuidance)??"None"}"`}
- Current Main Quest (before dialogue): "${e.mainQuest??"Not set"}"
- Current Objective (before dialogue): "${e.currentObjective??"Not set"}"
- Scene Description (when dialogue started): "${e.currentScene}"
- Local Time: "${e.localTime??"Unknown"}", Environment: "${e.localEnvironment??"Undetermined"}", Place: "${e.localPlace??"Undetermined"}"
  - Player's Character Gender: "${((d=e.heroSheet)==null?void 0:d.gender)??"Male"}"

${o}${i}
${r}- Dialogue Participants: ${e.dialogueParticipants.join(", ")}

## Full Dialogue Transcript:
${n}

Based *only* on the Dialogue Transcript and the provided context, determine what specific game state changes (items, NPCs, quest/objective updates, log message, map updates) resulted *directly* from this dialogue.
The "logMessage" field in your response should be a concise summary suitable for the main game log.
Provide the next scene description and ${String(ct)} action options for the player as you would for a normal game turn.
If the dialogue revealed a new alias for an existing NPC, use "npcsUpdated" with "addAlias".
If the dialogue changed some NPC's general whereabouts, use "newLastKnownLocation" in "npcsUpdated".
If the dialogue shifts an NPC's feelings toward the player, set "newAttitudeTowardPlayer".
If an NPC learns, confirms, or forgets the player's name, use "npcKnownNameUpdates" with either "newKnownPlayerNames" (replace list; empty array means they know none) or "addKnownPlayerName" to append a single new nickname.
If the dialogue revealed new map information (new locations, changed accessibility, etc.), or if Player's own location changed over the course of the dialogue, then set "mapUpdated": true.
`},xc=e=>{var r,i;const t=e.heroShortName??"Player",n=e.dialogueLog.map(s=>`  ${s.speaker.toLowerCase()==="player"?t:s.speaker}: ${s.line}`).join(`
`),o=`You are an AI assistant creating a detailed memory of a conversation. This memory will be remembered by the NPCs who participated.
Your task is to write a concise yet detailed summary of the conversation.
The summary should be between 500 and 1500 characters. It should be written from the point of view of the Conversation Participants other than the Player.
The summary should ALWAYS mention all names and the player (named "${t}") explicitly without pronouns.
It should capture:
- Key topics discussed.
- Important information revealed or exchanged by any participant.
- Significant decisions made or outcomes reached.
- The overall emotional tone or atmosphere of the conversation.
- Any impressions or key takeaways the NPCs might have.

Output ONLY the summary text. Do NOT use JSON or formatting. Do NOT include any preamble like "Here is the summary:".`,a=`Generate a memory summary for the following conversation:
- Conversation Participants: ${e.dialogueParticipants.join(", ")}
${e.storyArc?`- Narrative Arc: ${e.storyArc.title} (Act ${String(e.storyArc.currentAct)}: ${e.storyArc.acts[e.storyArc.currentAct-1].title})`:`- Theme: "${((r=e.theme)==null?void 0:r.name)??e.themeName}" (${((i=e.theme)==null?void 0:i.storyGuidance)??"None"})`}
- Scene at the start of conversation: "${e.currentScene}"
- Context: Time: "${e.localTime??"Unknown"}", Environment: "${e.localEnvironment??"Undetermined"}", Place: "${e.localPlace??"Undetermined"}"

## Full Dialogue Transcript:
${n}

Output ONLY the summary text. Do NOT use JSON or formatting. Do NOT include any preamble like "Here is the summary:".`;return{systemInstructionPart:o,userPromptPart:a}},ft=e=>{const n=e.replace(/[\s_]+/g,"-").replace(/[^a-zA-Z0-9-]/g,"").replace(/-+$/,""),o=Math.random().toString(36).substring(2,6);return`${n}-${o}`},Dt=e=>e.replace(/\[[^\]]*\]|\([^)]*\)/g,"").replace(/\s+/g," ").trim(),oa=(e,t,n,o)=>{if(!e||!t)return 1/0;const a=pr(e,t,n,o);return a?a.filter(r=>r.step==="edge").length:1/0},je=(e,t,n,o,a=!1)=>{if(!e)return a?[]:void 0;const r=t.find(I=>I.id===e);if(!a&&r)return r;const i=I=>I.toLowerCase().replace(/[.,!?;:"(){}[\]'’]/g,"").trim(),s=i(e),c=t.filter(I=>i(I.placeName)===s),l=t.filter(I=>{var S;return(S=I.aliases)==null?void 0:S.some(M=>i(M)===s)}).filter(I=>!c.includes(I)),d=n?Dn(n):void 0,u=I=>!n||!o?I:[...I].sort((S,M)=>oa(n,o,S.id,d)-oa(n,o,M.id,d)),m=u(c),p=u(l);if(a){const I=[];return r&&I.push(r),I.push(...m),I.push(...p),I}if(m.length>0)return m[0];if(p.length>0)return p[0];const g=e.toLowerCase();let f=t.find(I=>I.id.toLowerCase().includes(g));const v=/^(.*)-([a-zA-Z0-9]{4})$/;let y=null;if(!f){const I=v.exec(e);if(I){const S=I[1];y=S;const M=t.filter(k=>k.id.toLowerCase().startsWith(`${S.toLowerCase()}-`));M.length===1&&(f=M[0])}}if(f)return f;const w=i((y??e).replace(/-/g," ")),h=t.find(I=>i(I.placeName)===w);if(h)return h;const T=t.find(I=>{var S;return(S=I.aliases)==null?void 0:S.some(M=>i(M)===w)});return T||r},On=(e,t,n=!1)=>{if(!e)return n?[]:void 0;const o=t.find(s=>s.id===e);if(!n&&o)return o;const a=e.toLowerCase(),r=t.filter(s=>s.name.toLowerCase()===a),i=t.filter(s=>{var c;return(c=s.aliases)==null?void 0:c.some(l=>l.toLowerCase()===a)}).filter(s=>!r.includes(s));if(n){const s=[];return o&&s.push(o),s.push(...r),s.push(...i),s}return r.length>0?r[0]:i.length>0?i[0]:o},Fe=(e,t,n=!1,o=!1)=>{if(!Array.isArray(e)||e.length===0)return n?[]:null;const[a,r]=e,i=[],s=typeof r=="string"?r:void 0,c=(l,d)=>{const u=Dt(l),m=Dt(d);return o?u.toLowerCase()===m.toLowerCase():u===m};if(a){const l=t.find(d=>d.id===a);if(l){if(s&&!c(l.name,s)&&console.warn(`findItemByIdentifier: Provided name "${s}" does not match item name "${l.name}" for <ID: ${a}>.`),!n)return l;i.push(l)}}if((!a||n)&&s){const l=t.filter(d=>c(d.name,s)&&(!a||d.id!==a));if(n)i.push(...l);else if(l.length>0)return l[0]}if(!n&&o&&s){const l=Dt(s).toLowerCase(),d=t.find(u=>Dt(u.name).toLowerCase()===l);if(d)return d}return n?i:null},io=e=>ft(`node-${e}`),Nt=e=>ft(`npc-${e}`),vr=e=>{const t=Dt(e);return ft(`item-${t}`)},bt=e=>{if(typeof e=="string"){const t=e.trim();if(t.length>0)return t}return Mn},Uc=e=>{if(Array.isArray(e)){const t=[];for(const n of e){if(typeof n!="string")continue;const o=n.trim();o.length!==0&&t.push(o)}return t}if(typeof e=="string"){const t=e.trim();return t.length>0?[t]:[]}return[]},At=(e,t)=>Uc(e??t),Ir=e=>{if(!e||typeof e!="object")return null;const t=e,n={...t,attitudeTowardPlayer:bt(t.attitudeTowardPlayer),knowsPlayerAs:At(t.knowsPlayerAs,t.knownPlayerName),lastKnownLocation:t.lastKnownLocation===void 0?null:t.lastKnownLocation,preciseLocation:t.preciseLocation===void 0?null:t.preciseLocation};return delete n.knownPlayerName,xi(n)?n:null},Nr=e=>({...e,id:Nt(e.name),aliases:e.aliases??[],presenceStatus:e.presenceStatus??"unknown",attitudeTowardPlayer:bt(e.attitudeTowardPlayer),knowsPlayerAs:e.knowsPlayerAs??[],lastKnownLocation:e.lastKnownLocation??null,preciseLocation:e.preciseLocation??null,dialogueSummaries:[]}),br=e=>{if(!Oi(e))return null;const t=e,n=At(t.newKnownPlayerNames,t.newKnownPlayerName);return n.length>0&&(t.newKnownPlayerNames=Array.from(new Set(n))),delete t.newKnownPlayerName,t},Ar=(e,t)=>{const n=[...t.allRelevantNPCs],o=new Map(n.map(i=>[i.name,i])),a=i=>{const s=Ir(i);if(!s)return;const c=Nr(s);n.push(c),o.set(c.name,c)},r=i=>{const s=br(i);if(!s)return;const c=o.get(s.name),l={id:Nt(s.name),name:s.name,description:s.newDescription??(c==null?void 0:c.description)??"Updated NPC",aliases:s.newAliases??(s.addAlias?[...(c==null?void 0:c.aliases)??[],s.addAlias]:(c==null?void 0:c.aliases)??[]),presenceStatus:s.newPresenceStatus??(c==null?void 0:c.presenceStatus)??"unknown",attitudeTowardPlayer:bt(s.newAttitudeTowardPlayer??(c==null?void 0:c.attitudeTowardPlayer)),knowsPlayerAs:At(s.newKnownPlayerNames,c==null?void 0:c.knowsPlayerAs),lastKnownLocation:s.newLastKnownLocation??(c==null?void 0:c.lastKnownLocation)??null,preciseLocation:s.newPreciseLocation??(c==null?void 0:c.preciseLocation)??null,dialogueSummaries:(c==null?void 0:c.dialogueSummaries)??[]};n.push(l),o.set(l.name,l)};return Array.isArray(e.npcsAdded)&&e.npcsAdded.forEach(a),Array.isArray(e.npcsUpdated)&&e.npcsUpdated.forEach(r),n},_c=async(e,t,n)=>{if(!e||typeof e!="object")return null;const o=e,a=Array.isArray(o.participants)?o.participants:[],r=Array.isArray(o.initialNpcResponses)?o.initialNpcResponses:[],i=Array.isArray(o.initialPlayerOptions)?o.initialPlayerOptions:[];if(a.length===0&&r.length===0)return null;const s=Ar(t,n),c=new Set(s.map(w=>w.name)),l=Array.from(c),d=w=>{c.has(w)||(c.add(w),l.push(w))},u=new Map,m=async w=>{if(typeof w!="string")return null;const h=w.trim();if(h.length===0)return null;const T=u.get(h);if(T!==void 0)return T;if(c.has(h))return u.set(h,h),h;const I=On(h,s);if(I&&!Array.isArray(I))return d(I.name),u.set(h,I.name),I.name;if(l.length===0)return u.set(h,null),null;const S=await Ln("dialogue participant",h,n.logMessageFromPayload??t.logMessage,n.sceneDescriptionFromPayload??t.sceneDescription,l,n.theme);return S&&c.has(S)?(u.set(h,S),S):(u.set(h,null),null)},p=new Set,g=[];for(const w of a){const h=await m(w);h&&!p.has(h)&&(p.add(h),g.push(h))}const f=[];for(const w of r){if(!w||typeof w!="object")continue;const h=w;if(typeof h.line!="string")continue;const T=h.line.trim();if(T.length===0)continue;const I=await m(h.speaker);if(!I)continue;p.has(I)||(p.add(I),g.push(I));const S={speaker:I,line:T};if(typeof h.thought=="string"){const M=h.thought.trim();M.length>0&&(S.thought=M)}f.push(S)}const v=w=>{if(typeof w=="string"){const h=w.trim();return h.length>0?h:null}if(w&&typeof w=="object"){const h=w.text;if(typeof h=="string"){const T=h.trim();return T.length>0?T:null}}return null},y=[];for(const w of i){const h=v(w);h&&(y.includes(h)||y.push(h))}return g.length===0||f.length===0||y.length===0?null:{participants:g,initialNpcResponses:f,initialPlayerOptions:y}},Ft=e=>{const t={...e};return t.presenceStatus==="distant"||t.presenceStatus==="unknown"?t.preciseLocation=null:t.preciseLocation??(t.preciseLocation=t.presenceStatus==="companion"?"with you":"nearby in the scene"),t},ht=(...e)=>{const t=new Set;for(const n of e)if(n)for(const o of n){if(typeof o!="string")continue;const a=o.trim();a.length!==0&&t.add(a)}return Array.from(t)},jc=(e,t)=>{const n={...e};return t.newDescription!==void 0&&(n.description=t.newDescription),t.newAliases!==void 0&&(n.aliases=t.newAliases),t.addAlias&&(n.aliases=ht(n.aliases??[],[t.addAlias])),t.newPresenceStatus!==void 0&&(n.presenceStatus=t.newPresenceStatus),t.newAttitudeTowardPlayer!==void 0&&(n.attitudeTowardPlayer=bt(t.newAttitudeTowardPlayer)),t.newKnownPlayerNames!==void 0&&(n.knowsPlayerAs=At(t.newKnownPlayerNames)),t.newLastKnownLocation!==void 0&&(n.lastKnownLocation=t.newLastKnownLocation),t.newPreciseLocation!==void 0&&(n.preciseLocation=t.newPreciseLocation),Ft(n)},Fc=(e,t)=>{const n=e.newAliases??ht(t==null?void 0:t.aliases,e.addAlias?[e.addAlias]:void 0),o=e.newKnownPlayerNames,a=o===void 0?[]:At(o);return Ft({id:Nt(e.name),name:e.name,description:e.newDescription??(t==null?void 0:t.description)??`Details for ${e.name} are emerging.`,aliases:n,presenceStatus:e.newPresenceStatus??(t==null?void 0:t.presenceStatus)??"unknown",attitudeTowardPlayer:bt(e.newAttitudeTowardPlayer??(t==null?void 0:t.attitudeTowardPlayer)),knowsPlayerAs:a,lastKnownLocation:e.newLastKnownLocation??(t==null?void 0:t.lastKnownLocation)??null,preciseLocation:e.newPreciseLocation??(t==null?void 0:t.preciseLocation)??null,dialogueSummaries:[]})},Vc=async(e,t,n)=>{let o=Fc(e);if(o.description===`Details for ${e.name} are emerging.`){const a=await cr(e.name,n.logMessageFromPayload??t.logMessage,n.sceneDescriptionFromPayload??t.sceneDescription,n.theme,n.allRelevantMainMapNodesForCorrection);a&&(o=Wc(o,a))}return o},Gc=async(e,t,n,o,a)=>{if(!e||typeof e!="object")return console.warn("parseAIResponse ('npcsUpdated'): Update missing or malformed. Discarding.",e),null;const r={...e};if(typeof r.name!="string"||r.name.trim()==="")return console.warn("parseAIResponse ('npcsUpdated'): Update missing or has invalid 'name'. Discarding.",e),null;const i=r.name;if("newKnownPlayerName"in r){const l=r.newKnownPlayerName;r.newKnownPlayerNames=Array.isArray(l)?l:l!=null?[l]:[],delete r.newKnownPlayerName}const s=On(r.name,t);if(s)r.name=s.name;else if(!n.has(r.name)){console.warn(`parseAIResponse ('npcsUpdated'): Identifier "${i}" not found. Attempting name correction.`);const l=await Ln("NPC name",r.name,a.logMessageFromPayload??o.logMessage,a.sceneDescriptionFromPayload??o.sceneDescription,Array.from(n),a.theme);l&&l.trim()!==""?(r.name=l,console.log(`parseAIResponse ('npcsUpdated'): Corrected target name to "${l}".`)):console.warn(`parseAIResponse ('npcsUpdated'): Failed to correct identifier "${i}". Will attempt to process as is, may convert to 'add'.`)}const c=br(r);return c||(console.warn(`parseAIResponse ('npcsUpdated'): Payload for "${i}" is invalid after potential name correction. Discarding. Payload:`,r),null)},Kc=(e,t)=>{const n=At(t.knowsPlayerAs,t.knownPlayerName);return Ft({id:Nt(e),name:e,description:t.description,aliases:ht(t.aliases),presenceStatus:t.presenceStatus,attitudeTowardPlayer:bt(t.attitudeTowardPlayer),knowsPlayerAs:n,lastKnownLocation:t.lastKnownLocation,preciseLocation:t.preciseLocation,dialogueSummaries:[]})},Bc=async(e,t,n)=>{const o=await cr(e??"Newly Mentioned NPC",n.logMessageFromPayload??t.logMessage,n.sceneDescriptionFromPayload??t.sceneDescription,n.theme,n.allRelevantMainMapNodesForCorrection);if(!o)return null;const a=o.description.split(" ").slice(0,2).join(" ").trim();return Kc(e??(a||"Corrected NPC"),o)},Wc=(e,t)=>{const n=ht(e.aliases,t.aliases),o=ht(e.knowsPlayerAs,At(t.knowsPlayerAs,t.knownPlayerName));return Ft({...e,description:t.description,aliases:n,presenceStatus:t.presenceStatus,attitudeTowardPlayer:bt(t.attitudeTowardPlayer??e.attitudeTowardPlayer),knowsPlayerAs:o,lastKnownLocation:t.lastKnownLocation,preciseLocation:t.preciseLocation})};function Yc(e,t,n){if(!e||typeof e!="object")return console.warn("parseAIResponse: Parsed data is not a valid object.",e),n==null||n("non_object","Storyteller response must be a JSON object that matches the expected schema."),null;const o=e;if(typeof o.sceneDescription!="string"||o.sceneDescription.trim()==="")return console.warn("parseAIResponse: sceneDescription is missing or empty.",e),n==null||n("missing_scene_description",'Storyteller response must include a non-empty "sceneDescription" field.'),null;const a=d=>d==null||typeof d=="string",r=d=>d==null||typeof d=="boolean",i=d=>d==null||Array.isArray(d),s=d=>d==null||typeof d=="object";return a(o.mainQuest)&&a(o.currentObjective)&&a(o.logMessage)&&i(o.npcsAdded)&&i(o.npcsUpdated)&&r(o.objectiveAchieved)&&r(o.mainQuestAchieved)&&a(o.localTime)&&a(o.localEnvironment)&&a(o.localPlace)&&s(o.dialogueSetup)&&r(o.mapUpdated)&&a(o.currentMapNodeId)&&a(o.mapHint)&&a(o.playerItemsHint)&&a(o.worldItemsHint)&&a(o.npcItemsHint)&&a(o.librarianHint)&&i(o.newItems)?Ss(o):(console.warn("parseAIResponse: Basic field validation failed (pre-dialogue specifics and array checks).",e),n==null||n("invalid_base_fields","Storyteller response contained invalid or mistyped base fields. Ensure optional arrays and strings use the correct types."),null)}async function Hc(e,t){var r;let n=e.dialogueSetup,o=Array.isArray(e.options)?e.options:[],a=!1;if(n){const i=await _c(n,e,t);i&&(n=i);let s=so(n);if(!s){console.warn("parseAIResponse: 'dialogueSetup' is present but malformed. Attempting correction.");const c=Ar(e,t),l=await Ac(t.logMessageFromPayload??e.logMessage,t.sceneDescriptionFromPayload??e.sceneDescription,t.theme,c,t.allRelevantMainMapNodesForCorrection,t.currentInventoryForCorrection,t.heroGender,n);l&&so(l)?(n=l,s=!0,console.log("parseAIResponse: Successfully corrected 'dialogueSetup'.")):(console.warn("parseAIResponse: Failed to correct 'dialogueSetup' or corrected version is still invalid. Discarding dialogue attempt."),n=void 0,s=!1)}a=s&&!!n,a&&(o=[])}return!a&&(n=void 0,!Array.isArray(o)||!o.every(i=>typeof i=="string"))?(console.warn("parseAIResponse: options are missing or invalid (must be array of strings) when not in dialogue.",e),(r=t.recordFailure)==null||r.call(t,"invalid_options","Storyteller response must provide six distinct action options when not initiating dialogue."),null):{dialogueSetup:n,options:o,isDialogueTurn:a}}async function Jc(e,t,n,o){const a=[],r=[],i=new Map,s=new Set(o.allRelevantNPCs.map(p=>p.name)),c=new Set(s),l=[...o.allRelevantNPCs],d=p=>{const g=Ft(p),f=i.get(g.name);if(f===void 0)i.set(g.name,a.length),a.push(g),l.push(g);else{const v=a[f],y=Ft({...v,...g,aliases:ht(v.aliases,g.aliases),knowsPlayerAs:ht(v.knowsPlayerAs,g.knowsPlayerAs)});a[f]=y;const w=l.findIndex(h=>h.name===y.name);w>=0?l[w]=y:l.push(y)}c.add(g.name)};if(Array.isArray(e))for(const p of e){const g=typeof p=="object"&&p!==null&&"name"in p&&typeof p.name=="string"?p.name??void 0:void 0,f=Ir(p);if(f){d(Nr(f));continue}console.warn(`parseAIResponse ('npcsAdded'): Invalid NPC structure for "${g??"Unknown Name"}". Attempting correction.`);const v=await Bc(g,n,o);v?(d(v),console.log("parseAIResponse ('npcsAdded'): Successfully corrected NPC:",v.name)):console.warn(`parseAIResponse ('npcsAdded'): Failed to correct NPC "${g??"Unknown Name"}". Discarding.`)}else e!==void 0&&console.warn("parseAIResponse ('npcsAdded'): Field was present but not an array.",e);const u=Array.isArray(t)?t:[],m=[];for(const p of u){const g=await Gc(p,l,c,n,o);g&&(m.push(g),c.add(g.name))}for(const p of m){const g=p.name,f=i.get(g);if(s.has(g)){r.push(p);continue}if(f!==void 0){r.push(p);const y=jc(a[f],p);a[f]=y;const w=l.findIndex(h=>h.name===g);w>=0?l[w]=y:l.push(y);continue}console.warn(`parseAIResponse ('npcsUpdated'): Target NPC "${g}" for update not found. Converting to an add operation.`);const v=await Vc(p,n,o);d(v)}return{npcsAdded:a,npcsUpdated:r}}async function Sr(e,t,n,o,a,r,i=[],s={nodes:[],edges:[]},c=[]){var f,v,y;const l=e,d=s.nodes.filter(w=>w.type!=="feature");let u=null,m=null;const p=(w,h)=>{u===null&&(u=w,m=h)},g=(w,h)=>({data:null,reason:u??w,error:m??h});try{const w=he(l);if(w===null)throw p("json_parse_failed","Storyteller response could not be parsed as JSON."),new Error("JSON parse failed");const h=Yc(w,o,p);if(!h)return g("invalid_base_fields","Storyteller response failed base validation.");const T={heroGender:(n==null?void 0:n.gender)??"Male",theme:t,onParseAttemptFailed:o,logMessageFromPayload:a,sceneDescriptionFromPayload:r,allRelevantNPCs:i,allRelevantMainMapNodesForCorrection:d,currentInventoryForCorrection:c,recordFailure:p},I=await Hc(h,T);if(!I)return g("invalid_options","Storyteller response must include valid action options when dialogue is not triggered.");h.dialogueSetup=I.dialogueSetup,h.options=I.options;let S=I.isDialogueTurn;h.itemChange=[];const M=await Jc(h.npcsAdded,h.npcsUpdated,h,T);if(h.npcsAdded=M.npcsAdded,h.npcsUpdated=M.npcsUpdated,S&&h.dialogueSetup){const k=[...i,...h.npcsAdded??[]],$=new Set([...k.map(E=>E.name),...h.npcsUpdated.map(E=>E.name)]),L=[];for(const E of h.dialogueSetup.participants){const N=On(E,k);if(N)L.push(N.name);else if($.has(E))L.push(E);else{console.warn(`parseAIResponse: Dialogue participant "${E}" is not among known or newly added/updated NPCs. Attempting name correction against this turn's NPCs.`);const A=await Ln("dialogue participant",E,a??h.logMessage,r??h.sceneDescription,Array.from($),t);A&&$.has(A)?(L.push(A),console.log(`parseAIResponse: Corrected dialogue participant name from "${E}" to "${A}".`)):console.warn(`parseAIResponse: Dialogue participant "${E}" could not be validated/corrected against this turn's NPCs. Discarding participant.`)}}L.length===0&&h.dialogueSetup.participants.length>0?(console.warn("parseAIResponse: No valid dialogue participants remain after final name validation. Discarding dialogue attempt."),h.dialogueSetup=void 0,S=!1,(!Array.isArray(h.options)||h.options.length===0||!h.options.every(E=>typeof E=="string"&&E.trim()!==""))&&(console.warn("parseAIResponse: options invalid after dialogue cancellation. Resetting to default failsafe.",h.options),h.options=["Look around.","Ponder the situation.","Check inventory.","Try to move on.","Consider your objective.","Plan your next steps."])):h.dialogueSetup.participants=L}if(S)h.options=[];else{if(!Array.isArray(h.options)||h.options.length===0||!h.options.every(k=>typeof k=="string"&&k.trim()!==""))return console.warn("parseAIResponse: options are missing, empty, or invalid when not inDialogue (final check).",h.options),o==null||o(),p("invalid_options","Storyteller response must provide six distinct action options when not initiating dialogue."),g("invalid_options","Storyteller response must provide six distinct action options when not initiating dialogue.");for(;h.options.length<ct;)h.options.push("...");h.options.length>ct&&(h.options=h.options.slice(0,ct))}return h.objectiveAchieved=h.objectiveAchieved??!1,h.mainQuestAchieved=h.mainQuestAchieved??!1,h.localTime=((f=h.localTime)==null?void 0:f.trim())??"Time Unknown",h.localEnvironment=((v=h.localEnvironment)==null?void 0:v.trim())??"Environment Undetermined",h.localPlace=((y=h.localPlace)==null?void 0:y.trim())??"Undetermined Location",Nc(h),delete h.placesAdded,delete h.placesUpdated,{data:h,error:null,reason:null}}catch(w){return console.warn("parseAIResponse: Failed to parse JSON response from AI. This attempt will be considered a failure.",w),console.debug("parseAIResponse: Original response text (before any processing):",e),console.debug("parseAIResponse: JSON string after fence stripping (if any, input to JSON.parse):",l),p("json_parse_failed","Storyteller response could not be parsed as JSON."),g("unknown","Storyteller response failed due to an unknown parsing error.")}}const qc={type:"object",properties:{dialogueEnds:{type:"boolean",description:"Set to true if any of the dialogue participants signal the end of the conversation, or if the conversation obviously reached its logical conclusion."},npcResponses:{type:"array",minItems:1,description:"NPC lines for this turn. Each speaker must be an active participant and lines must be non-empty.",items:{type:"object",properties:{line:{type:"string"},speaker:{type:"string"}},propertyOrdering:["line","speaker"],required:["line","speaker"],additionalProperties:!1}},playerOptions:{type:"array",minItems:Ba,maxItems:Ka,description:"Possible player replies, MUST ALWAYS be in the form of direct speech. The last option must contextually appropriately end the conversation.",items:{type:"string"}},updatedParticipants:{type:"array",minItems:1,description:"Provide the new full list of participants if it changes. Don't include the player.",items:{type:"string"}},npcAttitudeUpdates:{type:"array",description:"Describe any change in NPC's attitude toward the player during this turn.",items:{type:"object",properties:{name:{type:"string"},newAttitudeTowardPlayer:{type:"string"}},required:["name","newAttitudeTowardPlayer"],additionalProperties:!1}},npcKnownNameUpdates:{type:"array",description:"Describe any change in the name or nickname the NPC uses for the player.",items:{type:"object",properties:{name:{type:"string"},newKnownPlayerNames:{type:"array",items:{type:"string"}},addKnownPlayerName:{type:"string"}},required:["name"],additionalProperties:!1}}},required:["dialogueEnds","npcResponses","playerOptions"],propertyOrdering:["dialogueEnds","npcResponses","playerOptions","updatedParticipants","npcAttitudeUpdates","npcKnownNameUpdates"],additionalProperties:!1},zc=async(e,t,n,o,a,r,i,s,c,l,d,u,m,p,g,f)=>{if(!ee())return console.error("API Key not configured for Dialogue Service."),Promise.reject(new Error("API Key not configured."));const v=Rc({theme:e,currentQuest:n,currentObjective:o,currentScene:a,localTime:r,localEnvironment:i,localPlace:s,knownMainMapNodes:c,knownNPCs:l,inventory:d,heroSheet:u,storyArc:t,dialogueHistory:m,playerLastUtterance:p,dialogueParticipants:g,relevantFacts:f});let y=null;const w=await ie(async h=>{var T,I,S;try{const M=h>0&&y?`${v}

[Parser Feedback]
${y}`:v;console.log(`Fetching dialogue turn (Participants: ${g.join(", ")}, Attempt ${String(h+1)}/${String(B+1)})`),ae(ne.dialogue_turn.icon);const k=Se(512),{response:$}=await oe({modelNames:[z,Q],prompt:M,systemInstruction:Ys,temperature:.8,responseMimeType:"application/json",thinkingBudget:k,includeThoughts:!0,jsonSchema:qc,label:"Dialogue"}),E=(((S=(I=(T=$.candidates)==null?void 0:T[0])==null?void 0:I.content)==null?void 0:S.parts)??[]).filter(P=>P.thought===!0&&typeof P.text=="string").map(P=>P.text);let N=null,A=fr($.text??"",E,P=>{N=P});if(A??(A=await Sc($.text??"",g,e,E)),A)return y=null,{result:{parsed:A,rawResponse:$.text??"",thoughts:E,promptUsed:M}};console.warn(`executeDialogueTurn (Attempt ${String(h+1)}/${String(B+1)}): invalid response even after correction`),typeof N=="string"?y=N:y="The previous dialogue response did not follow the required JSON schema for npcResponses/playerOptions. Return valid structured JSON only."}catch(M){throw console.error(`Error fetching dialogue turn (Attempt ${String(h+1)}/${String(B+1)}):`,M),M}return{result:null}});if(w)return{parsed:w.parsed,prompt:w.promptUsed,rawResponse:w.rawResponse,thoughts:w.thoughts};throw new Error("Failed to fetch dialogue turn after maximum retries.")},Qc=async e=>{if(!ee())return console.error("API Key not configured for Dialogue Summary Service."),Promise.reject(new Error("API Key not configured."));if(!e.theme)return console.error("DialogueSummaryContext missing theme. Cannot summarize dialogue."),Promise.reject(new Error("DialogueSummaryContext missing theme."));const{theme:t}=e,n=Oc(e);let o=null;const a=await ie(async r=>{var i,s,c;try{const l=r>0&&o?`${n}

[Parser Feedback]
${o}`:n;console.log(`Summarizing dialogue with ${e.dialogueParticipants.join(", ")}, Attempt ${String(r+1)}/${String(B+1)})`),ae(ne.dialogue_summary.icon);const d=Se(4096),{response:u}=await oe({modelNames:[Q],prompt:l,systemInstruction:Ut,temperature:1,responseMimeType:"application/json",thinkingBudget:d,includeThoughts:!0,jsonSchema:rr,label:"Storyteller"}),p=(((c=(s=(i=u.candidates)==null?void 0:i[0])==null?void 0:s.content)==null?void 0:c.parts)??[]).filter(f=>f.thought===!0&&typeof f.text=="string").map(f=>f.text),g=await Sr(u.text??"",t,e.heroSheet??null,void 0,void 0,void 0,e.knownNPCs,e.mapDataSnapshot,e.inventory);if(g.data)return o=null,{result:{parsed:g.data,rawResponse:u.text??"",thoughts:p,promptUsed:l}};g.error&&console.warn(`executeDialogueSummary (Attempt ${String(r+1)}/${String(B+1)}): ${g.error}`),console.warn(`executeDialogueSummary (Attempt ${String(r+1)}/${String(B+1)}): invalid JSON, retrying`),o=typeof g.error=="string"?g.error:"The previous dialogue summary did not match the expected storyteller schema. Return valid JSON only."}catch(l){throw console.error(`Error summarizing dialogue (Attempt ${String(r+1)}/${String(B+1)}):`,l),l}return{result:null}});return a?{parsed:a.parsed,prompt:a.promptUsed,rawResponse:a.rawResponse,thoughts:a.thoughts}:{parsed:null,prompt:n,rawResponse:"",thoughts:[]}},Xc=async e=>{if(!ee())return console.error("API Key not configured for Dialogue Memory Summary Service."),null;if(!e.theme)return console.error("DialogueMemorySummaryContext missing theme. Cannot summarize memory."),null;const{systemInstructionPart:t,userPromptPart:n}=xc(e);let o=null;return await ie(async r=>{var i;try{const s=r>0&&o?`${n}

[Parser Feedback]
${o}`:n;console.log(`Generating memory summary for dialogue with ${e.dialogueParticipants.join(", ")}, Attempt ${String(r+1)}/${String(B+1)})`),ae(ne.dialogue_memory.icon);const{response:c}=await oe({modelNames:[be,z],prompt:s,systemInstruction:t,temperature:Me,label:"Corrections"}),l=((i=c.text)==null?void 0:i.trim())??null;if(l&&l.length>0)return console.log(`summarizeDialogueForMemory: ${e.dialogueParticipants.join(", ")} will remember ${l}`),o=null,{result:l};console.warn(`executeMemorySummary (Attempt ${String(r+1)}/${String(B+1)}): empty memory text`),o="The previous attempt returned an empty memory summary. Respond with a concise sentence describing the memory."}catch(s){if(console.error(`Error generating memory summary (Attempt ${String(r+1)}/${String(B+1)}):`,s),!nn(s))return{result:null,retry:!1};throw s}return{result:null}})??null},Tr=(e,t,n,o,a)=>{const r=n?`
${Lo(n)}`:"",i=o?`
${Rn(o,!1)}`:"",s=a?`
${gr(a)}`:"",c=`${r}${i}${s}`;return`Theme: ${e}

  ## Context:
${t}${c}

List immutable facts according to your instructions. Return JSON as:
[{"entities": ["id1", "id2"], "text": "fact"}]
`},Zc=(e,t,n,o,a)=>{const r=t.map(c=>`- ID ${String(c.id)}: ${c.text} [${c.entities.join(", ")}]`).join(`
`)||"None.",i=n.map(c=>`- ${c.text} [${c.entities.join(", ")}]`).join(`
`)||"None.",s=mr([o,a].filter(c=>c.trim()!==""));return`Theme: ${e}

  ## Recent Events:
${s||"None"}

  ## Known Facts:
${r}

  ## New Candidate Facts:
${i}

Provide facts integration, changes and pruning instructions acording to your instructions.
`},el=(e,t,n,o,a,r)=>{const i=t.map((c,l)=>`${String(l+1)}. (Tier ${String(c.tier)}) ${c.text}`).join(`
`),s=a.map(c=>`- ${c}`).join(`
`);return`**Context for Fact Selection**
Theme: ${e}
Last Scene: "${n}"
Recent Log:
  ${s}
  ${r}

  ## Player Actions:
${o}

  ------
  
Select the 10 most relevant facts from the list of Known Facts:
${i}
`},tl=(e,t,n,o,a,r,i)=>{const s=t.map(u=>`- ID ${String(u.id)}: "${u.text}" [${u.entities.join(", ")}] (Tier ${String(u.tier)})`).join(`
`),c=a.map(u=>`- ${u}`).join(`
`),l=r.map(u=>`- ${u}`).join(`
`),d=i.map(u=>`- ${u}`).join(`
`);return`Theme: ${e}
Current Quest: ${n??"None"}
Current Objective: ${o??"None"}

## Recent Events:
${d||"None"}

## Inventory Items:
${c||"None"}

## Known Places:
${l||"None"}

## Current Facts:
${s}

Identify sets of facts that could be merged into a single, more specific statement.
Delete facts that reference obsolete quests, objectives, conditions, items or places. If merging or deleting, provide instructions.
`},nl=e=>{if(!e||typeof e!="object")return!1;const t=e;return!(typeof t.action!="string"||t.entities!==void 0&&(!Array.isArray(t.entities)||!t.entities.every(n=>typeof n=="string"))||t.text!==void 0&&typeof t.text!="string")},Pr=e=>{const t=he(e);return t&&Array.isArray(t)&&t.every(n=>{if(!n||typeof n!="object")return!1;const o=n.entities;return typeof n.text=="string"&&Array.isArray(o)&&o.every(a=>typeof a=="string")})?t:null},Cr=(e,t=[])=>{const n=he(e);if(!n||typeof n!="object")return null;const o=n,a=[],r=t.map(l=>l.id);if(Array.isArray(o.factsChange)&&o.factsChange.forEach(l=>{nl(l)&&(Array.isArray(l.entities)&&(l.entities=l.entities.filter(d=>typeof d=="string")),a.push(l))}),a.some(l=>(l.action==="change"||l.action==="delete")&&(typeof l.id!="number"||!r.includes(l.id))))return null;const i=typeof o.loreRefinementOutcome=="string"?o.loreRefinementOutcome:"",s=typeof o.observations=="string"?o.observations:void 0,c=typeof o.rationale=="string"?o.rationale:void 0;return{factsChange:a,loreRefinementOutcome:i,observations:s,rationale:c}},ol=e=>{const t=he(e);return t&&Array.isArray(t)&&t.every(n=>typeof n=="string")?t:null},Er=`You are the Loremaster, collecting immutable facts about the game world from narrative context.
Your sole task is to harvest immutable, setting-level facts from the surrounding narrative and return them as a JSON array of objects with "text" and "entities" fields.
The "entities" array must list IDs of map nodes, NPCs or items referenced in the fact, selected from the supplied node-, npc-, and item- IDs. Use 'player' ID to reference the player character. Use '${K}' ID to reference the world in general.
Each fact must aid long-term continuity and world-building.

## What is a valid fact? Think “map pins & rulebook notes”
- Geography & structures, such as Stable locations, routes, landmarks, architecture, for example: “The Citadel of Glass rises at the mouth of the Azure Gulf.”
- Lore & history, such as Past events, legendary deeds, consequences, for example: “The War of Ashes ended with the signing of the Ember Accord.”
- Cultural rules & customs, such as Laws, taboos, rituals, social hierarchies, for example: “Necromancy is outlawed within the Kingdom of Silverpine.”
- Relationships & roles, such as Power structures, affiliations, well-known titles, for example: “The Order of Verdant Flame answers directly to the crown.”
- Properties of artefacts or creatures, such as Enduring traits that future scenes should honour, for example: “Obsidian golems can be shattered only by sound of a crystal horn.”

## What to reject outright:
- Ephemeral or player-centric details;
- Reference to non-specific nondescript directions or locations - a tavern, a path, a road, a plain, a river, a forest, a mountain, a city, a kingdom, a continent, etc.;
- Current weather, smells, lighting, time of day;
- Sensory “vibe” descriptions (“The market buzzes with chatter”);
- Player inventory, position, quests, feelings, level, dialogue;
- Transactional minutiae - Prices, haggling, countdowns to completion;
- Unverified rumours or philosophical musings - “It is said that…”, “True readiness involves an open spirit…”;
- Bare names or cosmetic trivia “The tavern keeper is named Jorim.”;
- Clothing colours unless culturally significant;
- Duplicates or contradictions;
- Statements already recorded or that clash with existing facts.

## Quality checklist (run mentally for every candidate)
- Standalone? Reads clearly and specific enough to be understood without outside context.
- Enduring? Will still matter a week of in-game time later.
- World-level? Describes the setting, not the current scene.
- Certain? Factual, not conjecture or flavour text.
- Non-redundant? Adds something new (no near-duplicates).

## Examples of *good* quality facts:
- "The city of Dorim is carved into a cliff face.",
- "A secret tunnel links the tavern cellar to the old crypt.",
- "The black market dealer's nickname is Catfish.",
- "The password to the lower deck service console is qwerty123.",
- "The city of Copperhaven is built on three terraced plateaus.",
- "A crystal bridge spans the River Umber beneath the northern plateau.",
- "The Sapphire Guild controls all official cartography in the realm.",
- "Defeating a stone golem requires striking the rune on its chest.",
- "The High Council convenes at dawn on the first day of every month.",
- "The catacombs under Copperhaven were sealed two centuries ago after a plague."

## Examples of *bad* quality and irrelevant facts to avoid:
- "The weather is rainy." (Weather is too transient)
- "The player is in a tavern." (Contextual information, not a fact)
- "The player posesses a sword." (Player actions or possessions are not world facts)
- "The player is thinking about their plans." (Player dialogue is not a fact)
- "The player is a human." (Player characteristics are not world facts)
- "The player is a level 5 warrior." (Player attributes are not world facts)
- "The player is accompanied by an elf." (Player companions are not world facts)
- "It is night time outside." (Time of day is too transient)
- "Joseph said 'It is dangerous in the catacombs'." (Dialogue is not a fact)
- "Kevin stated, 'The forest is haunted'." (Dialogue is not a fact)
- "A gentle breeze blows through the trees." (Weather is too transient)
- "The player carries a rusty dagger." (Player possessions are not world facts)
- "A merchant offers apples for two copper coins." (Transactional details are not world facts)
- "The alley smells of wet garbage." (Sensory details are not world facts)
- "Gregory says, 'Beware the king!'" (Dialogue is not a fact)
- "Morning sunlight warms the streets." (Time of day is too transient)
- "It is rumored that dragons might exist somewhere." (Conjecture is not a fact)

CRITICALLY IMPORTANT: DO NOT include bad quality and irrelevant facts.
`,aa=`You are the Loremaster maintaining up-to-date set of facts about the game world.
1. Compare Recent Events and Known Facts, then change or delete any Known Facts that are obsolete and no longer in effect based on the story developments described in Recent Events.
2. Compare Candidate Facts with existing Known Facts, then add good Known Facts that don't lead to overlaps and potential contradictions with Known Facts.
Known Facts are listed with their numeric IDs. Use these IDs when specifying which fact to change or delete.

## Examples:
"factsChange": [
    {
        "action": "delete",
        "id": 13
    },
    {
        "action": "add",
        "entities": [
            "node-Whisperwood-Jungle-38ax"
        ],
        "text": "The Whisperwood Jungle is a colossal green wall of ancient trees and tangled vines, characterized by oppressive humidity in its undergrowth and a high canopy with gaps allowing sunlight to filter through. It resonates with exotic bird calls and the distant roar of vast, unseen creatures."
    },
    {
        "action": "change",
        "entities": [
            "node-Whisperwood-Jungle-38ax",
            "node-Jagged-Peaks-44re",
            "item-Ancient-Map-Fragment-mjdl"
        ],
        "id": 3
        "text": "From the current location within the Whisperwood Jungle, the colossal green wall appears to stretch limitlessly to the north. To the east, a dip in the terrain suggests a watercourse, while a lone, massive flowering tree with vibrant red blossoms is visible to the south. To the west, a distant jagged peak is discernible, matching a feature marked on the Ancient Map Fragment.",
        "tier": 2
    }
]
`,ra=`You are the Loremaster selecting relevant known facts.
Relevant facts are those that directly inform the next scene: details the NPCs might reference, rules that shape the environment, or recent events likely to influence decisions.
Select the ten most important facts for the upcoming story turn.
`,sa=`You are the Loremaster refining and pruning accumulated facts.
Consider the last 20 log entries supplied in the prompt. Remove or edit any facts that have been addressed and are no longer in effect.
1. Look for statements that describe the same idea and merge them into a single, more specific fact. Keep the length of the merged fact under 200 words. Split any fact longer than 200 words into two non-overlapping facts.
Increase the tier of the merged fact by one.
When merging, combine the entity IDs from all merged facts into a single set with no duplicates.
2. Prune facts that reference obsolete or irrelevant details, such as:
- places that no longer exist;
- items that no longer exist;
- old quest and objective that is different from the current quest and objective.
3. Edit or prune any facts facts that are obsolete and no longer in effect according to Recent Events.
4. Prune any simple statements about the Player posessing an inventory item or items - it's redundant.

## Examples:
"factsChange": [
    {
        "action": "delete",
        "id": 13
    },
    {
        "action": "add",
        "entities": [
            "node-Whisperwood-Jungle-38ax"
        ],
        "text": "The Whisperwood Jungle is a colossal green wall of ancient trees and tangled vines, characterized by oppressive humidity in its undergrowth and a high canopy with gaps allowing sunlight to filter through. It resonates with exotic bird calls and the distant roar of vast, unseen creatures."
    },
    {
        "action": "change",
        "entities": [
            "node-Whisperwood-Jungle-38ax",
            "node-Jagged-Peaks-44re",
            "item-Ancient-Map-Fragment-mjdl"
        ],
        "id": 3,
        "text": "From the current location within the Whisperwood Jungle, the colossal green wall appears to stretch limitlessly to the north. To the east, a dip in the terrain suggests a watercourse, while a lone, massive flowering tree with vibrant red blossoms is visible to the south. To the west, a distant jagged peak is discernible, matching a feature marked on the Ancient Map Fragment.",
        "tier": 2
    }
]
`,kr={type:"array",items:{type:"object",properties:{text:{type:"string"},entities:{type:"array",minItems:1,items:{type:"string"}}},propertyOrdering:["entities","text"],required:["entities","text"],additionalProperties:!1,description:`A fact extracted from the context that satisfies the requirement for the *good* quality fact and does not show signs of a *bad* quality fact. Entities array must include at least one relevant node-*, npc-*, or item-* ID from the supplied list of IDs, or the IDs "player" or "${K}".`}},ia={type:"array",minItems:10,maxItems:10,description:"From the provided facts list select 10 most important facts for the upcoming story turn.",items:{type:"string"}},ca={type:"object",properties:{observations:{type:"string",minLength:500,description:"Minimum 300 words. Observations about the lore state and the proposed new facts, e.g. There are 3 facts that can be merged. Some of the facts may be too vague or obsolete to be included..."},rationale:{type:"string",minLength:500,description:"Minimum 300 words. Rationale for and against including the proposed facts into the lore, e.g. Most facts are good enough to be included in the lore. However, the facts about the old tavern are no longer relevant. The fact about *a path* leading to the church is too vague - a more concrete named path should have been mentioned instead. I will omit these facts."},factsChange:{type:"array",items:{oneOf:[{type:"object",properties:{action:{enum:["add"]},entities:{type:"array",items:{type:"string"}},text:{type:"string",description:"Must be one of the accepted *New Candidate Facts*."}},propertyOrdering:["action","entities","text"],required:["action","entities","text"],additionalProperties:!1},{type:"object",description:"Change or delete the lore facts that are no longer relevant according to Recent Events",properties:{action:{enum:["delete","change"]},entities:{type:"array",items:{type:"string"}},id:{type:"integer",description:"ID of the fact to change or remove."},text:{type:"string",description:"Updated fact text for the change action."}},propertyOrdering:["action","entities","id","text"],required:["action","id"],additionalProperties:!1}]}}},required:["observations","rationale","factsChange"],propertyOrdering:["observations","rationale","factsChange"],additionalProperties:!1},la={type:"object",properties:{observations:{type:"string",minLength:500,description:"Minimum 300 words. Observations about the lore state, close duplicates, too vague facts, and facts made obsolete by recent events."},rationale:{type:"string",minLength:500,description:"Minimum 300 words. Rationale for the proposed mergers, splits, and deletions."},factsChange:{type:"array",items:{type:"object",description:"REQUIRED for the *add* and *change* actions. Omitted for the *delete* action.",properties:{action:{enum:["add","change","delete"]},entities:{type:"array",items:{type:"string"}},id:{type:"integer",description:"Required for *change* and *delete* actions."},text:{type:"string",maxLength:2e3,description:"REQUIRED for the *add* and *change* actions. MUST be under 200 words."},tier:{type:"integer",description:"Omit tier for *add* action. Increase tier by one for *change* action, when any number of other facts are merged into this one.",default:1}},propertyOrdering:["action","entities","id","text","tier"],required:["action"],additionalProperties:!1}}},required:["observations","rationale","factsChange"],propertyOrdering:["observations","rationale","factsChange"],additionalProperties:!1},al=async e=>{if(!ee())return console.error("extractInitialFacts: API not configured"),null;const{themeName:t,WorldSheet:n,heroSheet:o,heroBackstory:a}=e,r=Tr(t,"",n,o,a),i=await ie(async()=>{var f,v,y,w;(f=e.onSetLoadingReason)==null||f.call(e,"loremaster_extract"),ae(ne.loremaster_extract.icon);const s=Se(512),c=tt(512),{response:l,systemInstructionUsed:d,jsonSchemaUsed:u,promptUsed:m}=await oe({modelNames:[z,Q],prompt:r,systemInstruction:Er,thinkingBudget:s,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:kr,temperature:.7,label:"LoremasterExtractInitial",maxOutputTokens:c}),g=(((w=(y=(v=l.candidates)==null?void 0:v[0])==null?void 0:y.content)==null?void 0:w.parts)??[]).filter(h=>h.thought===!0&&typeof h.text=="string").map(h=>h.text);return{result:{parsed:Pr(l.text??""),raw:l.text??"",thoughts:g,systemInstructionUsed:d,jsonSchemaUsed:u,promptUsed:m}}});return i?{facts:i.parsed??[],debugInfo:{extract:{prompt:i.promptUsed,systemInstruction:i.systemInstructionUsed,jsonSchema:i.jsonSchemaUsed,rawResponse:i.raw,parsedPayload:i.parsed??void 0,thoughts:i.thoughts},integrate:null}}:null},rl=async e=>{if(!ee())return console.error("refineLore: API not configured"),null;const{themeName:t,turnContext:n,existingFacts:o,logMessage:a,currentScene:r,WorldSheet:i,heroSheet:s,heroBackstory:c,onFactsExtracted:l}=e,d=Tr(t,n,i,s,c),u=await ie(async()=>{var I,S,M,k;(I=e.onSetLoadingReason)==null||I.call(e,"loremaster_extract"),ae(ne.loremaster_extract.icon);const g=Se(512),{response:f,systemInstructionUsed:v,jsonSchemaUsed:y,promptUsed:w}=await oe({modelNames:[z,Q],prompt:d,systemInstruction:Er,thinkingBudget:g,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:kr,temperature:.7,label:"LoremasterExtract"}),T=(((k=(M=(S=f.candidates)==null?void 0:S[0])==null?void 0:M.content)==null?void 0:k.parts)??[]).filter($=>$.thought===!0&&typeof $.text=="string").map($=>$.text);return{result:{parsed:Pr(f.text??""),raw:f.text??"",thoughts:T,systemInstructionUsed:v,jsonSchemaUsed:y,promptUsed:w}}});if(!u)return null;if(l){const{proceed:g}=await l(u.parsed??[]);if(!g)return{refinementResult:null,debugInfo:{extract:{prompt:u.promptUsed,systemInstruction:u.systemInstructionUsed,jsonSchema:u.jsonSchemaUsed,rawResponse:u.raw,parsedPayload:u.parsed??void 0,thoughts:u.thoughts},integrate:null}}}const m=Zc(t,o,u.parsed??[],a,r),p=await ie(async()=>{var S,M,k,$;(S=e.onSetLoadingReason)==null||S.call(e,"loremaster_integrate"),ae(ne.loremaster_integrate.icon);const g=Se(1024),{response:f,systemInstructionUsed:v,jsonSchemaUsed:y,promptUsed:w}=await oe({modelNames:[z,Q],prompt:m,systemInstruction:aa,thinkingBudget:g,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:ca,temperature:.7,label:"LoremasterIntegrate"}),T=((($=(k=(M=f.candidates)==null?void 0:M[0])==null?void 0:k.content)==null?void 0:$.parts)??[]).filter(L=>L.thought===!0&&typeof L.text=="string").map(L=>L.text),I=Cr(f.text??"",o);return{result:I?{parsed:I,raw:f.text??"",thoughts:T,systemInstructionUsed:v,jsonSchemaUsed:y,promptUsed:w}:null}});return{refinementResult:(p==null?void 0:p.parsed)??null,debugInfo:{extract:{prompt:u.promptUsed,systemInstruction:u.systemInstructionUsed,jsonSchema:u.jsonSchemaUsed,rawResponse:u.raw,parsedPayload:u.parsed??void 0,thoughts:u.thoughts},integrate:{prompt:(p==null?void 0:p.promptUsed)??m,systemInstruction:(p==null?void 0:p.systemInstructionUsed)??aa,jsonSchema:(p==null?void 0:p.jsonSchemaUsed)??ca,rawResponse:p==null?void 0:p.raw,parsedPayload:p==null?void 0:p.parsed,observations:p==null?void 0:p.parsed.observations,rationale:p==null?void 0:p.parsed.rationale,thoughts:p==null?void 0:p.thoughts}}}},Mr=async e=>{if(!ee())return console.error("collectRelevantFacts: API not configured"),null;const{themeName:t,facts:n,lastScene:o,playerAction:a,recentLogEntries:r,detailedContext:i}=e,s=el(t,n,o,a,r,i),c=await ie(async()=>{var v,y,w;ae(ne.loremaster_collect.icon);const l=Se(1024),{response:d,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:p}=await oe({modelNames:[be,z,Q],prompt:s,systemInstruction:ra,thinkingBudget:l,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:ia,temperature:.7,label:"LoremasterCollect"}),f=(((w=(y=(v=d.candidates)==null?void 0:v[0])==null?void 0:y.content)==null?void 0:w.parts)??[]).filter(h=>h.thought===!0&&typeof h.text=="string").map(h=>h.text);return{result:{parsed:ol(d.text??""),raw:d.text??"",thoughts:f,systemInstructionUsed:u,jsonSchemaUsed:m,promptUsed:p}}});return{facts:(c==null?void 0:c.parsed)??[],debugInfo:{prompt:(c==null?void 0:c.promptUsed)??s,systemInstruction:(c==null?void 0:c.systemInstructionUsed)??ra,jsonSchema:(c==null?void 0:c.jsonSchemaUsed)??ia,rawResponse:c==null?void 0:c.raw,parsedPayload:(c==null?void 0:c.parsed)??void 0,thoughts:c==null?void 0:c.thoughts}}},$r=async e=>{if(!ee())return console.error("distillFacts: API not configured"),null;const{themeName:t,facts:n,currentQuest:o,currentObjective:a,inventoryItemNames:r,mapNodeNames:i,recentLogEntries:s}=e,c=tl(t,n,o,a,r,i,s),l=await ie(async()=>{var w,h,T;ae(ne.loremaster_distill.icon);const d=Se(4096),{response:u,systemInstructionUsed:m,jsonSchemaUsed:p,promptUsed:g}=await oe({modelNames:[Ts,Q,z],prompt:c,systemInstruction:sa,thinkingBudget:d,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:la,temperature:.7,label:"LoremasterDistill"}),v=(((T=(h=(w=u.candidates)==null?void 0:w[0])==null?void 0:h.content)==null?void 0:T.parts)??[]).filter(I=>I.thought===!0&&typeof I.text=="string").map(I=>I.text),y=Cr(u.text??"",n);return{result:y?{parsed:y,raw:u.text??"",thoughts:v,systemInstructionUsed:m,jsonSchemaUsed:p,promptUsed:g}:null}});return{refinementResult:(l==null?void 0:l.parsed)??null,debugInfo:{prompt:(l==null?void 0:l.promptUsed)??c,systemInstruction:(l==null?void 0:l.systemInstructionUsed)??sa,jsonSchema:(l==null?void 0:l.jsonSchemaUsed)??la,rawResponse:l==null?void 0:l.raw,parsedPayload:l==null?void 0:l.parsed,observations:l==null?void 0:l.parsed.observations,rationale:l==null?void 0:l.parsed.rationale,thoughts:l==null?void 0:l.thoughts}}},In=e=>{const t=(e??"").trim();return t.length===0?Mn:t},Nn=e=>{if(e==null)return[];const t=Array.isArray(e)?e:[e],n=[];for(const o of t){if(typeof o!="string")continue;const a=o.trim();a.length!==0&&(n.includes(a)||n.push(a))}return n},sl=(e,t,n)=>{const o=[];return e.forEach(a=>{const r={...a,id:Nt(a.name),aliases:a.aliases??[],presenceStatus:a.presenceStatus??"unknown",attitudeTowardPlayer:In(a.attitudeTowardPlayer),knowsPlayerAs:Nn(a.knowsPlayerAs),lastKnownLocation:a.lastKnownLocation??null,preciseLocation:a.preciseLocation??null,dialogueSummaries:[]};o.push({type:"add",npcName:r.name,addedNPC:r})}),t.forEach(a=>{const r=n.find(i=>i.name===a.name);if(r){const i={...r,dialogueSummaries:r.dialogueSummaries??[]};a.newDescription!==void 0&&(i.description=a.newDescription),a.newAliases!==void 0&&(i.aliases=a.newAliases),a.addAlias&&(i.aliases=Array.from(new Set([...i.aliases??[],a.addAlias]))),a.newPresenceStatus!==void 0&&(i.presenceStatus=a.newPresenceStatus),a.newAttitudeTowardPlayer!==void 0&&(i.attitudeTowardPlayer=In(a.newAttitudeTowardPlayer)),a.newKnownPlayerNames!==void 0&&(i.knowsPlayerAs=Nn(a.newKnownPlayerNames)),a.newLastKnownLocation!==void 0&&(i.lastKnownLocation=a.newLastKnownLocation),a.newPreciseLocation!==void 0&&(i.preciseLocation=a.newPreciseLocation),i.presenceStatus==="distant"||i.presenceStatus==="unknown"?i.preciseLocation=null:i.preciseLocation??(i.preciseLocation=i.presenceStatus==="companion"?"with you":"nearby in the scene"),o.push({type:"update",npcName:a.name,oldNPC:{...r},newNPC:i})}}),o},co=(e,t,n)=>{const o=[...n];return e.forEach(a=>{if(!o.some(r=>r.name===a.name)){const r={...a,id:Nt(a.name),aliases:a.aliases??[],presenceStatus:a.presenceStatus??"unknown",attitudeTowardPlayer:In(a.attitudeTowardPlayer),knowsPlayerAs:Nn(a.knowsPlayerAs),lastKnownLocation:a.lastKnownLocation??null,preciseLocation:a.preciseLocation??null,dialogueSummaries:[]};(r.presenceStatus==="distant"||r.presenceStatus==="unknown")&&(r.preciseLocation=null),o.push(r)}}),t.forEach(a=>{const r=o.findIndex(i=>i.name===a.name);if(r!==-1){const i={...o[r],dialogueSummaries:o[r].dialogueSummaries??[]};a.newDescription!==void 0&&(i.description=a.newDescription),a.newAliases!==void 0&&(i.aliases=a.newAliases),a.addAlias&&(i.aliases=Array.from(new Set([...i.aliases??[],a.addAlias]))),a.newPresenceStatus!==void 0&&(i.presenceStatus=a.newPresenceStatus),a.newAttitudeTowardPlayer!==void 0&&(i.attitudeTowardPlayer=In(a.newAttitudeTowardPlayer)),a.newKnownPlayerNames!==void 0&&(i.knowsPlayerAs=Nn(a.newKnownPlayerNames)),a.newLastKnownLocation!==void 0&&(i.lastKnownLocation=a.newLastKnownLocation),a.newPreciseLocation!==void 0&&(i.preciseLocation=a.newPreciseLocation),i.presenceStatus==="distant"||i.presenceStatus==="unknown"?i.preciseLocation=null:i.preciseLocation??(i.preciseLocation=i.presenceStatus==="companion"?"with you":"nearby in the scene"),o[r]=i}}),o},il=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,initiateDialogueExit:i,isDialogueExiting:s,addDebugEntry:c}=e;return{handleDialogueOptionSelect:b.useCallback(async d=>{const u=t();if(!u.dialogueState||s)return;const m=u.theme,p={speaker:"Player",line:d},g=[...u.dialogueState.options],f=[...u.dialogueState.history,p],v=g.length>0&&d===g[g.length-1],y={...u,dialogueState:{...u.dialogueState,history:f,options:[]},lastTurnChanges:null};n(y);const w=y.dialogueState;if(!w){o("The conversation ended unexpectedly. Try selecting an option again."),a(!1),r(null);return}if(v)await i(y);else{a(!0),r("dialogue_turn"),o(null);try{const h=y.mapData.nodes.filter(C=>C.type!=="feature"),T=y.allNPCs,I=y.gameLog.slice(-Io),S=$o(h,T,`${y.currentScene} ${d}`,"Locations mentioned:","NPCs mentioned:"),M=[...y.loreFacts].sort((C,R)=>R.tier-C.tier||R.createdTurn-C.createdTurn).map(C=>({text:C.text,tier:C.tier}));r("loremaster_collect");const k=await Mr({themeName:m.name,facts:M,lastScene:y.currentScene,playerAction:d,recentLogEntries:I,detailedContext:S});r("dialogue_turn");const $=(k==null?void 0:k.facts)??[],{parsed:L,prompt:E,rawResponse:N,thoughts:A}=await zc(m,y.storyArc,y.mainQuest,y.currentObjective,y.currentScene,y.localTime,y.localEnvironment,y.localPlace,h,T,y.inventory.filter(C=>C.holderId===se),y.heroSheet,f,d,w.participants,$);c({prompt:E,rawResponse:N,thoughts:A});const P=t();if(L&&P.dialogueState){const C=[...f,...L.npcResponses],R={participants:L.updatedParticipants??P.dialogueState.participants,history:C,options:L.playerOptions};L.dialogueEnds&&(R.options=[]);let _=P.allNPCs;const W=new Set([...P.dialogueState.participants,...L.updatedParticipants??P.dialogueState.participants]),x=new Set(P.allNPCs.map(X=>X.name)),ce=(L.npcAttitudeUpdates??[]).filter(X=>W.has(X.name)&&x.has(X.name)),ge=(L.npcKnownNameUpdates??[]).filter(X=>W.has(X.name)&&x.has(X.name));if(ce.length>0){const X=ce.map(({name:pe,newAttitudeTowardPlayer:me})=>({name:pe,newAttitudeTowardPlayer:me}));_=co([],X,P.allNPCs)}if(ge.length>0){const X=[];ge.forEach(pe=>{const me=_.find(D=>D.name===pe.name);if(me){if(pe.newKnownPlayerNames!==void 0)X.push({name:pe.name,newKnownPlayerNames:pe.newKnownPlayerNames});else if(pe.addKnownPlayerName){const D=me.knowsPlayerAs,j=pe.addKnownPlayerName.trim();if(j.length===0)return;const J=new Set(D);J.add(j),X.push({name:pe.name,newKnownPlayerNames:Array.from(J)})}}}),X.length>0&&(_=co([],X,_))}const ue={...P,dialogueState:R,allNPCs:_,lastTurnChanges:null};n(ue),L.dialogueEnds&&await i(ue)}else if(P.dialogueState){o("The conversation faltered. Try choosing an option again or ending the dialogue.");const C={...P.dialogueState};C.options.length===0&&(C.options=g.length>0?g:["End Conversation."]),n({...P,dialogueState:C,lastTurnChanges:null})}}catch(h){console.error("Error during dialogue turn:",h),o("An error occurred in the conversation. You might need to end it.");const T=t();if(T.dialogueState){const I=g.length>0?g:["Try to end the conversation."];n({...T,dialogueState:{...T.dialogueState,options:I},lastTurnChanges:null})}}finally{const h=t(),{dialogueState:T}=h;T!=null&&T.options.length===0&&T.history.length>0||s||(a(!1),r(null))}}},[t,n,s,o,a,r,i,c])}},cl=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:i,getDialogueDebugLogs:s,clearDialogueDebugLogs:c}=e,[l,d]=b.useState(!1),u=b.useCallback(async p=>{const{dialogueState:g}=p;if(!g){console.error("Cannot exit dialogue: no dialogue state available.",p),await i(null,p,{turns:s()}),c(),d(!1),a(!1),r(null);return}a(!0),d(!0),o(null);const f=Z(p),v=g.history,y=g.participants;f.turnState="dialogue_memory",n(f),r("dialogue_memory");const w={themeName:f.theme.name,theme:f.theme,currentScene:f.currentScene,localTime:f.localTime,localEnvironment:f.localEnvironment,localPlace:f.localPlace,dialogueParticipants:y,dialogueLog:v,heroShortName:f.heroSheet.heroShortName||"Player"},T={summaryText:await Xc(w)??"A conversation took place, but the details are hazy.",participants:y,timestamp:f.localTime,location:f.localPlace};f.allNPCs=f.allNPCs.map(N=>{if(g.participants.includes(N.name)){const A=[...N.dialogueSummaries??[],T];return A.length>Ps&&A.shift(),{...N,dialogueSummaries:A}}return N}),r("dialogue_summary");const I=Ke(f.storyArc)?f.storyArc.acts[f.storyArc.currentAct-1]:null,S={mainQuest:(I==null?void 0:I.mainObjective)??null,currentObjective:f.currentObjective,currentScene:f.currentScene,localTime:f.localTime,localEnvironment:f.localEnvironment,localPlace:f.localPlace,mapDataSnapshot:f.mapData,knownNPCs:f.allNPCs,inventory:f.inventory.filter(N=>N.holderId===se),dialogueLog:v,dialogueParticipants:y,heroSheet:f.heroSheet,themeName:f.theme.name,theme:f.theme,storyArc:f.storyArc},{parsed:M,prompt:k,rawResponse:$,thoughts:L}=await Qc(S);f.dialogueState=null;const E={turns:s(),summaryPrompt:k,summaryRawResponse:$,summaryThoughts:L};await i(M,f,E),c(),d(!1)},[o,a,r,i,s,c,n]),m=b.useCallback(()=>{const p=t();if(p.dialogueState&&!l){const g={speaker:"Player",line:"(Forces the conversation to end)"},f=[...p.dialogueState.history,g],v={...p,dialogueState:{...p.dialogueState,history:f,options:[]},lastTurnChanges:null};n(v),u(v)}},[t,n,l,u]);return{isDialogueExiting:l,initiateDialogueExit:u,handleForceExitDialogue:m}},ll=e=>{const{getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:i}=e,s=b.useRef([]),c=f=>{s.current.push(f)},l=()=>s.current,d=()=>{s.current=[]},{isDialogueExiting:u,initiateDialogueExit:m,handleForceExitDialogue:p}=cl({getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,onDialogueConcluded:i,getDialogueDebugLogs:l,clearDialogueDebugLogs:d}),{handleDialogueOptionSelect:g}=il({getCurrentGameState:t,commitGameState:n,setError:o,setIsLoading:a,setLoadingReason:r,initiateDialogueExit:m,isDialogueExiting:u,addDebugEntry:c});return{isDialogueExiting:u,handleDialogueOptionSelect:g,handleForceExitDialogue:p}},da=`<ID: {id}> - "{name}" (Type: "{type}"{tagswithdescription}, Description: "{currentdescription}"{activehint}){availableactions};
`,dl=(e,t,n,o,a)=>{const r=Lo(n),i=Rn(o,!0),s=gr(a),c=Do(t);return`# Storyteller: New Adventure Setup

Start a new adventure in the theme "${e.name}". ${e.storyGuidance}

## Narrative Arc:
${c}

## World Details:
${r}

## Player Character Description:
${i}

## Player Character Backstory:
${s}

### NPC Seeding Requirements:
- Carefully examine the narrative arc, world details, and backstory. Identify **every** named individual other than the protagonist.
- For each named NPC, add a detailed entry to "npcsAdded" with attitudeTowardPlayer, presenceStatus, lastKnownLocation, preciseLocation (if nearby), and the name(s) they know protagonist by.
- Do not omit or rename any referenced character. If a figure is clearly named or title-referenced, include them. If only referenced by title or occupation - creatively invent their name.

Creatively generate the main quest, current objective, scene description, action options, and starting items using the world details and hero history for inspiration.
Creatively add any important quest item(s), if any, based on your generated quest and objective.

ALWAYS SET "mapUpdated": true.
ALWAYS REQUIRED: "mainQuest", "currentObjective", "localTime", "localEnvironment", and "localPlace".
`},ul=(e,t,n,o,a,r,i,s,c,l,d,u,m,p,g,f,v,y,w,h,T)=>{const I=n.filter(re=>re.holderId===se),S=Ue(I,da,`### Player's Inventory:
`,`
`),M=o?n.filter(re=>re.holderId===o):[],k=Ue(M,da,`### Items at Current Location:
`,`
`),$=It(c,!0),L=[],E=[],N=[];for(const re of l)switch(re.presenceStatus){case"companion":L.push(re);break;case"nearby":E.push(re);break;case"distant":case"unknown":N.push(re);break}const A=Ze(L,`<ID: {id}> - {name} — {description} (preciseLocation: {preciseLocation}, attitude: {attitudeTowardPlayer}, knows Player as {knowsPlayerAs})
`,`### Companions traveling with the Player:
`),P=Ze(E,`<ID: {id}> - {name} — {description} (preciseLocation: {preciseLocation}, attitude: {attitudeTowardPlayer}, knows Player as {knowsPlayerAs})
`,`### NPCs Player can interact with (nearby):
`),C=Ze(N,`<ID: {id}> - {name} — {description} (lastKnownLocation: {lastKnownLocation})
`,`### Other Known NPCs:
`),R=d.length>0?d.map(re=>`- ${re}`).join(`
`):"",_=mr(s),W=Do(h),x=wi(y,(v==null?void 0:v.id)??null),ce=Ic(y,(v==null?void 0:v.id)??null,w),ge=(()=>{var Le;if(ce)return ce;if(!w)return"";const re=new Map(y.nodes.map(Qe=>[Qe.id,Qe])),Ie=re.get(w),Ce=(Ie==null?void 0:Ie.placeName)??w,Pe=Ie==null?void 0:Ie.parentNodeId,_e=Pe&&Pe!==K?((Le=re.get(Pe))==null?void 0:Le.placeName)??Pe:null;return`Player wants to reach ${_e?`${Ce} in ${_e}`:Ce}, but does not know how to get there.`})(),ue=$o(c,l,`${e} ${t}`,"### Details on relevant locations mentioned in current scene or action:","### Details on relevant NPCs mentioned in current scene or action:"),X=Lo(g),pe=Rn(f,!1),me=T?`### DEBUG TOOL DIRECTIVE (Developer Override):
${T}`:"",D=`## Narrative Arc:
${W}`,j=x?`### Current Map Context (including your location, possible exits, nearby paths, and other nearby locations):
${x}`:"",J=ue||"",ve=R?`### Relevant Facts at present moment:
${R}`:"",U=_?`### Recent Events to keep in mind (for context and continuity):
${_}
 - A bit later you look around and consider your next move.
IMPORTANT: Recent events are provided only for additional context. These actions have already been processed by the game and should NEVER trigger item actions again, to avoid double counting.`:"",O=[`### World Details:
${X}`,`### Player Character Description:
${pe}`,S||null,k||null,`### Known Locations:
${$}`,A||null,P||null,C||null,j||null,J||null,ve||null,U||null].filter(re=>!!re).join(`

`),V=[`Previous Local Time: ${u??"Unknown"}`,`Previous Local Environment: ${m??"Undetermined"}`,`Previous Local Place: ${p??"Undetermined Location"}`,`Main Quest: ${a??"Not set"}`],q=(r==null?void 0:r.trim())??"";q.length>0&&V.push(`Current Objective: ${q}`);const Y=V.join(`
`),fe=(me?[me,D]:[D]).join(`

`),ye=ge?`
${ge}`:"";return`# Storyteller: Main Game Turn

Based on the Previous Scene and Player Action, and taking into account the provided narrative arc guidance and context, generate the next scene description, options, item changes, log message, etc.
${fe?`${fe}

`:""}## Context that may or may not be relevant for this specific turn:
${Y}

${O}

---

## Previous Scene:
${e}

## Player Actions:
${t}${ye}`};function pl(e){const t=Z(e);return t.inventory=t.inventory.map(n=>n.lastInspectTurn!==void 0&&n.lastInspectTurn>=t.globalTurnNumber?{...n,lastInspectTurn:void 0}:n),t.lastJournalInspectTurn>=t.globalTurnNumber&&(t.lastJournalInspectTurn=0),t}const ml={type:"object",properties:{geography:{type:"string",minLength:200,maxLength:400},climate:{type:"string",minLength:100,maxLength:200},technologyLevel:{type:"string",minLength:100,maxLength:200},supernaturalElements:{type:"string",minLength:100,maxLength:200},majorFactions:{type:"array",items:{type:"string"},description:"Names of the factions and their brief description"},keyResources:{type:"array",items:{type:"string"}},culturalNotes:{type:"array",items:{type:"string"}},notableLocations:{type:"array",items:{type:"string"},description:"Notable geographic locations and their brief description"}},required:["geography","climate","technologyLevel","supernaturalElements","majorFactions","keyResources","culturalNotes","notableLocations"],additionalProperties:!1},gl={type:"object",properties:{name:{type:"string"},heroShortName:{type:"string",description:"Single-word name for UI; only alphanumeric and hyphen."},occupation:{type:"string"},traits:{type:"array",items:{type:"string"}},startingItems:{type:"array",items:{type:"string"}}},required:["name","heroShortName","occupation","traits","startingItems"],additionalProperties:!1},Lr={type:"object",properties:{title:{type:"string",description:"Creative title for the act."},description:{type:"string",minLength:500,maxLength:1e3},mainObjective:{type:"string",description:"Main objective that must be achieved in order to complete the act."},sideObjectives:{type:"array",items:{type:"string"}},successCondition:{type:"string",description:"Actionable, clearly defined condition for finishing the act and moving forvard into the next act."}},required:["title","description","mainObjective","sideObjectives","successCondition"],additionalProperties:!1},fl={type:"object",properties:{title:{type:"string",description:"Creative title for the whole storyline."},overview:{type:"string",description:"High level story overview, like a book series synopsis, without going into specifics of the story, and not describing specific acts.",minLength:500,maxLength:1e3},acts:{type:"array",minItems:1,maxItems:1,items:Lr}},required:["title","overview","acts"],additionalProperties:!1},hl={type:"object",description:"Narrative description of what was happening to the player character in each of the time periods up until present moment.",properties:{fiveYearsAgo:{type:"string",minLength:100,maxLength:500,description:"Narrative story from 5 years ago."},oneYearAgo:{type:"string",minLength:100,maxLength:500,description:"Narrative story from one year ago."},sixMonthsAgo:{type:"string",minLength:100,maxLength:500,description:"Narrative story from 6 months ago."},oneMonthAgo:{type:"string",minLength:100,maxLength:500,description:"Narrative story from one month ago."},oneWeekAgo:{type:"string",minLength:100,maxLength:500,description:"Narrative story from last week."},yesterday:{type:"string",minLength:100,maxLength:500,description:"Narrative story from yesterday."},now:{type:"string",minLength:100,maxLength:500,description:"Narrative story leading to the present moment."},storyArc:fl},required:["fiveYearsAgo","oneYearAgo","sixMonthsAgo","oneMonthAgo","oneWeekAgo","yesterday","now","storyArc"],additionalProperties:!1},yl=async e=>{if(!ee())return console.error("generateWorldSheet: API key not configured."),null;const t=`Using the theme description "${e.storyGuidance}", expand it into a world profile.`,n=async()=>{const o=Se(1024),a=tt(1024),{response:r}=await oe({modelNames:[z,Q],prompt:t,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:o,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:ml,label:"WorldSheet",maxOutputTokens:a});return r.text??null};return ie(async()=>{ae(ne.initial_load.icon);const o=await n();return{result:o?he(o):null}})},wl=async(e,t,n)=>{if(!ee())return console.error("generateCharacterNames: API key not configured."),null;const o=`Using this world description:
    ${JSON.stringify(n)}
    Generate 50 strictly ${t} full names with occasional optional nicknames appropriate for the theme "${e.name}".
    Allowed templates: 'FirstName LastName', 'FirstName "Nickname" LastName', or 'Prefix FirstName LastName'.
    UNIQUENESS REQUIREMENTS (very important):
    - Each FirstName must be unique across the entire list (no repeats or trivial variants).
    - Each LastName must be unique across the entire list (no repeats or trivial variants).
    - Each Nickname (if present) must be unique across the entire list.
    - Avoid minor spelling variants or simple diacritic tweaks; use genuinely different names.
    - Aim for diverse cultural origins to maximize variety.
    Respond ONLY with a JSON array of 50 distinct strings.`,a=async()=>{const r=Se(1024),i=tt(1024),{response:s}=await oe({modelNames:[z,Q],prompt:o,systemInstruction:"Respond with a JSON array of strings.",thinkingBudget:r,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:{type:"array",minItems:50,items:{type:"string"}},label:"HeroNames",maxOutputTokens:i});return s.text??null};return ie(async()=>{ae(ne.initial_load.icon);const r=await a();return{result:r?he(r):null}})},vl=async(e,t,n,o)=>{if(!ee())return console.error("generateCharacterDescriptions: API key not configured."),null;const a=`Using this world description:
    ${JSON.stringify(n)}
    Provide a short adventurous description for each of these potential ${t} player characters appropriate for the theme "${e.name}":
    ${o.join(`
`)}`,r=async()=>{const i=Se(1024),s=tt(4096),{response:c}=await oe({modelNames:[z,Q],prompt:a,systemInstruction:"Respond with a JSON array matching the provided names with their descriptions.",thinkingBudget:i,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:{type:"array",items:{type:"object",properties:{name:{type:"string"},description:{type:"string",minLength:100,maxLength:300}},required:["name","description"],additionalProperties:!1}},label:"HeroDescriptions",maxOutputTokens:s});return c.text??null};return ie(async()=>{ae(ne.initial_load.icon);const i=await r();return{result:i?he(i):null}})},wp=async(e,t,n,o,a)=>{if(!ee())return console.error("generateHeroData: API key not configured."),null;const r=`Using the theme "${e.name}" and these world details:
${JSON.stringify(n)}
The player's character gender is ${t}.${o?` Their name is ${o}.`:""}${a?` Here is a short description of the hero: ${a}.`:""}
Create a brief character sheet including occupation, notable traits, and starting items.
Also include "heroShortName": a single-word short name used in UI and dialogue, composed only of alphanumeric characters and hyphens (no underscores). Strongly PREFER using the exact FirstName part of the full name for "heroShortName"; choose a different single-word alias only if the FirstName would be ambiguous in this world/context.`,i=async(s,c,l)=>{const d=Se(1024),u=tt(1024),{response:m}=await oe({modelNames:[z,Q],prompt:s,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:d,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:c,label:l,maxOutputTokens:u});return m.text??null};return ie(async()=>{ae(ne.initial_load.icon);const s=await i(r,gl,"HeroSheet"),c=s?he(s):null;if(c){c.gender=t;const f=c.name.split(/\s+/)[0]||"Hero",v=c.heroShortName&&c.heroShortName.trim().length>0?c.heroShortName:f;c.heroShortName=v.replace(/[ _]+/g,"-").replace(/[^a-zA-Z0-9-]/g,"").replace(/-+/g,"-").replace(/^-+|-+$/g,"")||"Hero"}const l=o??(c==null?void 0:c.name)??"the hero",d=`Using these world details:
${JSON.stringify(n)}
and this hero sheet:
${s??""}
${a?`The hero's description is: ${a}.`:""}
Write a short backstory for ${l} using these time markers: 5 years ago, 1 year ago, 6 months ago, 1 month ago, 1 week ago, yesterday, and now.
Then outline a five act narrative arc for this adventure with a creative overview.
Provide details only for Act 1 (exposition) including a creative description, the main objective, 2-4 side quests, and the success condition to proceed to the next act (rising action).`,u=await i(d,hl,"HeroBackstory"),m=u?he(u):null;let p=null,g=null;if(m){const{storyArc:f,...v}=m;p={title:f.title,overview:f.overview,acts:f.acts.map((y,w)=>({...y,actNumber:w+1,completed:!1})),currentAct:1},g=v}if(p&&!Ke(p))throw new Error("generateHeroData: invalid story arc");return{result:{heroSheet:c??null,heroBackstory:g,storyArc:p}}})},Il=async(e,t,n,o,a,r)=>{if(!ee())return console.error("generateNextStoryAct: API key not configured."),null;const i=o.currentAct+1,s=Cs[i];if(!s)return null;const c=o.acts.filter(p=>p.actNumber<=o.currentAct).map(p=>`Act ${String(p.actNumber)}: ${p.description}`).join(`
`),l=a.slice(-Io).join(`
`),d=i===5?" This is the final act of the game. Provide a successCondition that clearly ends the entire story.":"",u=`Using the theme "${e.name}" continue the narrative.

World Facts:
${JSON.stringify(t)}

Player Character:
${JSON.stringify(n)}

Story Arc Title: ${o.title}
Overview: ${o.overview}

Completed Acts:
${c}

Last Scene:
${r}

Recent Log:
${l}

Generate full details for Act ${String(i)} (${s}).${d}`,m=async()=>{const p=Se(1024),g=tt(1024),{response:f}=await oe({modelNames:[z,Q],prompt:u,systemInstruction:"Respond only with JSON matching the provided schema.",thinkingBudget:p,includeThoughts:!1,responseMimeType:"application/json",jsonSchema:Lr,label:"NextAct",maxOutputTokens:g});return f.text??null};return ie(async()=>{ae(ne.storyteller.icon);const p=await m(),g=p?he(p):null;return g?{result:{actNumber:i,title:g.title,description:g.description,mainObjective:g.mainObjective,sideObjectives:g.sideObjectives,successCondition:g.successCondition,completed:!1}}:{result:null}})},Dr=e=>{const t=e.id??vr(e.name),n=e.holderId.trim()===""?se:e.holderId;return{...e,id:t,holderId:n,activeDescription:e.activeDescription??void 0,isActive:e.isActive??!1,knownUses:e.knownUses??[],tags:e.tags??[]}},Rr=(e,t)=>{const n={...e};return t.type!==void 0&&(n.type=t.type),t.description!==void 0&&(n.description=t.description),t.activeDescription!==void 0&&(t.activeDescription===null?n.activeDescription=void 0:n.activeDescription=t.activeDescription),t.isActive!==void 0&&(n.isActive=t.isActive),t.activeDescription===null&&(n.isActive=!1),t.tags!==void 0&&(n.tags=t.tags),t.chapters!==void 0&&(n.chapters=t.chapters),t.knownUses!==void 0&&(n.knownUses=t.knownUses),t.holderId!==void 0&&t.holderId.trim()!==""&&(n.holderId=t.holderId),n},Nl=(e,t)=>{let n=[...e];switch(t.action){case"create":{const o=Dr(t.item),a=n.findIndex(r=>r.id===o.id);a!==-1?n[a]=o:n.push(o);break}case"destroy":{const o=t.item,a=Fe([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;r&&(n=n.filter(i=>i.id!==r.id));break}case"move":{const o=t.item,a=Fe([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const i=n.findIndex(s=>s.id===r.id);n[i]={...r,holderId:o.newHolderId}}break}case"change":{const o=t.item,a=Fe([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const i=n.findIndex(d=>d.id===r.id),s=o.newName===void 0&&o.name!==void 0&&o.name!==r.name,c=o.newName??(s?o.name:void 0),l=Rr(r,o);c&&c.trim()!==""&&c!==r.name&&(l.name=c),n[i]=l}break}case"addDetails":{const o=t.item,a=Fe([o.id,o.name],n,!1,!0),r=Array.isArray(a)?null:a;if(r){const i=n.findIndex(c=>c.id===r.id),s={...r};if(o.chapters&&o.chapters.length>0&&(s.chapters=[...r.chapters??[],...o.chapters]),o.tags&&o.tags.length>0){const c=new Set(r.tags??[]);for(const l of o.tags)c.add(l);s.tags=Array.from(c)}if(o.knownUses&&o.knownUses.length>0){const c=[...r.knownUses??[]];for(const l of o.knownUses){const d=c.findIndex(u=>u.actionName===l.actionName);d!==-1?c[d]=l:c.push(l)}s.knownUses=c}s.lastInspectTurn=void 0,n[i]=s}break}}return n},bl=(e,t)=>{const n=[];for(const o of e){let a=null;if(o.action==="create")a={type:"acquire",acquiredItem:{...Dr(o.item)}};else if(o.action==="destroy"){const r=o.item,i=Fe([r.id,r.name],t,!1,!0),s=Array.isArray(i)?null:i;s&&(a={type:"loss",lostItem:{...s}})}else if(o.action==="move"){const r=o.item,i=Fe([r.id,r.name],t,!1,!0),s=Array.isArray(i)?null:i;if(s){const c={...s},l={...s,holderId:r.newHolderId};a={type:"update",oldItem:c,newItem:l}}}else if(o.action==="change"){const r=o.item,i=Fe([r.id,r.name],t,!1,!0),s=Array.isArray(i)?null:i;if(s){const c={...s},l=r.newName===void 0&&r.name!==void 0&&r.name!==s.name,d=r.newName??(l?r.name:void 0),u=Rr(s,r);d&&d.trim()!==""&&d!==s.name&&(u.name=d),a={type:"update",oldItem:c,newItem:u}}}else{const r=o.item,i=Fe([r.id,r.name],t,!1,!0),s=Array.isArray(i)?null:i;if(s){const c={...s};let l={...s};if(r.chapters&&r.chapters.length>0&&(l={...l,chapters:[...s.chapters??[],...r.chapters]}),r.tags&&r.tags.length>0){const d=new Set(s.tags??[]);for(const u of r.tags)d.add(u);l.tags=Array.from(d)}if(r.knownUses&&r.knownUses.length>0){const d=[...s.knownUses??[]];for(const u of r.knownUses){const m=d.findIndex(p=>p.actionName===u.actionName);m!==-1?d[m]=u:d.push(u)}l.knownUses=d}a={type:"update",oldItem:c,newItem:l}}}a&&n.push(a)}return n},Al=(e,t)=>{let n=[...t];for(const o of e)n=Nl(n,o);return n},lo=(e,t,n)=>{const o=[...e,t];return o.length>n?o.slice(o.length-n):o},Sl=(e,t)=>{const n=`You left your ${t}`;for(let o=e.length-1;o>=0;o-=1)if(e[o].startsWith(n))return[...e.slice(0,o),...e.slice(o+1)];return e},xn=(e,t,n)=>{let o=e.loreFacts.length>0?Math.max(...e.loreFacts.map(a=>a.id))+1:1;for(const a of t)switch(a.action){case"add":if(a.text){const r={id:o++,text:a.text,entities:a.entities??[],createdTurn:a.createdTurn??n,tier:a.tier??1};e.loreFacts.push(r)}break;case"change":{const r=e.loreFacts.findIndex(i=>i.id===a.id);if(r>=0){const i={...e.loreFacts[r],text:a.text??e.loreFacts[r].text,entities:a.entities??e.loreFacts[r].entities,tier:a.tier??e.loreFacts[r].tier};e.loreFacts[r]=i}break}case"delete":{const r=e.loreFacts.findIndex(i=>i.id===a.id);r>=0&&e.loreFacts.splice(r,1);break}}},Tl=(e,t)=>{e.length===0||Object.keys(t).length===0||e.forEach(n=>{n.entities=n.entities.map(o=>t[o]??o)})},Pl=`You are an AI assistant specializing in updating a game map based on narrative events.
Your task is to analyze the provided game context and determine what changes should be made to the map data.
You may receive a "Map Hint" string from the storyteller describing distant quest locations, their surroundings, and how to reach them. Use these hints to ensure those locations exist on the map, adding them and their nearby context nodes if necessary.

Fill the JSON object with nodes and edges to add, update, or remove based on the provided context.
Assign relevant node and edge types, statuses, and descriptions.
Ensure that the hierarchy of nodes is logical and consistent, with no feature nodes as parents of other feature nodes.

${za}
${Qa}
${Xa}

CRITICAL INSTRUCTIONS:
- All nodes MUST represent physical locations. NEVER add small items and NPCs to the map!!! Nodes represent spaces the player can occupy: regions, general locations, settlements, building exteriors or interiors, rooms, and notable landscape or architectural features. Feature-type nodes represent sub-spaces within larger spaces. NEVER create nodes that represent inventory items.
- IMPORTANT: Large multi-crew vehicles (e.g., ships, airships, spaceships, trains) can be represented as nodes if they are significant locations in the narrative. They should have a "type" of "exterior" and MUST have sub-nodes for their interior spaces. When creating a node for a large vehicle, ensure it has a "description" that indicates its size and purpose, and that it contains a significant number of constituent nodes required for the large vehicle operation (e.g. main deck, engine room, captain's quarters, cargo hold, bridge, observation deck, reactor room, life support, etc.). At least one of the feature nodes must be clearly defined as a connection point to the outer world (e.g., "Docking Bay", "Hangar", "Airlock", "Gang Plank" etc.).
- When considering a new location, check existing item and NPC names (including aliases). If the name matches or closely resembles one, SKIP adding that node and omit any edges that would connect to it.
- Node Fields for "nodesToAdd":
    - "aliases", "description", and "status" are ALWAYS REQUIRED for ALL added nodes.
    - You MUST provide "parentNodeId" of a node higher in the hierarchy for every node. Top level nodes should be assigned '${K}' as their parentNodeId.
- Node Fields for "nodesToUpdate":
    - "aliases" and "description" can be optionally provided to update ANY node.
    - When adding a new main location via "nodesToAdd", the "placeName" MUST correspond to a location name that the Storyteller AI has indicated as significant.
    - You MUST include "parentNodeId" of a node higher in the hierarchy for every node.
- Node "placeName" (both for identifying nodes and for new names) should be unique within their theme. NEVER create duplicates of existing nodes or edges.
- NEVER add a node named "${K}" or create edges that reference a place named "${K}". That name is reserved for the root and already exists.
- Edges only allowed to connect nodes of type='feature' that have the same parent (siblings), that have the same grandparent (grandchildren), or where one feature's parent is the grandparent of the other (child-grandchild), or edges of type='shortcut'.
- Edges of type 'shortcut' are exempt from these hierarchy restrictions but still must connect feature nodes.
- When you add intermediate feature nodes to satisfy hierarchy rules, ALWAYS assign to them the same status as their parent node. Any edges created to replace a prior connection should keep that connection's status unless explicitly updated.
- If the narrative suggests that a generic feature node (e.g., "Dark Alcove") has become more specific (e.g., "Shrine of Eldras"), UPDATE the existing feature node's "placeName" (if name changed via newPlaceName) and "details" via "nodesToUpdate", rather than adding a new node.
- If any new specific places (feature nodes) within or between main locations are described, add them and specify their parent via 'parentNodeId'.
- Try to assign a definitive parent node to any orphan nodes (Parent node: N/A).
- Try to fix any illogical inconsistencies in the hierarchy, such as a feature node that has no parent, illogical child-parent relationships, or wrong level of hierarchy.
- If connections (paths, doors, etc.) are revealed or changed, update edges.
- If new details are revealed about a location (main or feature), update description and/or aliases.
- If the Player's new 'localPlace' tells that they are at a specific feature node (existing or newly added), suggest it in 'suggestedCurrentMapNodeId'.
- When renaming a node using "nodesToUpdate" (via the "newPlaceName" field), omit any matching entry in "nodesToRemove" for that node.
- Feature Nodes can have any number of edges.
- CRITICALLY IMPORTANT: Delete Nodes ONLY in EXTREME CASES when the Scene unambiguously implies that they will no longer ever be relevant to the Player.
- CRITICALLY IMPORTANT: Delete Edges ONLY in EXTREME CASES when the Scene description mentions an absolutely certain destruction of a path. In all other cases, avoid deleting edges and nodes.
`,Cl=`You are an AI assistant helping to locate the Player on an existing game map.
Your primary goal is to review the provided context and select the single most plausible *accessible* map node ID that represents where the Player is now.

Rules:
- You are given a list of accessible nodes (status = "discovered" or "quest_target"). Start by trying to match the Player to one of those nodes.
- Prefer a specific sub-location (feature/room/interior) when the context clearly implies it; otherwise choose the closest higher-level location that fits.
- Use the change in the player's local position (localPlace: from → to), the log message, and the current scene to infer movement.
- If the best choice is the same as before, pick that node.
- If NO accessible node fits, you must propose exactly one new node and edge to add. The new node must:
  * Include complete fields (placeName, description ≥30 chars, aliases, status, type, parentNodeId).
  * Use status "discovered" unless the narrative explicitly marks it as a quest target.
  * Reference an existing parent from the provided information (never invent a brand new parent hierarchy).
- Response MUST be a JSON object with:
  * "suggestedCurrentMapNodeId": string (existing node ID, or the placeName of the newly added node when adding one).
  * Optional "nodeAndEdge" containing 'edgeToAdd' and 'nodeToAdd' objects for adding a new node and edge.
`,El=["discovered","quest_target"],kl=(e,t,n,o,a,r,i,s,c,l)=>`## Narrative Context for Map Update:
  - Current Theme: "${a.name}";
  - Theme Guidance: "${a.storyGuidance}";
  - Scene Description: "${e}";
  - Log Message (outcome of last action): "${t}";
  - Player's Current Location Description (localPlace): "${n}".

## Map Context:
  - All Known Main Locations: ${s};
  - Player's Previous Location was: ${r};
  - Map Hint from Storyteller: "${o}".
  - Item Names to avoid as nodes: ${c.length>0?c.map(d=>`"${d}"`).join(", "):"None"};
  - NPC Names to avoid as nodes: ${l.length>0?l.map(d=>`"${d}"`).join(", "):"None"}.

${i}
---
Based on the Narrative Context and existing map context, provide a JSON response strongly adhering to the System Instructions.

`,Ml=(e,t,n)=>{const o=t.nodes.filter(d=>El.includes(d.status)),a=o.length>0?o.map(d=>`<ID: ${d.id}> - name: "${d.placeName}"; type: ${d.type}; description: ${d.description}`).join(`
`):"None (no accessible nodes discovered yet).",r=(n.logMessage??"").trim()||"None",i=n.currentScene.trim()||"Unknown",s=n.previousLocalPlace??"Unknown",c=n.currentLocalPlace??"Unknown",l=n.previousMapNodeName??"Unknown or N/A";return`## Goal
Pick the single best accessible node that matches the Player's current position. If none fits, define one new node and edge to add to the map.

## Theme
- Name: "${e.name}"

## Player Context
- Log Message: ${r}
- Current Scene: "${i}"
- Previous Map Node: ${l}
- localPlace change: "${s}" → "${c}"

## Accessible Nodes (existing map only)
${a}

Respond ONLY with JSON.
- When an existing node works: { "suggestedCurrentMapNodeId": "<existing id>" }
- When a new node is required:
{ 
  "nodeAndEdge": { 
    "edgeToAdd": { "description": "...", sourcePlaceName": "<existing id or name>", "status": "discovered", "targetPlaceName": "<new placeName>", "travelTime": "<optional>", "type": "<edge type>" },
    "nodeToAdd": { "aliases": ["..."], "description": "...", "parentNodeId": "<existing id or name>", "placeName": "...", "status": "discovered", "type": "<type>"}
  },
  "suggestedCurrentMapNodeId": "<new placeName>"
}`},Or=async(e,t)=>{const n="Map update response must include valid nodes/edges formatted according to the documented schema.",o=he(e);try{if(o===null)throw new Error("JSON parse failed");let a=null;if(Array.isArray(o))a=o.reduce((s,c)=>{if(c&&typeof c=="object"){const l=c,d=l.nodeAndEdge;if(d&&typeof d=="object"){const u=d;u.edgeToAdd&&typeof u.edgeToAdd=="object"&&(s.edgesToAdd=[...s.edgesToAdd??[],u.edgeToAdd]),u.nodeToAdd&&typeof u.nodeToAdd=="object"&&(s.nodesToAdd=[...s.nodesToAdd??[],u.nodeToAdd])}Array.isArray(l.nodesToAdd)&&(s.nodesToAdd=[...s.nodesToAdd??[],...l.nodesToAdd]),Array.isArray(l.nodesToUpdate)&&(s.nodesToUpdate=[...s.nodesToUpdate??[],...l.nodesToUpdate]),Array.isArray(l.nodesToRemove)&&(s.nodesToRemove=[...s.nodesToRemove??[],...l.nodesToRemove]),Array.isArray(l.edgesToAdd)&&(s.edgesToAdd=[...s.edgesToAdd??[],...l.edgesToAdd]),Array.isArray(l.edgesToUpdate)&&(s.edgesToUpdate=[...s.edgesToUpdate??[],...l.edgesToUpdate]),Array.isArray(l.edgesToRemove)&&(s.edgesToRemove=[...s.edgesToRemove??[],...l.edgesToRemove]),l.suggestedCurrentMapNodeId&&!s.suggestedCurrentMapNodeId&&(s.suggestedCurrentMapNodeId=l.suggestedCurrentMapNodeId),l.observations&&!s.observations&&(s.observations=l.observations),l.rationale&&!s.rationale&&(s.rationale=l.rationale)}return s},{});else if(o&&typeof o=="object"){const s=o;if(s.nodeAndEdge&&typeof s.nodeAndEdge=="object"){const c=s.nodeAndEdge,l={};s.suggestedCurrentMapNodeId&&typeof s.suggestedCurrentMapNodeId=="string"&&(l.suggestedCurrentMapNodeId=s.suggestedCurrentMapNodeId),c.nodeToAdd&&typeof c.nodeToAdd=="object"&&(l.nodesToAdd=[c.nodeToAdd]),c.edgeToAdd&&typeof c.edgeToAdd=="object"&&(l.edgesToAdd=[c.edgeToAdd]),a=l}else a=o}if(a&&typeof a=="object"){const s=l=>typeof l=="string"&&l.trim().toLowerCase()===K;Array.isArray(a.nodesToAdd)&&(a.nodesToAdd=a.nodesToAdd.filter(l=>!s(l.placeName))),Array.isArray(a.nodesToUpdate)&&(a.nodesToUpdate=a.nodesToUpdate.filter(l=>!s(l.placeName))),Array.isArray(a.nodesToRemove)&&(a.nodesToRemove=a.nodesToRemove.filter(l=>!s(l.nodeName)));const c=l=>(l??[]).filter(d=>!s(d.sourcePlaceName)&&!s(d.targetPlaceName));Array.isArray(a.edgesToAdd)&&(a.edgesToAdd=c(a.edgesToAdd)),Array.isArray(a.edgesToUpdate)&&(a.edgesToUpdate=c(a.edgesToUpdate)),Array.isArray(a.edgesToRemove),Mo(a)}let r;if(a){const s=[],c=console.warn;console.warn=(...d)=>{s.push(d.map(u=>String(u)).join(" ")),c(...d)};const l=dr(a);if(console.warn=c,l)return{payload:a};r=s.length>0?s.join("; "):n}console.warn("Parsed map update JSON does not match AIMapUpdatePayload structure or is empty:",o);const i=await ea(e,r,t);return i?{payload:i}:{payload:null,validationError:r??n}}catch(a){console.error("Failed to parse map update JSON response from AI:",a),console.debug("Original map update response text:",e);const r=await ea(e,a instanceof Error?a.message:String(a),t);if(r)return{payload:r};const i=a instanceof Error?a.message:String(a);return{payload:null,validationError:i&&i.trim().length>0?i:n}}},$l={type:"object",properties:{observations:{type:"string",minLength:2e3,description:"Contextually relevant observations about the current map state and relationships."},rationale:{type:"string",minLength:1e3,description:"Explanation of the reasons for the changes. Feature nodes can not be parents of other feature nodes."},edgesToAdd:{type:"array",items:{type:"object",properties:{description:{type:"string",description:Ht},sourcePlaceName:{type:"string",description:"Source node ID or placeName. Use placeName when referencing other nodes in this response."},status:{enum:qe,description:`One of ${yn}`},targetPlaceName:{type:"string",description:"Target node ID or placeName. Use placeName when referencing other nodes in this response."},travelTime:{type:"string"},type:{enum:Je,description:`One of ${hn}`}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","status","targetPlaceName","type"],additionalProperties:!1}},edgesToRemove:{type:"array",items:{type:"object",properties:{edgeId:{type:"string"},sourceId:{type:"string"},targetId:{type:"string"}},propertyOrdering:["edgeId","sourceId","targetId"],required:["edgeId"],additionalProperties:!1}},edgesToUpdate:{type:"array",items:{type:"object",properties:{description:{type:"string",description:Ht},sourcePlaceName:{type:"string",description:"Source node ID or placeName. Use placeName when referencing other nodes in this response."},status:{enum:qe,description:`One of ${yn}`},targetPlaceName:{type:"string",description:"Target node ID or placeName. Use placeName when referencing other nodes in this response."},travelTime:{type:"string",description:"Approximate travel time for the route."},type:{enum:Je,description:`One of ${hn}`}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","targetPlaceName"],additionalProperties:!1}},nodesToAdd:{type:"array",items:{type:"object",properties:{aliases:{type:"array",minItems:1,items:{type:"string"},description:Ve},description:{type:"string",minLength:30,description:ut},type:{enum:mt,description:`One of ${gn}`},parentNodeId:{type:"string",description:`Parent Node ID, or "${K}" for top-level nodes. Use placeName when referencing other nodes in this response.`},placeName:{type:"string",description:"Name of the node. Should not contain a comma. For sub-locations this can be a descriptive feature name."},status:{enum:pt,description:`One of ${fn}`}},propertyOrdering:["aliases","description","parentNodeId","placeName","status","type"],required:["aliases","description","parentNodeId","placeName","status","type"],additionalProperties:!1}},nodesToRemove:{type:"array",items:{type:"object",properties:{nodeId:{type:"string"},nodeName:{type:"string"}},propertyOrdering:["nodeId","nodeName"],required:["nodeId"],additionalProperties:!1}},nodesToUpdate:{type:"array",items:{type:"object",properties:{aliases:{type:"array",items:{type:"string"},minItems:1,description:Ve},description:{type:"string",description:ut},newPlaceName:{type:"string",description:"If provided, this will be the new name for the node."},type:{enum:mt,description:`One of ${gn}`},parentNodeId:{type:"string",description:`Parent Node ID, or "${K}" for top-level nodes. Parent can not be a feature node. Use placeName when referencing other nodes in this response.`},placeName:{type:"string",description:"Existing node ID or name to identify it."},status:{enum:pt,description:`One of ${fn}`}},propertyOrdering:["aliases","description","newPlaceName","parentNodeId","placeName","status","type"],required:["placeName"],additionalProperties:!1}},suggestedCurrentMapNodeId:{type:"string",description:"If map updates and the context both imply a new player location, provide its node ID or placeName."}},required:["observations","rationale","edgesToAdd","edgesToRemove","edgesToUpdate","nodesToAdd","nodesToRemove","nodesToUpdate"],propertyOrdering:["observations","rationale","edgesToAdd","edgesToRemove","edgesToUpdate","nodesToAdd","nodesToRemove","nodesToUpdate","suggestedCurrentMapNodeId"],additionalProperties:!1},xr={type:"object",properties:{suggestedCurrentMapNodeId:{type:"string",description:"Existing node id or placeName representing the player's new location."},nodeAndEdge:{type:"object",description:"When no existing node fits, define exactly one new node and edge to add to the map.",properties:{edgeToAdd:{type:"object",properties:{description:{type:"string",description:Ht},sourcePlaceName:{type:"string",description:"Node ID of the existing accessible node. Usually, the previous location of the player character."},status:{enum:qe,description:`One of ${yn}`},targetPlaceName:{type:"string",description:"placeName of the node being added in nodeToAdd."},travelTime:{type:"string"},type:{enum:Je,description:`One of ${hn}`}},propertyOrdering:["description","sourcePlaceName","status","targetPlaceName","travelTime","type"],required:["sourcePlaceName","status","targetPlaceName","type"],additionalProperties:!1},nodeToAdd:{type:"object",properties:{aliases:{type:"array",minItems:1,items:{type:"string"},description:Ve},description:{type:"string",minLength:30,description:ut},type:{enum:mt,description:`One of ${gn}`},parentNodeId:{type:"string",description:"Existing parent node id"},placeName:{type:"string",description:"Name of the new node. Must be unique within the theme and free of commas."},status:{enum:pt,description:`One of ${fn}`}},propertyOrdering:["aliases","description","parentNodeId","placeName","status","type"],required:["aliases","description","parentNodeId","placeName","status","type"],additionalProperties:!1}},propertyOrdering:["edgeToAdd","nodeToAdd"],required:["edgeToAdd","nodeToAdd"],additionalProperties:!1}},propertyOrdering:["nodeAndEdge","suggestedCurrentMapNodeId"],required:["suggestedCurrentMapNodeId"],additionalProperties:!1},Ll=async(e,t)=>{if(!ee())throw console.error("API Key not configured for Map Update Service."),new Error("API Key not configured.");const n=await ie(async()=>{var d,u,m;ae(ne.map_updates.icon);const o=Se(4096),{response:a,systemInstructionUsed:r,jsonSchemaUsed:i,promptUsed:s}=await oe({modelNames:[Q,z,be],prompt:e,systemInstruction:t,thinkingBudget:o,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:$l,temperature:1,label:"Cartographer"}),l=(((m=(u=(d=a.candidates)==null?void 0:d[0])==null?void 0:u.content)==null?void 0:m.parts)??[]).filter(p=>p.thought===!0&&typeof p.text=="string").map(p=>p.text);return{result:{response:a,thoughts:l,systemInstructionUsed:r,jsonSchemaUsed:i,promptUsed:s}}});if(!n)throw new Error("Failed to execute map update request.");return n},Dl=async(e,t)=>{if(!ee())throw console.error("API Key not configured for Map Update Service."),new Error("API Key not configured.");const n=await ie(async()=>{var d,u,m;ae(ne.map_updates.icon);const o=Se(1024),{response:a,systemInstructionUsed:r,jsonSchemaUsed:i,promptUsed:s}=await oe({modelNames:[z,Q,be],prompt:e,systemInstruction:t,thinkingBudget:o,includeThoughts:!0,responseMimeType:"application/json",jsonSchema:xr,temperature:1,label:"Cartographer (Quick)"}),l=(((m=(u=(d=a.candidates)==null?void 0:d[0])==null?void 0:u.content)==null?void 0:m.parts)??[]).filter(p=>p.thought===!0&&typeof p.text=="string").map(p=>p.text);return{result:{response:a,thoughts:l,systemInstructionUsed:r,jsonSchemaUsed:i,promptUsed:s}}});if(!n)throw new Error("Failed to execute navigation-only request.");return n},Rl=e=>{const t=he(e);if(t&&typeof t=="object"&&"suggestedCurrentMapNodeId"in t){const n=t.suggestedCurrentMapNodeId;return typeof n=="string"&&n.trim()!==""?n:null}return null},Ol=async(e,t,n)=>{const{response:o,thoughts:a,systemInstructionUsed:r,jsonSchemaUsed:i,promptUsed:s}=await Dl(e,t),c=o.text??"",l={prompt:s,systemInstruction:r,jsonSchema:i??xr,rawResponse:c,observations:void 0,rationale:void 0,thoughts:a.length>0?a:void 0,connectorChainsDebugInfo:[]},{payload:d,validationError:u}=await Or(c,n);let m=null,p=[],g=[];if(d){const f={};if(typeof d.suggestedCurrentMapNodeId=="string"){const v=d.suggestedCurrentMapNodeId.trim();f.suggestedCurrentMapNodeId=v.length>0?v:void 0}Array.isArray(d.nodesToAdd)&&d.nodesToAdd.length>0&&(f.nodesToAdd=d.nodesToAdd.slice(0,1)),Array.isArray(d.edgesToAdd)&&d.edgesToAdd.length>0&&(f.edgesToAdd=d.edgesToAdd.slice(0,1)),l.parsedPayload=f,m=f.suggestedCurrentMapNodeId??null,p=f.nodesToAdd??[],g=f.edgesToAdd??[],l.validationError=void 0}else m=Rl(c),p=[],g=[],u&&(l.validationError=u);return{suggestedCurrentMapNodeId:m,nodesToAdd:p,edgesToAdd:g,debugInfo:l}},xl=async(e,t,n,o)=>{let a=e;const r={prompt:e,systemInstruction:t,jsonSchema:void 0,observations:void 0,rationale:void 0,minimalModelCalls:n,connectorChainsDebugInfo:[]};let i=null;for(let s=0;s<B;s++)try{console.log(`Map Update Service: Attempt ${String(s+1)}/${String(B)}`),s>0&&r.validationError?a=`${e}
CRITICALLY IMPORTANT: Your previous attempt has triggered an error: ${r.validationError}`:a=e,r.prompt=a;const{response:c,thoughts:l,systemInstructionUsed:d,jsonSchemaUsed:u,promptUsed:m}=await Ll(a,t);r.rawResponse=c.text??"",l.length>0&&(r.thoughts=l),r.systemInstruction=d,r.jsonSchema=u,r.prompt=m;const{payload:p,validationError:g}=await Or(c.text??"",o);if(p){r.observations=p.observations??r.observations,r.rationale=p.rationale??r.rationale,Zi(p),tc(p);const f=Mo(p);if(ec(p),!f.length){i=p,r.parsedPayload=p,r.validationError=void 0;break}r.parsedPayload=p,r.validationError=f.length>0?`Invalid values: ${f.join("; ")}`:"Parsed payload failed structural/value validation."}else r.validationError=g??"Failed to parse AI response into valid JSON map update payload.";s===B-1&&console.error("Map Update Service: Failed to get valid map update payload after all retries.")}catch(c){console.error(`Error in map update request (Attempt ${String(s+1)}/${String(B)}):`,c),r.rawResponse=`Error: ${c instanceof Error?c.message:String(c)}`,r.validationError=`Processing error: ${c instanceof Error?c.message:String(c)}`}return{payload:i,debugInfo:r}},Ul=(e,t)=>{const n=[];let o=t.get(e.parentNodeId??"");for(;o&&(n.push(o),!(!o.parentNodeId||o.parentNodeId===K));)o=t.get(o.parentNodeId);return n},Ur=(e,t,n)=>{let o=e;for(;o!=null&&o.parentNodeId&&o.parentNodeId!==K;){if(o.parentNodeId===t.id)return!0;o=n.get(o.parentNodeId)}return!1},vp=(e,t,n)=>{const o=new Map(e.nodes.map(i=>[i.id,i])),a=o.get(t),r=o.get(n);return!a||!r?!1:Ur(a,r,o)},_r=(e,t)=>{const{adjacency:n}=Dn(e),o=new Map(e.edges.map(r=>[r.id,r])),a=["open","accessible","active"];return(n.get(t)??[]).filter(r=>{const i=o.get(r.edgeId);return i?a.includes(i.status):!0}).map(r=>r.to)},_l=e=>{const t=new Map,n=o=>o!=="rumored"&&o!=="removed";for(const o of e.edges){if(!n(o.status))continue;t.has(o.sourceNodeId)||t.set(o.sourceNodeId,[]);const a=t.get(o.sourceNodeId)??[];a.push({nodeId:o.targetNodeId,edgeId:o.id}),t.set(o.sourceNodeId,a),t.has(o.targetNodeId)||t.set(o.targetNodeId,[]);const r=t.get(o.targetNodeId)??[];r.push({nodeId:o.sourceNodeId,edgeId:o.id}),t.set(o.targetNodeId,r)}return t},jl=(e,t,n,o)=>{const a=new Set,r=[];for(a.add(t),r.push(t);r.length>0;){const i=r.shift();if(!i)continue;if(i===n)return!0;const s=e.get(i)??[];for(const{nodeId:c,edgeId:l}of s)l!==o&&(a.has(c)||(a.add(c),r.push(c)))}return!1},ua=e=>e?Oe[e]:-1,jr=(e,t,n)=>{let o=e;const a=ua(t);for(;o&&ua(o.type)>=a;){if(!o.parentNodeId)return;o=n.get(o.parentNodeId)}return o?o.id:void 0},Fl={region:"location",location:"settlement",settlement:void 0,district:void 0,exterior:void 0,interior:"room",room:"feature",feature:void 0},Vl={feature:"room",room:"interior",interior:"exterior",exterior:"district",district:"settlement",settlement:"location",location:"region",region:void 0},Oo=(e,t,n)=>{const o=Fl[e.type];if(!o||Oe[t]>=Oe[o])return null;const a=Oe[o];return n.filter(i=>i.parentNodeId===e.id).every(i=>Oe[i.type]>a)?o:null},Gl=(e,t)=>{const n=Vl[e.type];if(!n)return null;const o=Oe[n];if(e.parentNodeId){const r=t.find(i=>i.id===e.parentNodeId);if(r&&Oe[r.type]>=o)return null}return t.filter(r=>r.parentNodeId===e.id).some(r=>Oe[r.type]<=o)?null:n},Kl=e=>{const t=new Map(e.map(n=>[n.id,n]));for(const n of e){const o=n.parentNodeId;if(!o||o===K)continue;const a=t.get(o);if(a&&Oe[a.type]>=Oe[n.type])return!0}return!1},Bl=(e,t,n="New Approach")=>{const o=Z(e),a=o.nodes.findIndex(d=>d.id===t);if(a===-1)return{updatedMapData:o,newNode:null,newEdges:[]};const r=o.nodes[a];if(r.type!=="feature")return{updatedMapData:o,newNode:null,newEdges:[]};r.type="region";const i=ft(`node-${n}-`),s={id:i,placeName:n,position:{...r.position},description:r.description,aliases:r.aliases??[],status:r.status,type:"feature",parentNodeId:r.id,visited:r.visited};o.nodes.push(s),o.edges.forEach(d=>{d.sourceNodeId===t&&(d.sourceNodeId=i),d.targetNodeId===t&&(d.targetNodeId=i)});const c=o.nodes.filter(d=>d.parentNodeId===t&&d.id!==i),l=[];return c.forEach(d=>{const m={id:ft(`edge-${i}-to-${d.id}`),sourceNodeId:i,targetNodeId:d.id,type:"path",status:r.status==="rumored"?"rumored":"open",description:`Connection from ${n} to ${d.placeName}`};o.edges.push(m),l.push(m)}),{updatedMapData:o,newNode:s,newEdges:l}},Wl=async e=>{let t=Z(e);const n=[],o=[];for(const a of t.nodes)if(a.type==="feature"){const r=t.nodes.filter(i=>i.parentNodeId===a.id);if(r.length>0)if(await Ki(a,r[0])==="convert_child")r.forEach(s=>{s.parentNodeId=a.parentNodeId});else{const s=Bl(t,a.id,"Temp Approach");t=s.updatedMapData,s.newNode&&n.push(s.newNode),o.push(...s.newEdges)}}return{updatedMapData:t,addedNodes:n,addedEdges:o}},Yl=async e=>{try{return(await Wl(e)).updatedMapData}catch(t){return console.error("repairFeatureHierarchy error:",t),e}};function yt(e,t,n,o){var u,m,p,g;if(e.type!=="feature"||t.type!=="feature")return!1;if(n==="shortcut")return!0;const a=o??new Map,r=e.parentNodeId??K,i=t.parentNodeId??K,s=r===K?null:a.get(r),c=i===K?null:a.get(i);if(!s&&r!==K||!c&&i!==K)return!1;if(r===i)return!0;const l=r===K?K:((u=a.get(r))==null?void 0:u.parentNodeId)??K,d=i===K?K:((m=a.get(i))==null?void 0:m.parentNodeId)??K;if(l&&d&&l===d||l&&i===l||d&&r===d)return!0;if(r!==K&&i!==K){const f=((p=a.get(r))==null?void 0:p.parentNodeId)??K,v=((g=a.get(i))==null?void 0:g.parentNodeId)??K;if(f===K&&v===K)return!0}return r===K&&d===K||i===K&&l===K}function xo(e,t,n,o,a){const r=(a.get(e.id)??[]).find(d=>(d.sourceNodeId===e.id&&d.targetNodeId===t.id||d.sourceNodeId===t.id&&d.targetNodeId===e.id)&&d.type===n.type);if(r)return r;const s={id:ft(`edge-${e.id}-to-${t.id}-`),sourceNodeId:e.id,targetNodeId:t.id,description:n.description,type:n.type,status:n.status,travelTime:n.travelTime};for(const[d,u]of Object.entries(n))["description","type","status","travelTime"].includes(d)||(s[d]=u);o.push(s);let c=a.get(e.id);c||(c=[],a.set(e.id,c)),c.push(s);let l=a.get(t.id);return l||(l=[],a.set(t.id,l)),l.push(s),s}function pa(e,t){return e.filter(n=>{const o=t.get(n.sourceNodeId),a=t.get(n.targetNodeId);return!o||!a?!1:yt(o,a,n.type,t)})}function ma(e,t){let n=0,o=e;for(;o.parentNodeId;){const a=t.get(o.parentNodeId);if(!a)break;n++,o=a}return n}function Uo(e,t,n,o){const a=[],r=[e],i=[t];let s=e,c=t,l=0,d="";for(;!yt(s,c,n.type,o)&&l<10;){const u=`${s.id}|${c.id}`;u!==d&&(a.push({sourceParent:s,targetParent:c}),d=u);const m=ma(s,o),p=ma(c,o);if(m>=p&&s.parentNodeId){const g=o.get(s.parentNodeId);if(g)s=g,r.push(s);else break}else if(c.parentNodeId){const g=o.get(c.parentNodeId);if(g)c=g,i.push(c);else break}else break;l++}return yt(s,c,n.type,o)||`${s.id}|${c.id}`!==d&&a.push({sourceParent:s,targetParent:c}),{originalSource:e,originalTarget:t,pairs:a,sourceChain:r,targetChain:i,edgeData:n}}function Hl(e){const t=new Set,n=[];return[...e.sourceChain,...e.targetChain.slice().reverse()].forEach(o=>{o.type!=="feature"&&!t.has(o.id)&&(n.push(o.id),t.add(o.id))}),n.length===0&&(t.has(e.originalSource.id)||(n.push(e.originalSource.id),t.add(e.originalSource.id)),t.has(e.originalTarget.id)||n.push(e.originalTarget.id)),n}function cn(e,t){if(e.length>t.length)return!1;for(let n=0;n<=t.length-e.length;n++){let o=!0;for(let a=0;a<e.length;a++)if(e[a]!==t[n+a]){o=!1;break}if(o)return!0}return!1}function Xn(e){const t=[],n=[];return e.forEach(o=>{const a=Hl(o),r=[...a].reverse();let i=!1;for(let s=0;s<n.length;s++){const c=n[s],l=[...c].reverse();if(a.length===c.length&&a.every((m,p)=>m===c[p])||a.length===c.length&&r.every((m,p)=>m===c[p])){i=!0;break}if(a.length<=c.length&&(cn(a,c)||cn(r,c))||a.length>c.length&&(cn(c,a)||cn(l,a))){a.length>c.length&&(t[s]=o,n[s]=a),i=!0;break}}i||(t.push(o),n.push(a))}),t}async function Jl(e){var l,d;let t=[...e.payload.nodesToAdd??[]];e.nodesToRemove_mut=[...e.payload.nodesToRemove??[]],e.edgesToAdd_mut=[...e.payload.edgesToAdd??[]],e.edgesToRemove_mut=[...e.payload.edgesToRemove??[]];const n=[],o=new Set;for(const u of t){if(e.nameMatchesItemOrNPC(u.placeName)){console.warn(`MapUpdate: Skipping node add "${u.placeName}" that resembles an item or NPC.`),o.add(u.placeName);continue}const m=e.nodesToRemove_mut.findIndex(p=>p.nodeName&&p.nodeName.toLowerCase()===u.placeName.toLowerCase());m!==-1?e.nodesToRemove_mut.splice(m,1):n.push(u)}t=n;const a=[];for(const u of e.edgesToAdd_mut)a.push(u);e.edgesToAdd_mut=a;const r=[],i=new Set;for(const u of e.edgesToAdd_mut){const m=u.sourcePlaceName.toLowerCase(),p=u.targetPlaceName.toLowerCase(),g=u.type,f=m<p?`${m}|${p}|${g}`:`${p}|${m}|${g}`;i.has(f)||(i.add(f),r.push(u))}e.edgesToAdd_mut=r,o.size>0&&(e.edgesToAdd_mut=e.edgesToAdd_mut.filter(u=>!o.has(u.sourcePlaceName)&&!o.has(u.targetPlaceName))),t.forEach(u=>{const m=io(u.placeName);e.newNodesInBatchIdNameMap[u.placeName]={id:m,name:u.placeName}}),(e.payload.nodesToUpdate??[]).forEach(u=>{const m=[u.placeName.toLowerCase()];u.newPlaceName&&m.push(u.newPlaceName.toLowerCase());for(const p of m){const g=e.nodesToRemove_mut.findIndex(f=>f.nodeName&&f.nodeName.toLowerCase()===p);g!==-1&&e.nodesToRemove_mut.splice(g,1)}});let s=[...t],c=!1;for(;s.length>0;){const u=[];for(const m of s){const p=typeof m.description=="string"?m.description:"";typeof m.description!="string"&&(m.description=p);const g=Array.isArray(m.aliases)?m.aliases.filter(N=>typeof N=="string"):[];m.aliases=g;const f=typeof m.status=="string"?m.status:"discovered";m.status=f;const v=m.nodeType,w=ga(m.type)?m.type:ga(v)?v:"feature";m.type=w,m.nodeType=w;let h,T=null;if(m.parentNodeId)if(m.parentNodeId===K)h=void 0;else{const N=je(m.parentNodeId,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(N){let A=m.type;if(N.type===A){const P=Oo({id:"temp",placeName:m.placeName,description:m.description,aliases:m.aliases,parentNodeId:N.id,type:A},N.type,e.newMapData.nodes);P?(m.type=P,A=P,h=N.id):(T=N,h=N.id)}else h=jr(N,A,e.nodeIdMap)}else{const A=/^(.*)_([a-zA-Z0-9]{4})$/.exec(m.parentNodeId);if(A){const C=A[1].toLowerCase().replace(/_/g,"-"),R=Object.values(e.newNodesInBatchIdNameMap).filter(_=>_!=null).filter(_=>_.id.toLowerCase().startsWith(`${C}-`));R.length===1&&(h=R[0].id)}if(h===void 0){u.push(m);continue}}}const I=je(m.placeName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId),S=I&&(h===void 0&&!I.parentNodeId||I.parentNodeId===h)&&(I.placeName.toLowerCase()===m.placeName.toLowerCase()||(((l=I.aliases)==null?void 0:l.some(N=>N.toLowerCase()===m.placeName.toLowerCase()))??!1)||m.aliases.some(N=>N.toLowerCase()===I.placeName.toLowerCase()))?I:null;if(S){const N=new Set([...S.aliases??[]]);m.aliases.forEach(A=>N.add(A)),S.aliases=Array.from(N),m.description&&S.description.trim().length===0&&(S.description=m.description),Reflect.deleteProperty(e.newNodesInBatchIdNameMap,m.placeName);continue}const k=((d=e.newNodesInBatchIdNameMap[m.placeName])==null?void 0:d.id)??io(m.placeName),$={},L=m;for(const[N,A]of Object.entries(L))["placeName","description","aliases","status","parentNodeId","type","nodeType"].includes(N)||($[N]=A);const E={id:k,placeName:m.placeName,position:{x:0,y:0},description:p,aliases:g,status:f,parentNodeId:h,type:m.type,...$};if(e.newMapData.nodes.push(E),e.newlyAddedNodes.push(E),e.nodeIdMap.set(k,E),e.nodeNameMap.set(m.placeName,E),E.aliases&&E.aliases.forEach(N=>e.nodeAliasMap.set(N.toLowerCase(),E)),e.newNodesInBatchIdNameMap[m.placeName]={id:k,name:m.placeName},T){const N={type:"path",status:E.status==="rumored"||T.status==="rumored"?"rumored":"open",description:`Path between ${m.placeName} and ${T.placeName}`};yt(E,T,"path",e.nodeIdMap)?xo(E,T,N,e.newMapData.edges,e.edgesMap):e.pendingChainRequests.push(Uo(E,T,N,e.nodeIdMap))}}if(u.length===s.length)if(c){console.warn("MapUpdate: Some nodes could not be added due to unresolved parents after AI assistance:",u.map(m=>m.placeName).join(", "));break}else{for(const m of u){const p=await ji({placeName:m.placeName,description:m.description,type:m.type,status:m.status,aliases:m.aliases},{sceneDescription:e.sceneDesc,logMessage:e.logMsg,localPlace:e.localPlace,theme:e.theme,currentMapNodeId:e.referenceMapNodeId,mapNodes:e.nodesFromMapData,mapEdges:e.edgesFromMapData},e.minimalModelCalls);m.parentNodeId=p??K}c=!0,s=u;continue}s=u}}const ga=e=>typeof e=="string"&&mt.includes(e);async function ql(e){for(const t of e.payload.nodesToUpdate??[]){const n=await e.resolveNodeReference(t.placeName);if(n){let o=n.parentNodeId??void 0;if(t.parentNodeId!==void 0){const a=t.parentNodeId;if(a===K)o=void 0;else{const r=await e.resolveNodeReference(a);if(r){o=r.id;let i=typeof t.type=="string"?t.type:n.type;if(r.type===i){const s=Oo(n,r.type,e.newMapData.nodes);s?(i=s,o=r.id):o=r.parentNodeId}n.type=i}else console.warn(`MapUpdate (nodesToUpdate): Feature node "${t.placeName}" trying to update parentNodeId to NAME "${t.parentNodeId}" which was not found.`),o=void 0}}if(t.parentNodeId===void 0&&typeof t.type=="string"&&(n.type=t.type),typeof t.description=="string"&&(n.description=t.description),Array.isArray(t.aliases)){n.aliases=t.aliases.filter(a=>typeof a=="string");for(const[a,r]of Array.from(e.nodeAliasMap.entries()))r.id===n.id&&e.nodeAliasMap.delete(a);n.aliases.forEach(a=>e.nodeAliasMap.set(a.toLowerCase(),n))}typeof t.status=="string"&&(n.status=t.status),n.parentNodeId=o,"nodeType"in n&&delete n.nodeType;for(const a in t)["description","aliases","status","parentNodeId","type","nodeType","placeName","visited","newPlaceName"].includes(a)||(n[a]=t[a]);if(t.newPlaceName&&t.newPlaceName!==n.placeName){const a=Object.keys(e.newNodesInBatchIdNameMap).find(i=>{const s=e.newNodesInBatchIdNameMap[i];return s!=null&&s.id===n.id});a&&(Reflect.deleteProperty(e.newNodesInBatchIdNameMap,a),e.newNodesInBatchIdNameMap[t.newPlaceName]={id:n.id,name:t.newPlaceName}),e.nodeNameMap.delete(n.placeName);const r=n.placeName;n.placeName=t.newPlaceName,e.nodeNameMap.set(n.placeName,n),n.aliases??(n.aliases=[]),n.aliases.includes(r)||n.aliases.push(r);for(const[i,s]of Array.from(e.nodeAliasMap.entries()))s.id===n.id&&e.nodeAliasMap.delete(i);n.aliases.forEach(i=>e.nodeAliasMap.set(i.toLowerCase(),n))}}else console.warn(`MapUpdate (nodesToUpdate): Node with original name "${t.placeName}" not found for update.`)}for(const t of e.nodesToRemove_mut){let n=await e.resolveNodeReference(t.nodeId);if(!n&&t.nodeName&&(n=await e.resolveNodeReference(t.nodeName)),n){if(t.nodeName&&n.placeName.toLowerCase()!==t.nodeName.toLowerCase()&&console.warn(`MapUpdate (nodesToRemove): nodeId "${t.nodeId}" resolves to "${n.placeName}" which mismatches provided nodeName "${t.nodeName}".`),e.inventoryItems.some(s=>{var c;return s.holderId===n.id&&!((c=s.tags)!=null&&c.includes("junk"))})){console.warn(`MapUpdate (nodesToRemove): Skipping removal of "${n.placeName}" because it contains non-junk items.`);continue}const a=n.id,r=e.newMapData.nodes.findIndex(s=>s.id===a);r!==-1&&e.newMapData.nodes.splice(r,1),e.nodeNameMap.delete(n.placeName),e.nodeIdMap.delete(a),e.newMapData.edges=e.newMapData.edges.filter(s=>s.sourceNodeId!==a&&s.targetNodeId!==a),e.edgesMap.forEach((s,c)=>{e.edgesMap.set(c,s.filter(l=>l.sourceNodeId!==a&&l.targetNodeId!==a))}),e.edgesMap.delete(a);for(const[s,c]of Array.from(e.nodeAliasMap.entries()))c.id===a&&e.nodeAliasMap.delete(s);const i=Object.keys(e.newNodesInBatchIdNameMap).find(s=>{const c=e.newNodesInBatchIdNameMap[s];return c!=null&&c.id===a||s===t.nodeName});i&&Reflect.deleteProperty(e.newNodesInBatchIdNameMap,i)}else console.warn(`MapUpdate (nodesToRemove): Node "${t.nodeId}" not found for removal.`)}}async function zl(e){var t;for(const n of e.edgesToAdd_mut){const o=await e.resolveNodeReference(n.sourcePlaceName),a=await e.resolveNodeReference(n.targetPlaceName);if(!o||!a){console.warn(`MapUpdate: Skipping edge add due to missing source ("${n.sourcePlaceName}") or target ("${n.targetPlaceName}") node.`);continue}const r=e.nodeIdMap.get(o.id),i=e.nodeIdMap.get(a.id);if(!r||!i){console.warn("MapUpdate: Failed to resolve edge nodes after lookup.");continue}const s=n.type,c=r.id<i.id?`${r.id}|${i.id}|${s}`:`${i.id}|${r.id}|${s}`;if(e.processedChainKeys.has(c))continue;e.processedChainKeys.add(c);const l=n.status,d=Uo(r,i,{description:n.description,status:l,travelTime:n.travelTime,type:s},e.nodeIdMap);if(!yt(r,i,s,e.nodeIdMap)){e.pendingChainRequests.push(d);continue}xo(r,i,{description:n.description,type:s,travelTime:n.travelTime,status:l},e.newMapData.edges,e.edgesMap)}for(const n of e.payload.edgesToUpdate??[]){const o=await e.resolveNodeReference(n.sourcePlaceName),a=await e.resolveNodeReference(n.targetPlaceName);if(!o||!a){console.warn(`MapUpdate: Skipping edge update due to missing source ("${n.sourcePlaceName}") or target ("${n.targetPlaceName}") node.`);continue}const r=o.id,i=a.id,s=e.nodeIdMap.get(r),c=e.nodeIdMap.get(i);if(!s||!c)continue;const l=(e.edgesMap.get(r)??[]).filter(m=>m.sourceNodeId===r&&m.targetNodeId===i||m.sourceNodeId===i&&m.targetNodeId===r),d=n.type??((t=l[0])==null?void 0:t.type);if(!yt(s,c,d,e.nodeIdMap)){console.warn(`MapUpdate: Edge update between "${s.placeName}" and "${c.placeName}" violates hierarchy rules. Skipping update.`);continue}const u=l.find(m=>n.type?m.type===n.type:!0);if(!u){console.warn(`MapUpdate (edgesToUpdate): Edge between "${n.sourcePlaceName}" and "${n.targetPlaceName}" not found for update.`);continue}typeof n.description=="string"&&(u.description=n.description),typeof n.status=="string"&&(u.status=n.status),typeof n.travelTime=="string"&&(u.travelTime=n.travelTime),typeof n.type=="string"&&(u.type=n.type)}for(const n of e.edgesToRemove_mut){let o=e.newMapData.edges.find(i=>i.id===n.edgeId)??e.newMapData.edges.find(i=>i.id.toLowerCase().includes(n.edgeId.toLowerCase()));if(!o&&n.sourceId&&n.targetId){const i=await e.resolveNodeReference(n.sourceId),s=await e.resolveNodeReference(n.targetId);if(!i||!s){console.warn(`MapUpdate: Skipping edge removal due to missing source ("${n.sourceId}") or target ("${n.targetId}") node.`);continue}o=e.newMapData.edges.find(c=>c.sourceNodeId===i.id&&c.targetNodeId===s.id||c.sourceNodeId===s.id&&c.targetNodeId===i.id)??void 0}else o&&(n.sourceId&&o.sourceNodeId!==n.sourceId&&o.targetNodeId!==n.sourceId||n.targetId&&o.sourceNodeId!==n.targetId&&o.targetNodeId!==n.targetId)&&console.warn(`MapUpdate (edgesToRemove): edgeId "${n.edgeId}" does not match provided sourceId/targetId.`);if(!o){console.warn(`MapUpdate (edgesToRemove): Edge "${n.edgeId}" not found for removal.`);continue}e.newMapData.edges=e.newMapData.edges.filter(i=>i!==o);const a=e.edgesMap.get(o.sourceNodeId);a&&e.edgesMap.set(o.sourceNodeId,a.filter(i=>i!==o));const r=e.edgesMap.get(o.targetNodeId);r&&e.edgesMap.set(o.targetNodeId,r.filter(i=>i!==o))}}async function Ql(e){var a;let t=Xn(e.pendingChainRequests.splice(0)),n=0;const o={sceneDescription:e.sceneDesc,logMessage:e.logMsg,theme:e.theme,mapNodes:e.newMapData.nodes};for(;t.length>0&&n<Go;){t=Xn(t);let r=null;for(let i=0;i<B&&(console.log(`Connector Chains Refinement: Round ${String(n+1)}/${String(Go)}, Attempt ${String(i+1)}/${String(B)}`),r=await Gi(t,o),r.debugInfo&&((a=e.debugInfo.connectorChainsDebugInfo)==null||a.push({round:n+1,...r.debugInfo})),!r.payload);i++)console.warn(`Connector Chains Refinement (Round ${String(n+1)}, Attempt ${String(i+1)}): invalid or empty response. Retrying.`);if(r!=null&&r.payload)t=[],(r.payload.nodesToAdd??[]).forEach(i=>{const s=i,c=typeof s.description=="string"?s.description:"Connector node",l=typeof s.status=="string"?s.status:"discovered",d=typeof s.type=="string"?s.type:"feature",u=Array.isArray(s.aliases)?s.aliases.filter(w=>typeof w=="string"):void 0,m=s.parentNodeId&&s.parentNodeId!==K?je(s.parentNodeId,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId):void 0,p=m?m.id:void 0,g=je(i.placeName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(g){if(Array.isArray(s.aliases)&&s.aliases.length>0){const w=new Set([...g.aliases??[]]);s.aliases.forEach(h=>w.add(h)),g.aliases=Array.from(w),g.aliases.forEach(h=>e.nodeAliasMap.set(h.toLowerCase(),g))}s.description&&g.description.trim().length===0&&(g.description=s.description);return}const v={id:ft(`node-${i.placeName}-`),placeName:i.placeName,position:m?{...m.position}:{x:0,y:0},description:c,aliases:u,status:l,parentNodeId:p,type:d},y=v;for(const w of Object.keys(s)){if(["description","aliases","status","parentNodeId","type","placeName"].includes(w))continue;const h=s[w];if(h===void 0)continue;const T=w;y[T]=h}e.newMapData.nodes.push(v),e.newlyAddedNodes.push(v),e.nodeIdMap.set(v.id,v),e.nodeNameMap.set(v.placeName,v),v.aliases&&v.aliases.forEach(w=>e.nodeAliasMap.set(w.toLowerCase(),v))}),(r.payload.edgesToAdd??[]).forEach(i=>{const s=i,c=je(i.sourcePlaceName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId),l=je(i.targetPlaceName,e.newMapData.nodes,e.newMapData,e.referenceMapNodeId);if(c&&l){const d=s.type??"path",u=c.id<l.id?`${c.id}|${l.id}|${d}`:`${l.id}|${c.id}|${d}`;if(e.processedChainKeys.has(u))return;e.processedChainKeys.add(u);const m=s.status??"open";yt(c,l,d,e.nodeIdMap)?xo(c,l,{description:s.description,status:m,travelTime:s.travelTime,type:d},e.newMapData.edges,e.edgesMap):(console.warn(`Connector chain edge between "${c.placeName}" and "${l.placeName}" violates hierarchy rules. Reprocessing.`),t.push(Uo(c,l,{description:s.description,status:m,travelTime:s.travelTime,type:d},e.nodeIdMap)))}}),o.mapNodes=e.newMapData.nodes;else{console.warn(`Connector Chains Refinement failed after ${String(B)} attempts for round ${String(n+1)}. Giving up on these chain requests.`);break}t=Xn(t),n++}e.debugInfo.connectorChainsDebugInfo&&e.debugInfo.connectorChainsDebugInfo.length===0&&(e.debugInfo.connectorChainsDebugInfo=null)}async function Xl(e){for(const t of e.newMapData.nodes){const n=t.parentNodeId;if(!n||n===K)continue;const o=e.nodeIdMap.get(n);o&&o.type===t.type&&await Zl(e,t,o)}}async function Zl(e,t,n){var c;const o=[],a=Oo(t,n.type,e.newMapData.nodes);if(a&&o.push({desc:`Downgrade ${t.placeName} to ${a}`,apply:()=>{t.type=a},cloneApply:l=>{const d=l.find(u=>u.id===t.id);d&&(d.type=a)}}),n.parentNodeId!==void 0){const l=jr(n.parentNodeId===K?void 0:e.nodeIdMap.get(n.parentNodeId),t.type,e.nodeIdMap);if(l!==void 0&&l!==t.parentNodeId){const d=((c=e.nodeIdMap.get(l))==null?void 0:c.placeName)??"Unknown";o.push({desc:`Reparent ${t.placeName} under ${d}`,apply:()=>{t.parentNodeId=l},cloneApply:u=>{const m=u.find(p=>p.id===t.id);m&&(m.parentNodeId=l)}})}}const r=Gl(n,e.newMapData.nodes);r&&o.push({desc:`Upgrade ${n.placeName} to ${r}`,apply:()=>{n.type=r},cloneApply:l=>{const d=l.find(u=>u.id===n.id);d&&(d.type=r)}});const i=o.filter(l=>{const d=e.newMapData.nodes.map(u=>({...u}));return l.cloneApply(d),!Kl(d)});if(i.length===0)return;let s=i[0];if(i.length>1){const l=await Bi({sceneDescription:e.sceneDesc,parent:n,child:t,options:i.map(d=>d.desc)},e.minimalModelCalls);l&&l>=1&&l<=i.length&&(s=i[l-1])}s.apply()}const Fr=async({payload:e,currentMapData:t,theme:n,previousMapNodeId:o,inventoryItems:a,knownNPCs:r,aiData:i,minimalModelCalls:s,debugInfo:c})=>{const l="sceneDescription"in i?i.sceneDescription:"",d=i.logMessage??"",u=i.localPlace??"Unknown",m="currentMapNodeId"in i&&i.currentMapNodeId?i.currentMapNodeId:o,p=t.nodes,g=new Set(p.map(D=>D.id)),f=t.edges.filter(D=>g.has(D.sourceNodeId)&&g.has(D.targetNodeId)),v=new Map,y=new Map,w=new Map,h=new Map;p.forEach(D=>{v.set(D.id,D),y.set(D.placeName,D),D.aliases&&D.aliases.forEach(j=>w.set(j.toLowerCase(),D))}),f.forEach(D=>{h.has(D.sourceNodeId)||h.set(D.sourceNodeId,[]),h.has(D.targetNodeId)||h.set(D.targetNodeId,[]);const j=h.get(D.sourceNodeId);j&&j.push(D);const J=h.get(D.targetNodeId);J&&J.push(D)});const T=async D=>{let j=je(D,L.nodes,L,m);if(!j){const ve=/^(.*)_([a-zA-Z0-9]{4})$/.exec(D);if(ve){const F=ve[1].toLowerCase().replace(/_/g,"-"),O=Object.values(E).filter(V=>V!=null).filter(V=>V.id.toLowerCase().startsWith(`${F}-`));if(O.length===1&&(j=L.nodes.find(V=>V.id===O[0].id),!j))return}}if(!j){const J=await Fi(D,{mapNodes:L.nodes,currentLocationId:m},s);J&&(j=je(J,L.nodes,L,m))}return j},I=D=>D.toLowerCase().replace(/[{}().,!?;:"[\]]/g,"").replace(/\s+/g," ").trim(),S=D=>I(D).split(" ").filter(j=>j.length>0),M=a.map(D=>({norm:I(D.name),tokens:S(D.name)})),k=[];r.forEach(D=>{k.push({norm:I(D.name),tokens:S(D.name)}),(D.aliases??[]).forEach(j=>{k.push({norm:I(j),tokens:S(j)})})});const $=D=>{const j=I(D),J=S(D),ve=U=>{if(U.norm===j)return!0;const F=J.filter(q=>U.tokens.includes(q)),O=F.length/J.length,V=F.length/U.tokens.length;return F.length>0&&O>=.6&&V>=.6};return M.some(ve)||k.some(ve)},L=Z(t),E={},N=[],A=[],P=[],C=new Set,R=[],_=[],W=[];v.clear(),y.clear(),w.clear(),h.clear(),L.nodes.forEach(D=>{v.set(D.id,D),y.set(D.placeName,D),D.aliases&&D.aliases.forEach(j=>w.set(j.toLowerCase(),D))}),L.edges.forEach(D=>{if(v.has(D.sourceNodeId)&&v.has(D.targetNodeId)){h.has(D.sourceNodeId)||h.set(D.sourceNodeId,[]),h.has(D.targetNodeId)||h.set(D.targetNodeId,[]);const j=h.get(D.sourceNodeId);j&&j.push(D);const J=h.get(D.targetNodeId);J&&J.push(D)}});const x={payload:e,newMapData:L,theme:n,referenceMapNodeId:m,nodesFromMapData:p,edgesFromMapData:f,nodeIdMap:v,nodeNameMap:y,nodeAliasMap:w,edgesMap:h,newNodesInBatchIdNameMap:E,newlyAddedNodes:N,newlyAddedEdges:A,pendingChainRequests:P,processedChainKeys:C,nodesToRemove_mut:R,edgesToAdd_mut:_,edgesToRemove_mut:W,resolveNodeReference:T,nameMatchesItemOrNPC:$,minimalModelCalls:s,sceneDesc:l,logMsg:d,localPlace:u,debugInfo:c,inventoryItems:a};await Jl(x),await ql(x),await Xl(x),await zl(x),x.newMapData.edges=pa(x.newMapData.edges,x.nodeIdMap),x.edgesMap.clear(),x.newMapData.edges.forEach(D=>{x.edgesMap.has(D.sourceNodeId)||x.edgesMap.set(D.sourceNodeId,[]),x.edgesMap.has(D.targetNodeId)||x.edgesMap.set(D.targetNodeId,[]);const j=x.edgesMap.get(D.sourceNodeId);j&&j.push(D);const J=x.edgesMap.get(D.targetNodeId);J&&J.push(D)}),await Ql(x);const ce=D=>a.some(j=>{var J;return j.holderId===D&&!((J=j.tags)!=null&&J.includes("junk"))}),ge=D=>{if(ce(D.id)){console.warn(`Sanity check: skipping removal of "${D.placeName}" because it contains non-junk items.`);return}const j=D.id,J=x.newMapData.nodes.findIndex(U=>U.id===j);J!==-1&&x.newMapData.nodes.splice(J,1),x.nodeNameMap.delete(D.placeName),x.nodeIdMap.delete(j),x.newMapData.edges=x.newMapData.edges.filter(U=>U.sourceNodeId!==j&&U.targetNodeId!==j),x.edgesMap.forEach((U,F)=>{x.edgesMap.set(F,U.filter(O=>O.sourceNodeId!==j&&O.targetNodeId!==j))}),x.edgesMap.delete(j);for(const[U,F]of Array.from(x.nodeAliasMap.entries()))F.id===j&&x.nodeAliasMap.delete(U);const ve=Object.keys(x.newNodesInBatchIdNameMap).find(U=>{const F=x.newNodesInBatchIdNameMap[U];return F!=null&&F.id===j||U===D.placeName});ve&&Reflect.deleteProperty(x.newNodesInBatchIdNameMap,ve)},ue=new Map;a.forEach(D=>{D.type!=="vehicle"&&ue.set(I(D.name),D)});const X=new Set;r.forEach(D=>{X.add(I(D.name)),(D.aliases??[]).forEach(j=>X.add(I(j)))}),x.newMapData.nodes.forEach(D=>{const j=I(D.placeName);(ue.has(j)||X.has(j))&&ge(D)});const pe=new Set;r.filter(D=>D.presenceStatus==="companion").forEach(D=>{pe.add(I(D.name)),(D.aliases??[]).forEach(j=>pe.add(I(j)))});const me=a.filter(D=>{const j=I(D.name);return!(D.type!=="vehicle"&&pe.has(j))});return a.splice(0,a.length,...me),x.newMapData.edges=pa(x.newMapData.edges,x.nodeIdMap),x.edgesMap.clear(),x.newMapData.edges.forEach(D=>{x.edgesMap.has(D.sourceNodeId)||x.edgesMap.set(D.sourceNodeId,[]),x.edgesMap.has(D.targetNodeId)||x.edgesMap.set(D.targetNodeId,[]);const j=x.edgesMap.get(D.sourceNodeId);j&&j.push(D);const J=x.edgesMap.get(D.targetNodeId);J&&J.push(D)}),{updatedMapData:L,newlyAddedNodes:N,newlyAddedEdges:A,debugInfo:c}},ed=async(e,t,n,o,a,r,i)=>{if(!ee())return console.error("API Key not configured for Map Update Service."),null;const s="sceneDescription"in e?e.sceneDescription:"",c=e.logMessage??"",l=e.localPlace??"Unknown",d=e.mapHint??"",u="currentMapNodeId"in e&&e.currentMapNodeId?e.currentMapNodeId:a,m=[],p=u??"Player's Previous Map Node: Unknown or N/A.",g=t.nodes.length>0?hi(t):"No map data exists yet.",f=o.length>0?o.map(k=>`"${k.placeName}"`).join(", "):"No important places are known yet.",v=new Set;r.forEach(k=>{k.type!=="vehicle"&&v.add(k.name)}),"newItems"in e&&e.newItems&&e.newItems.forEach(k=>{k.type!=="vehicle"&&v.add(k.name)});const y=Array.from(v),w=new Set;i.forEach(k=>{w.add(k.name),(k.aliases??[]).forEach($=>w.add($))}),"npcsAdded"in e&&e.npcsAdded&&e.npcsAdded.forEach(k=>{w.add(k.name),(k.aliases??[]).forEach($=>w.add($))}),"npcsUpdated"in e&&e.npcsUpdated&&e.npcsUpdated.forEach(k=>{w.add(k.name),(k.newAliases??[]).forEach($=>w.add($)),k.addAlias&&w.add(k.addAlias)});const h=Array.from(w),T=kl(s,c,l,d,n,p,g,f,y,h),{payload:I,debugInfo:S}=await xl(T,Pl,m,n);return I?await Fr({payload:I,currentMapData:t,theme:n,previousMapNodeId:a,inventoryItems:r,knownNPCs:i,aiData:e,minimalModelCalls:m,debugInfo:S}):{updatedMapData:null,newlyAddedNodes:[],newlyAddedEdges:[],debugInfo:S}},fa=2,td=async(e,t,n,o,a,r,i)=>{var I;if(!ee())return console.error("API Key not configured for Map Update Service."),null;const s="sceneDescription"in e?e.sceneDescription:"",c=e.logMessage??"",{previousMapNodeId:l,inventoryItems:d,knownNPCs:u}=i,m=Ml(n,t,{logMessage:c,currentScene:s,previousLocalPlace:a,currentLocalPlace:r,previousMapNodeName:o});let p=null;for(let S=0;S<fa;S++){p=await Ol(m,Cl,n);const M=p.nodesToAdd.length>0,k=((I=p.suggestedCurrentMapNodeId)==null?void 0:I.trim())??null,$=k?!!je(k,t.nodes,t,l):!0;if(!M&&k&&!$){const L=`Navigation-only suggestion "${k}" did not match any known map node.`;p.debugInfo.validationError=p.debugInfo.validationError?`${p.debugInfo.validationError}; ${L}`:L;const E=(S+1).toString();if(console.warn(`Cartographer navigation-only retry (${E}): ${L}`),S<fa-1)continue}break}if(!p)return null;const{suggestedCurrentMapNodeId:g,nodesToAdd:f,edgesToAdd:v,debugInfo:y}=p;let w=g,h=null;if((f.length>0||v.length>0)&&(!(w?je(w,t.nodes,t,l):void 0)&&f.length>0||v.length>0)){const k={};f.length>0&&(k.nodesToAdd=f),v.length>0&&(k.edgesToAdd=v),w&&(k.suggestedCurrentMapNodeId=w);const $=await Fr({payload:k,currentMapData:t,theme:n,previousMapNodeId:l,inventoryItems:d,knownNPCs:u,aiData:e,minimalModelCalls:[],debugInfo:y});if(h={updatedMapData:$.updatedMapData,newlyAddedNodes:$.newlyAddedNodes,newlyAddedEdges:$.newlyAddedEdges,debugInfo:$.debugInfo},$.newlyAddedNodes.length>0){const L=w==null?void 0:w.toLowerCase(),E=L?$.newlyAddedNodes.find(N=>[N.id.toLowerCase(),N.placeName.toLowerCase(),...(N.aliases??[]).map(P=>P.toLowerCase())].includes(L)):$.newlyAddedNodes[0];E&&(w=E.id)}}return{suggested:w,debugInfo:y,mapUpdateResult:h}},nd=[{keywords:["inside of","inside"],type:"direct",weight:100},{keywords:["atop of","atop"],type:"direct",weight:100},{keywords:["at the center of","at the heart of","at the"],type:"direct",weight:90},{keywords:["at"],type:"direct",weight:85},{keywords:["within"],type:"direct",weight:95},{keywords:["on top of","on"],type:"direct",weight:90},{keywords:["entering into","entering"],type:"direct",weight:90},{keywords:["overlooking"],type:"relational",weight:60},{keywords:["leading to","leading towards"],type:"relational",weight:55},{keywords:["near to","near by","nearby","near","close to","by","beside","next to"],type:"relational",weight:50},{keywords:["facing"],type:"relational",weight:45},{keywords:["approaching"],type:"relational",weight:40},{keywords:["exiting from","exiting","leaving from","leaving"],type:"relational",weight:35},{keywords:["heading to","heading towards","going to","going towards"],type:"relational",weight:50},{keywords:["coming from","arriving from"],type:"relational",weight:30},{keywords:["outside of","outside","behind"],type:"negating",weight:30},{keywords:["away from","far from"],type:"negating",weight:20},{keywords:["beyond"],type:"negating",weight:25},{keywords:["of the","of a","of an","of"],type:"contextual_linking",weight:5},{keywords:["from the","from a","from an","from"],type:"contextual_linking",weight:5}],Vr=[...nd].sort((e,t)=>Math.max(...t.keywords.map(n=>n.length))-Math.max(...e.keywords.map(n=>n.length))),od=Vr.filter(e=>e.type!=="contextual_linking").flatMap(e=>e.keywords).sort((e,t)=>t.length-e.length),ad=new Set(["the","a","an","is","are","was","were","am","i","you","he","she","it","we","they","and","or","but","so","then","just","very","quite","also","too","now","player","character","up","down","left","right","north","south","east","west","above","below","under","over","through","around","along","across","between","among","front","go","look","see","find","take","get","move","walk","run","stand","sit","player is","several","stories"]),ze=e=>e?e.toLowerCase().replace(/[.,!?;:"(){}[\]'’]/g,"").trim():"",rd=e=>e?ze(e).split(/\s+/).map(n=>n.replace(/^['"]+|['"]+$/g,"")).filter(n=>n.length>0&&!ad.has(n)).map(n=>n.trim()).filter(n=>n.length>0):[];function sd(e,t){if(!e||!t||e===t||e.length<3&&t.length<3)return!1;const n=e.toLowerCase(),o=t.toLowerCase();return!!(n===o+"s"||o===n+"s"||n.endsWith("es")&&n.slice(0,-2)===o||o.endsWith("es")&&o.slice(0,-2)===n||n.endsWith("ies")&&n.slice(0,-3)+"y"===o||o.endsWith("ies")&&o.slice(0,-3)+"y"===n)}const id=e=>{if(!e||e.trim()==="")return[];const t=[],n=`\\b(?:${od.map(d=>d.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")).join("|")})\\b`,o=new RegExp(n,"gi"),a=[];let r;for(;(r=o.exec(e))!==null;){const d=r[0].toLowerCase(),u=Vr.find(m=>m.keywords.includes(d));u&&u.type!=="contextual_linking"&&a.push({index:r.index,text:d,originalText:r[0],definition:u})}a.sort((d,u)=>d.index-u.index);let i=0;const s=a.length>0?a[0].index:e.length;let c=e.substring(0,s).trim();const l=c.indexOf(",");l!==-1&&(c=c.substring(0,l).trim()),c&&t.push({phrase:c,prepositionKeyword:"implicit_subject",prepositionType:"direct",prepositionWeight:100});for(let d=0;d<a.length;d++){const u=a[d];i=u.index+u.originalText.length;const m=d+1<a.length?a[d+1].index:e.length;let p=e.substring(i,m).trim();const g=p.indexOf(",");g!==-1&&(p=p.substring(0,g).trim()),p&&t.push({phrase:p,prepositionKeyword:u.text,prepositionType:u.definition.type,prepositionWeight:u.definition.weight,originalPrepositionText:u.originalText})}return t.filter(d=>d.phrase.length>0)},cd=30,ld=10,bn=rd,dd=(e,t,n)=>{const o=[];for(const a of n){const r=[a.placeName,...a.aliases??[]];for(const i of r.filter(s=>s&&s.trim()!=="")){const s=ze(i),c=bn(i).join(" ");let l=0;if(s===e?l=1e3:e.endsWith(s)&&e.length>s.length?l=950:e.startsWith(s)&&e.length>s.length?l=920:c&&t&&c===t?l=900:e.includes(s)&&s.length>0&&(l=800+s.length*.5),l>0){const d=a.type==="feature";o.push({nodeId:a.id,score:l+(d?ld:0),isFeature:d,nameLength:i.length})}}}return o},ud=(e,t,n)=>{const{node:o,nameTokenPairs:a}=e;let r=-1;for(const{name:i,tokens:s}of a){if(s.length===0)continue;let c=0;for(const l of t){const d=bn(l.phrase);if(d.length===0)continue;let u=0;const m=[...d];if(s.forEach(p=>{const g=m.indexOf(p);if(g!==-1)u++,m.splice(g,1);else{const f=m.findIndex(v=>sd(p,v));f!==-1&&(u++,m.splice(f,1))}}),u>0){const p=u/s.length,g=u/d.length;let f=p*60+g*40;const v=ze(i),y=ze(l.phrase);let w=0;v===y?w=100:y.endsWith(v)&&y.length>v.length?w=75:y.startsWith(v)&&y.length>v.length?w=70:y.includes(v)?w=50+v.length*.2:v.includes(y)&&(w=25+y.length*.2),f+=w;const h=l.prepositionType==="negating"&&f>75?l.prepositionWeight*.5:l.prepositionWeight;c+=f*(h/100)}}c>r&&(r=c)}return r>-1&&n.has(o.id)&&(r+=cd),r},pd=(e,t,n)=>{if(!e||t.score>e.score)return t;if(t.score<e.score)return e;const o=n.find(l=>l.id===t.nodeId),a=n.find(l=>l.id===e.nodeId);if(!o||!a)return e;const r=o.type==="feature",i=a.type==="feature";if(r&&!i)return t;if(!r&&i)return e;const s=ze(o.placeName).length,c=ze(a.placeName).length;return s>c?t:e},md=(e,t,n)=>{if(!e)return null;const o=n.find(r=>r.id===e);if(!o||o.type==="feature"||o.parentNodeId&&o.parentNodeId!==K)return e;const a=n.filter(r=>r.type==="feature"&&r.parentNodeId===o.id);for(const r of a){const i=r.placeName,s=ze(i);if(t.find(l=>l.prepositionType==="direct"&&ze(l.phrase).includes(s)))return r.id}return e},ha=(e,t,n,o,a)=>{if(!e||e.trim()==="")return console.log(`MapNodeMatcher (${t}): No suggestion provided or suggestion is empty.`),{matched:!1,nodeId:null};if(a.length===0)return console.log(`MapNodeMatcher (${t}): No nodes found for theme "${o}" in draft state.`),{matched:!1,nodeId:null};const r=a.find(g=>g.id===e);if(r)return console.log(`MapNodeMatcher (${t}): AI suggested node ID "${e}", matched to ID "${r.id}".`),{matched:!0,nodeId:r.id};const i=e.toLowerCase();let s=a.find(g=>g.id.toLowerCase().includes(i));const c=/^(.*)-([a-zA-Z0-9]{4})$/;let l=null;if(!s){const g=c.exec(e);if(g){const f=g[1];l=f,s=a.find(v=>v.id.toLowerCase().includes(f.toLowerCase()))}}if(s)return console.log(`MapNodeMatcher (${t}): Heuristically matched malformed ID "${e}" to "${s.id}".`),{matched:!0,nodeId:s.id};const d=e.toLowerCase(),u=a.filter(g=>{var f;return g.placeName.toLowerCase()===d||((f=g.aliases)==null?void 0:f.some(v=>v.toLowerCase()===d))});if(u.length===0){const f=(l??e).replace(/_/g," ").toLowerCase();u.push(...a.filter(v=>{var y;return v.placeName.toLowerCase()===f||((y=v.aliases)==null?void 0:y.some(w=>w.toLowerCase()===f))}))}if(u.length===0)return console.log(`MapNodeMatcher (${t}): AI suggested identifier "${e}" NOT found by ID, name, or alias within theme "${o}".`),{matched:!1,nodeId:null};if(u.length===1){const g=u[0];return console.log(`MapNodeMatcher (${t}): AI suggested node NAME/ALIAS "${e}", uniquely matched to ID "${g.id}".`),{matched:!0,nodeId:g.id}}if(console.log(`MapNodeMatcher (${t}): AI suggested node NAME/ALIAS "${e}", multiple matches found. Applying tie-breaking.`),n){const g=u.find(f=>f.id===n);if(g)return console.log(`MapNodeMatcher (${t}): Tie-breaker: Matched oldMapNodeId "${n}".`),{matched:!0,nodeId:g.id}}const m=u.filter(g=>g.type!=="feature");if(m.length>0){const g=m[0];return console.log(`MapNodeMatcher (${t}): Tie-breaker: Chose non-feature node "${g.placeName}" (ID: ${g.id}).`),{matched:!0,nodeId:g.id}}const p=u[0];return console.log(`MapNodeMatcher (${t}): Tie-breaker: Chose first feature node match "${p.placeName}" (ID: ${p.id}).`),{matched:!0,nodeId:p.id}},gd=(e,t,n)=>{const o=t.nodes;if(!e||o.length===0)return null;const a=e.indexOf(","),r=(a!==-1?e.substring(0,a):e).trim(),i=ze(r),s=bn(e).join(" "),c=dd(i,s,o);if(c.length>0)return c.sort((g,f)=>f.score!==g.score?f.score-g.score:g.isFeature!==f.isFeature?g.isFeature?-1:1:f.nameLength-g.nameLength),c[0].nodeId;const l=id(e);if(l.length===0)return null;let d=null;const u=new Set;n&&t.edges.forEach(g=>{g.sourceNodeId===n?u.add(g.targetNodeId):g.targetNodeId===n&&u.add(g.sourceNodeId)});const m=o.map(g=>({node:g,nameTokenPairs:[g.placeName,...g.aliases??[]].filter(f=>f&&f.trim()!=="").map(f=>({name:f,tokens:bn(f)}))}));for(const g of m){const f=ud(g,l,u);if(f>-1){const v={nodeId:g.node.id,score:f};d=pd(d,v,o)}}let p=d?d.nodeId:null;return d&&d.score>0&&(p=md(p,l,o)),p},ya=e=>({nodesById:new Map(e.nodes.map(t=>[t.id,t])),edgesById:new Map(e.edges.map(t=>[t.id,t]))}),fd=(e,t,n)=>{if(e.length===0)return!1;const o={};let a=!1;for(const{nodeId:r,newName:i}of e){const s=n.get(r);if(!s)continue;const c=s.id,l=io(i);c===l&&s.placeName===i||(o[c]=l,a=!0,s.placeName=i,s.id=l,n.delete(c),n.set(l,s),t.mapData.nodes.forEach(d=>{d.parentNodeId===c&&(d.parentNodeId=l)}),t.mapData.edges.forEach(d=>{d.sourceNodeId===c&&(d.sourceNodeId=l),d.targetNodeId===c&&(d.targetNodeId=l)}),t.inventory.forEach(d=>{d.holderId===c&&(d.holderId=l)}),t.currentMapNodeId===c&&(t.currentMapNodeId=l),t.destinationNodeId===c&&(t.destinationNodeId=l))}return a&&Tl(t.loreFacts,o),a},hd=async(e,t,n,o,a,r)=>{var S,M,k,$,L,E;const i=t.theme;let s,c=null,{nodesById:l,edgesById:d}=ya(t.mapData);const u=()=>{const N=ya(t.mapData);l=N.nodesById,d=N.edgesById},m=N=>N?l.get(N):void 0,p=e.mapUpdated===!0,g=t.localPlace!==n.localPlace;if(p||g){const N=o;a("map_updates");let A=null;if(p){const C=t.mapData.nodes.filter(R=>R.type!=="feature");if(c=await ed(e,t.mapData,i,C,n.currentMapNodeId,t.inventory,t.allNPCs),!c)throw new Error("Map Update Service returned no data.");if(!c.updatedMapData){const R=((S=c.debugInfo)==null?void 0:S.validationError)??((M=c.debugInfo)==null?void 0:M.rawResponse)??"Unknown error";throw new Error(`Map update failed: ${R}`)}s=($=(k=c.debugInfo)==null?void 0:k.parsedPayload)==null?void 0:$.suggestedCurrentMapNodeId,A=c.debugInfo??null}else{const C=(()=>{const _=m(n.currentMapNodeId);return _?_.placeName:null})(),R=await td(e,t.mapData,i,C,n.localPlace,t.localPlace,{previousMapNodeId:n.currentMapNodeId,inventoryItems:t.inventory,knownNPCs:t.allNPCs});R&&(s=R.suggested,A=((L=R.mapUpdateResult)==null?void 0:L.debugInfo)??R.debugInfo,R.mapUpdateResult&&(c=R.mapUpdateResult))}a(N);let P=!1;if(c!=null&&c.updatedMapData&&c.updatedMapData!==t.mapData&&(t.mapData=c.updatedMapData,r.mapDataChanged=!0,P=!0),P&&u(),A&&t.lastDebugPacket&&(t.lastDebugPacket.mapUpdateDebugInfo=A),c&&c.newlyAddedNodes.length>0){for(const C of c.newlyAddedNodes)if(C.type!=="feature"){const _=m(C.id);if(_&&(!_.description||_.description.trim()===""||_.description.startsWith("Description missing"))){const W=o;a("corrections");const x=await _i(C.placeName,e.logMessage,"sceneDescription"in e?e.sceneDescription:n.currentScene,i);a(W),x&&(_.description=x.description,_.aliases=x.aliases??[],r.mapDataChanged=!0)}}}}const f=await nc(t.mapData.nodes,i,(E=c==null?void 0:c.debugInfo)==null?void 0:E.minimalModelCalls);fd(f,t,l)&&(r.mapDataChanged=!0,u());const v=new Set(((c==null?void 0:c.newlyAddedEdges)??[]).map(N=>N.id)),y="npcsAdded"in e&&e.npcsAdded?e.npcsAdded:[],w="npcsUpdated"in e&&e.npcsUpdated?e.npcsUpdated:[];(y.length>0||w.length>0)&&(r.npcChanges=sl(y,w,t.allNPCs),t.allNPCs=co(y,w,t.allNPCs));const h=n.currentMapNodeId;let T=h;const I=t.mapData.nodes;if(s){const N=ha(s,"mapAI",h,i.name,I);N.matched&&(T=N.nodeId)}if(!s&&"currentMapNodeId"in e&&e.currentMapNodeId){const N=ha(e.currentMapNodeId,"mainAI",h,i.name,I);N.matched&&(T=N.nodeId)}if(!s&&!("currentMapNodeId"in e&&e.currentMapNodeId)&&t.localPlace&&(T=gd(t.localPlace,t.mapData,h)??h),t.currentMapNodeId=T,t.currentMapNodeId!==h&&(r.currentMapNodeIdChanged=!0),t.currentMapNodeId&&t.destinationNodeId){const N=l.get(t.currentMapNodeId),A=l.get(t.destinationNodeId);N&&A&&(N.id===A.id||Ur(N,A,l))&&(t.destinationNodeId=null)}if(t.currentMapNodeId){const N=m(t.currentMapNodeId);if(N){N.visited||(N.visited=!0,(N.status==="rumored"||N.status==="undiscovered")&&(N.status="discovered"),r.mapDataChanged=!0);const A=Ul(N,l);for(const P of A)P.visited||(P.visited=!0,(P.status==="rumored"||P.status==="undiscovered")&&(P.status="discovered"),r.mapDataChanged=!0)}}if(r.mapDataChanged){const N=new Set(t.mapData.nodes.filter(C=>C.visited).map(C=>C.id)),A=new Set,P=_l(t.mapData);d.forEach(C=>{v.has(C.id)||N.has(C.sourceNodeId)&&N.has(C.targetNodeId)&&(C.status==="rumored"||C.status==="removed")&&(jl(P,C.sourceNodeId,C.targetNodeId,C.id)?A.add(C.id):(C.status="open",r.mapDataChanged=!0))}),A.size>0&&(t.mapData.edges=t.mapData.edges.filter(C=>!A.has(C.id)),u())}return s},yd=({loadingReasonRef:e,setLoadingReason:t,setError:n})=>({processMapUpdates:b.useCallback(async(a,r,i,s)=>{try{await hd(a,r,i,e.current,t,s)}catch(c){throw n(c instanceof Error?c.message:String(c)),c}},[e,t,n])}),wd=`** SYSTEM INSTRUCTIONS: **
You are an AI assistant that converts item hints into explicit inventory actions for a text adventure game, specializing on regular items that are not written items.
Analyze the hints and optional new items JSON provided in the prompt.

Define any operations on existing items in the Player's Inventory, based on Player's Action and the Player Items Hint.
Define any operations on existing items at Locations, or in NPCs' inventories, according to Location Items Hint and NPCs Items Hint.
Define any transfers of existing items between NPCs' and Player's Inventories using the 'move' action.
Items described in the "World Items Hint" must be placed at their appropriate map node holderId using the 'create' action.

Allowed actions are: ${vo}.
CRITICALLY IMPORTANT: Use 'create' only when revealing or creating a **NEW** item at a specific location, specific NPC inventory, or in Player's inventory. You MUST 'create' *all* items in the New Items JSON and *only* the items in the New Items JSON. NEVER create items that are part of the Player's Inventory.
CRITICALLY IMPORTANT: When the hint instructs to create an item, but it is not in the New Items array, the array takes precedence, and the creation hint must be ignored. (Especially, if it seems to be a page, a book, a map, or a photo - don't worry, it'll be taken care of by the next AI after you who specializes on written items)
CRITICALLY IMPORTANT: Use 'move' when transferring an **EXISTING** item from one holder to another, or dropping/picking up the item at the current location.
CRITICALLY IMPORTANT: Use 'destroy' ONLY when the item is **IRREVERSIBLY** consumed, destroyed, or otherwise removed from the world. Never 'destroy' items if only some Known Use needs to be deleted.
Use 'change' to edit or delete existing Known Uses.
Use 'addDetails' to add new Known Uses or Tags.

## Example:

"observations": "",
"rationale": "",
"create": [
    { // Example for gaining a *new* item from the provided New Items JSON:
        "activeDescription": "The lantern is lit and casts a warm glow.",
        "description": "A dusty old lantern that still flickers faintly.",
        "holderId": "player",
        "isActive": false,
        "knownUses": [
            {
              "actionName": "Light the Lantern",
              "appliesWhenInactive": true,
              "description": "Use this to light your way in dark places.",
              "promptEffect": "Light the lantern to illuminate the area."
            },
            {
              "actionName": "Extinguish the Lantern",
              "appliesWhenActive": true,
              "description": "Extinguish and conserve the fuel",
              "promptEffect": "Extinguish the lantern."
            }
        ],
        "name": "Old Lantern",
        "type": "equipment"
    }
],
"destroy": [
    { // Example for losing, destroying, completely removing an *existing* item from the world:
        "id": "item-old-lantern-7fr4",
        "name": "Old Lantern (flickering)"
    }
],
"move": [
    { // Example for giving an *existing* item item-iron-sword-ab12 from player to npc-guard-4f3a, or for placing it in the current location:
        "id": "item-iron-sword-ab12",
        "name": "Iron Sword",
        "newHolderId": "npc-guard-4f3a"
    },
    { // Example of taking an *existing* item item-coin-pouch-8f2c from npc-bandit-1wrc and putting it in player's inventory:
        "id": "item-coin-pouch-8f2c",
        "name": "Coin Pouch",
        "newHolderId": "player"
    },
    { // Example of picking up an *existing* item item-crowbar-55nf from node-rubble-pile-f4s3 and putting it in player's inventory:
        "id": "item-crowbar-55nf",
        "name": "Crowbar",
        "newHolderId": "player"
    }
],
"change": [
    { // Example for a simple change that only alters "isActive" state (lighting the Plasma Torch). All other properties are inherited from the *existing* item item-plasma-torch-7fr4:
        "id": "item-plasma-torch-7fr4",
        "isActive": true,
        "name": "Plasma Torch"
    },
    { // Example for transformation or crafting (new item details can be partial and will inherit old properties):
        "description": "A sharp piece of metal.",
        "id": "item-scrap-metal-7fr4",
        "knownUses": [
            {
                "actionName": "Cut",
                "description": "Use this to cut things.",
                "promptEffect": "Cut something with the shiv."
            }
        ],
        "name": "Scrap Metal",
        "newName": "Makeshift Shiv",
        "tags": [], /* empty array to remove the 'junk' tag from scrap metal */
        "type": "weapon"
    },
    { // Example for clearing the special active description text on an existing item:
        "activeDescription": null,
        "id": "item-old-lantern-7fr4",
        "isActive": false,
        "name": "Old Lantern"
    }
],
addDetails: [
    { // Example for adding a known use to *existing* item (existing properties and known uses are inherited):
        "id": "item-mystic-orb-7fr4",    
        "knownUses": {
            "actionName": "Peer into the Orb",
            "AppliesWhenActive": true,
            "description": "Try to see the beyond",
            "promptEffect": "Peer into the Mystic Orb, trying to glimpse the future."
        },
        "name": "Mystic Orb"
    }
]

- CRITICALLY IMPORTANT: holderId and newHolderId can only be 'node-*', 'npc-*' or 'player'. NEVER put an item inside another item!
- ALWAYS appropriately handle spending single-use items and state toggles ("isActive": true/false).
- Using some "single-use" items (food, water, medicine, etc) MUST add or remove appropriate "status effect" items.
- Use "change" to update the remaining number of uses for multi-use items in their name (in brackets) or in description.
IMPORTANT: For items that CLEARLY can be enabled or disabled (e.g., light sources, powered equipment, wielded or worn items) provide at least the two knownUses to enable and disable them with appropriate names:
  - The knownUse to turn on, light, or otherwise enable the item should ALWAYS have "appliesWhenInactive": true (and typically "appliesWhenActive": false or undefined).
  - The knownUse to turn off, extinguish, or disable the item should ALWAYS have "appliesWhenActive": true (and typically "appliesWhenInactive": false or undefined).
  - ALWAYS provide these actions in pairs, e.g. turn on/turn off, wield/put away, wear/take off, light/extinguish, activate/deactivate, start/stop, etc.
IMPORTANT: NEVER add ${Pn} known uses - there are dedicated buttons for those in the game.
IMPORTANT: To clear an item's special active description, set "activeDescription": null inside a "change" action.
IMPORTANT: When you clear the special active description, also set "isActive": false for that item.

${Ja}

`,vd=e=>{const t=new Set(Jt);return e.filter(n=>t.has(n.type))},Id=e=>{const t=new Map;return e.forEach(n=>{if(!n.holderId)return;const o=t.get(n.holderId);o?o.push(n):t.set(n.holderId,[n])}),t},wa=(e,t,n)=>{if(e.length===0)return{promptSection:"",correctionContext:"None."};const o=[],a=[];e.forEach((s,c)=>{const l=n.get(s.id)??[],d=`ID: ${s.id} - ${s.name}: `,u=`${c===0?`${t}
`:""}${d}`,m=Ue(l,gt,u,`
`);if(m){o.push(m);const p=Ue(l,gt,d);a.push(p||`${d}None.`)}else o.push(`${u}None.
`),a.push(`${d}None.`)});const r=o.join(""),i=a.length>0?a.join(`
`):"None.";return{promptSection:r.trim().length>0?r:"",correctionContext:i}},Nd=(e,t,n,o,a,r,i,s,c)=>{const l=vd(r),d=Id(l),u=s.filter(k=>k.presenceStatus==="companion"),m=s.filter(k=>k.presenceStatus==="nearby"),p=d.get(se)??[],g=Ue(p,gt,`Current Player Inventory:
`,`
`),f=i?d.get(i)??[]:[],v=Ue(f,gt,`Current Location Inventory - ID: ${i??"unknown"}
`,`
`),y=wa(u,"Companions Inventory:",d),w=wa(m,"Nearby NPCs Inventory:",d),h=a.filter(k=>Jt.includes(k.type)),T=`New Items from Storyteller AI or Dialogue AI:
${JSON.stringify(h,null,2)}
`,I=[];I.push(T),g&&I.push(`${g}
`),v&&I.push(`${v}
`),y.promptSection&&I.push(y.promptSection),w.promptSection&&I.push(w.promptSection),c&&I.push(`Nearby Map Context where you can put Items:
${c}
`);const S=I.join("");return{prompt:`- Player's Last Action: ${e}
- Player Items Hint: "${t}";
- World Items Hint: "${n}";
- NPC Items Hint: "${o}".

${S}
Provide the inventory update as JSON as described in the SYSTEM_INSTRUCTION.`,companionsContext:y.correctionContext,nearbyNpcsContext:w.correctionContext}};var bd={};const Ad={type:"object",properties:{observations:{type:"string",minLength:500,description:"Contextually relevant observations about the items."},rationale:{type:"string",minLength:500,description:"Reasoning behind the inventory changes."},addDetails:{type:"array",description:"Add new knownUses, or tags to an existing item.",items:{type:"object",properties:{id:{type:"string",description:"ID of the item like item-* ."},knownUses:{type:"array",description:"Additional Known Uses to be added to the item.",items:{type:"object",properties:{actionName:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"},description:{type:"string"},promptEffect:{type:"string"}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Name of the item."},tags:{type:"array",maxItems:1,items:{enum:[lt]},description:`Additional tags. One of ${Bn}`}},propertyOrdering:["id","knownUses","name","tags"],required:["id","name"],additionalProperties:!1}},change:{type:"array",description:"Updates to existing items.",items:{type:"object",properties:{activeDescription:{type:["string","null"],description:"Updated active description. Use null to clear the current active description."},description:{type:"string",description:"Updated description if changed."},id:{type:"string",description:"Identifier of the item to change."},isActive:{type:"boolean",description:"True if the item becomes active, worn, wielded, etc. False otherwise."},knownUses:{type:"array",description:"Edited set of Known Uses. For example, if an obsolete Known Use has to be removed, or an existing Known Use has to be changed. If provided, this array fully replaces the existing Known Uses.",items:{type:"object",properties:{actionName:{type:"string"},appliesWhenActive:{type:"boolean"},appliesWhenInactive:{type:"boolean"},description:{type:"string"},promptEffect:{type:"string"}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Current item name."},newName:{type:"string",description:"Updated name if changed."},tags:{type:"array",maxItems:1,items:{enum:lt},description:`Replacement tags. One of ${Bn}`},type:{enum:Jt,description:`Updated type if changed. One of ${no}.`}},propertyOrdering:["activeDescription","description","id","isActive","knownUses","name","newName","tags","type"],required:["id","name"],additionalProperties:!1}},create:{type:"array",description:"New items to create, taken exactly from the provided New Items JSON",items:{type:"object",properties:{activeDescription:{type:"string",description:"Description when item is active."},description:{type:"string",description:"Concise explanation of what the item is."},holderId:{type:"string",description:`ID of the location or holder. Use '${se}', 'npc-*' or 'node-*', depending on Item Hints.`},isActive:{type:"boolean",description:"True if the item is active, worn, wielded right now."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},appliesWhenActive:{type:"boolean",description:"Use is available when item is active."},appliesWhenInactive:{type:"boolean",description:"Use is available when item is inactive."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","appliesWhenActive","appliesWhenInactive","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",maxItems:1,items:{enum:lt},description:`Allowed tags: ${Bn}.`},type:{enum:Jt,description:`Item type. One of ${no}`}},propertyOrdering:["activeDescription","description","holderId","isActive","knownUses","name","tags","type"],required:["description","holderId","name","tags","type"],additionalProperties:!1}},destroy:{type:"array",items:{type:"object",description:"Remove items from the world.",properties:{id:{type:"string"},name:{type:"string"}},propertyOrdering:["id","name"],required:["id","name"],additionalProperties:!1}},move:{type:"array",items:{type:"object",description:"Move an existing item to a new holder.",properties:{id:{type:"string"},name:{type:"string"},newHolderId:{type:"string",description:`ID of the new location or holder of the Item. Use '${se}', 'npc-*' or 'node-*'.`}},propertyOrdering:["id","name","newHolderId"],required:["id","name","newHolderId"],additionalProperties:!1}}},required:["observations","rationale"],propertyOrdering:["observations","rationale","addDetails","change","create","destroy","move"],additionalProperties:!1},Sd=async e=>{if(!ee()&&(console.error("API Key not configured for Inventory Service."),!bd.VITEST))return Promise.reject(new Error("API Key not configured."));const t=await ie(async n=>{var o,a,r;try{console.log(`Executing inventory request (Attempt ${String(n+1)}/${String(B+1)})`),ae(ne.inventory_updates.icon);const i=Se(1024),{response:s,systemInstructionUsed:c,jsonSchemaUsed:l,promptUsed:d}=await oe({modelNames:[Q,z,be],prompt:e,systemInstruction:wd,jsonSchema:Ad,thinkingBudget:i,includeThoughts:!0,responseMimeType:"application/json",temperature:.7,label:"Inventory"}),m=(((r=(a=(o=s.candidates)==null?void 0:o[0])==null?void 0:a.content)==null?void 0:r.parts)??[]).filter(p=>p.thought===!0&&typeof p.text=="string").map(p=>p.text);return{result:{response:s,thoughts:m,systemInstructionUsed:c,jsonSchemaUsed:l,promptUsed:d}}}catch(i){throw console.error(`Error executing inventory request (Attempt ${String(n+1)}/${String(B+1)}):`,i),i}});if(!t)throw new Error("Failed to execute inventory request.");return t},Td=async(e,t,n,o,a,r,i,s,c,l,d,u)=>{const m=(e==null?void 0:e.trim())??"",p=(t==null?void 0:t.trim())??"",g=(n==null?void 0:n.trim())??"";if(!m&&!p&&!g&&o.length===0)return{itemChanges:[],debugInfo:null};const{prompt:f,companionsContext:v,nearbyNpcsContext:y}=Nd(a,m,p,g,o,r,i,s,u);let w=f,h=null,T=null,I=null,S=[],M,k,$=w;for(let E=0;E<=B;E+=1){const{response:N,thoughts:A,systemInstructionUsed:P,jsonSchemaUsed:C,promptUsed:R}=await Sd(w);I=N,S=A,M=P,k=C,$=R;let _=null;if(h=Ro(N.text??"",W=>{_=W}),!h){const W=await $c(N.text??"",l,c,m,p,g,i,v,y,d);W&&(h={itemChanges:W})}if(h){for(const W of h.itemChanges)if(W.action==="addDetails"&&W.invalidPayload){const x=await Ui(JSON.stringify(W.invalidPayload),l,c,d);x&&(W.item=x,delete W.invalidPayload)}T=null;break}if(typeof _=="string"?T=_:T="Inventory response did not match the expected JSON schema. Return only valid item change entries.",E===B)break;w=`${f}

[Parser Feedback]
${T}`}const L=T??void 0;return{itemChanges:h?h.itemChanges:[],debugInfo:{prompt:$,systemInstruction:M,jsonSchema:k,rawResponse:(I==null?void 0:I.text)??"",parsedItemChanges:h?h.itemChanges:void 0,observations:h==null?void 0:h.observations,rationale:h==null?void 0:h.rationale,thoughts:S,validationError:L}}},Gr=`** SYSTEM INSTRUCTIONS: **
You are an AI assistant that converts item hints into explicit inventory actions for a text adventure game.
Analyze the Librarian Hint and optional new items JSON provided in the prompt.

Define any operations on existing items in the Player's Inventory, based on Player's Action and the Librarian Hint.
Define any operations on existing items at Locations, or in NPCs' inventories, according to Librarian Hint.
Define any transfers of existing items between NPCs' and Player's Inventories using the 'move' action.

Allowed actions are: ${vo}.
Allowed item types are: ${un}
CRITICALLY IMPORTANT: Use 'create' only when revealing or creating a **NEW** item at a specific location, specific NPC inventory, or in Player's inventory. You MUST 'create' *all* items in the New Items JSON and *only* the items in the New Items JSON. NEVER create items that are part of the Player's Inventory.
CRITICALLY IMPORTANT: When the hint instructs to create an item, but it is not in the New Items array, the array takes precedence, and the creation hint must be ignored.
CRITICALLY IMPORTANT: Use 'move' when transferring an **EXISTING** item from one holder to another, or dropping/picking up the item at the current location.
CRITICALLY IMPORTANT: Use 'destroy' ONLY when the item is **IRREVERSIBLY** consumed, destroyed, or otherwise removed from the world.

## Examples:

observations: "",
rationale: "",
"create": [
    { // Example of gaining a new book with chapters:
        "chapters": [
            {
                "contentLength": 100,
                "description": "The first steps of an adventurer's journey.",
                "heading": "Chapter 1: The Beginning"
            },
            {
                "contentLength": 150,
                "description": "Facing challenges and overcoming obstacles.",
                "heading": "Chapter 2: The Trials"
            },
            {
                "contentLength": 200,
                "description": "The final victory and lessons learned.",
                "heading": "Chapter 3: The Triumph"
            }
        ],
        "description": "A personal recollection filled with the adventures of a seasoned explorer.",
        "holderId": "player",
        "name": "Adventurer's Path",
        "tags": ["handwritten"],
        "type": "book"
    }
],
"destroy": [
    { // Example for losing, destroying, completely removing an *existing* written item from the world:
        "id": "item-smudged-note-7fr4",
        "name": "Smudged Note"
    }
],
"move": [
    { // Example for giving an *existing* item item-old-map-ab12 from player to npc-guard-4f3a, or for placing it in the current location:
        "id": "item-old-map-ab12",
        "name": "Old Map",
        "newHolderId": "npc-guard-4f3a"
    },
    { // Example of taking an *existing* item item-family-portrait-8f2c from npc-bandit-1wrc and putting it in player's inventory:
        "id": "item-family-portrait-8f2c",
        "name": "Family Portrait",
        "newHolderId": "player"
    },
    { // Example of picking up an *existing* item item-cryptic-page-55nf from node-rubble-pile-f4s3 and putting it in player's inventory:
        "id": "item-cryptic-page-55nf",
        "name": "Cryptic Page",
        "newHolderId": "player"
    }
],
"change": [
    { // Example for adding a known use to an *existing* map (existing properties and known uses are inherited):
        "addKnownUse": {
            "actionName": "Translate Map",
            "description": "Attempt to decipher the foreign notes.",
            "promptEffect": "Study the map to translate its markings."
        },
        "id": "item-ancient-map-7fr4",
        "name": "Ancient Map"
    }
],
"addDetails": [
    { // Example for adding a new chapter to an existing written item:
        "chapters": [
            {
            "contentLength": 120,
            "description": "A grim tale about the price of forbidden knowledge.",
            "heading": "The Sacrifice of Silence"
            }
        ],
        "id": "item-codex-of-whispering-echoes-8g3c",
        "name": "The Codex of Whispering Echoes"
    }
]

- CRITICALLY IMPORTANT: holderId and newHolderId can only be 'node-*', 'npc-*' or 'player'. NEVER put an item inside another item!
- Use "addDetails" to reveal new chapters only when Librarian Hint directly instructs you to, for example when missing pages of a book are found and incorporated into the partial book, or some natural or magical process adds the text onto previously blank pages, or if a book equivalent digital device receives an additional fragment of text.
- Make sure that 'page', 'map' and 'picture' type items have exactly ONE chapter.
- Make sure that 'book' type items have between ${String(Cn)} and ${String(En)} chapters.
- Make sure items have one of the required tags: ${fo}.
IMPORTANT: NEVER add ${Pn} known uses - there are dedicated buttons for those in the game.

${qa}

`,Pd=e=>{const t=new Set($e);return e.filter(n=>t.has(n.type))},Cd=e=>{const t=new Map;return e.forEach(n=>{if(!n.holderId)return;const o=t.get(n.holderId);o?o.push(n):t.set(n.holderId,[n])}),t},va=(e,t,n)=>{if(e.length===0)return"";const o=[];return e.forEach((a,r)=>{const i=n.get(a.id)??[],s=`ID: ${a.id} - ${a.name}: `,c=`${r===0?`${t}
`:""}${s}`,l=Ue(i,gt,c,`
`);l?o.push(l):o.push(`${c}None.
`)}),o.join("")},Ed=(e,t,n,o,a,r,i)=>{const s=Pd(o),c=Cd(s),l=r.filter(I=>I.presenceStatus==="companion"),d=r.filter(I=>I.presenceStatus==="nearby"),u=c.get(se)??[],m=Ue(u,gt,`Current Player Inventory:
`,`
`),p=a?c.get(a)??[]:[],g=Ue(p,gt,`Current Location Inventory - ID: ${a??"unknown"}
`,`
`),f=va(l,"Companions Inventory:",c),v=va(d,"Nearby NPCs Inventory:",c),y=n.filter(I=>$e.includes(I.type)),w=`New Items from Storyteller AI or Dialogue AI:
${JSON.stringify(y,null,2)}
`,h=[];h.push(w),m&&h.push(`${m}
`),g&&h.push(`${g}
`),f&&h.push(f),v&&h.push(v),i&&h.push(`Nearby Map Context where you can put Items:
${i}
`);const T=h.join("");return`- Player's Last Action: ${e}
- Librarian Hint: "${t}".

${T}
Provide the librarian update as JSON as described in the SYSTEM_INSTRUCTION.`},kd={type:"object",properties:{observations:{type:"string",minLength:500,description:"Contextually relevant observations about the items."},rationale:{type:"string",minLength:500,description:"Reasoning behind the inventory changes."},addDetails:{type:"array",description:"Add new knownUses, chapters, or tags to an existing item.",items:{type:"object",properties:{chapters:{type:"array",description:"Only add chapters if Librarian Hint directly instructs that.",items:{type:"object",properties:{contentLength:{type:"number",minimum:50,maximum:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},id:{type:"string",description:"ID of the item like item-* ."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Name of the item."},tags:{type:"array",description:"Set 'recovered' tag if the item has been translated, decoded, or restored.",maxItems:1,items:{enum:["recovered"]}}},propertyOrdering:["chapters","id","knownUses","name","tags"],required:["id","name"],additionalProperties:!1}},change:{type:"array",description:"Update existing items.",items:{type:"object",properties:{description:{type:"string",description:"Updated description if changed."},id:{type:"string",description:"ID of the item to change."},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Current item name."},newName:{type:"string",description:"Updated name if changed."},tags:{type:"array",maxItems:5,items:{enum:mn},description:`Updated tags. Allowed tags: ${Ko}.`},type:{enum:$e,description:`Updated type if changed. One of ${un}.`}},propertyOrdering:["description","id","knownUses","name","newName","tags","type"],required:["id","name"],additionalProperties:!1}},create:{type:"array",description:"New items to create, taken exactly from the provided New Items JSON",items:{type:"object",properties:{chapters:{type:"array",description:`For type page, map, or picture - exactly one chapter. For type book - between ${String(Cn)} and ${String(En)} chapters.`,items:{type:"object",properties:{contentLength:{type:"number",minimum:50,maximum:500,description:"Approximate length in words."},description:{type:"string",description:"Detailed abstract of the chapter contents."},heading:{type:"string",description:"Short heading for the chapter."}},propertyOrdering:["contentLength","description","heading"],required:["contentLength","description","heading"],additionalProperties:!1}},description:{type:"string",description:"Concise explanation of what the item is."},holderId:{type:"string",description:`ID of the location or holder. Use '${se}', 'npc-*' or 'node-*', depending on Librarian Hints.`},knownUses:{type:"array",items:{type:"object",properties:{actionName:{type:"string",description:"Name of the use action."},description:{type:"string",description:"Tooltip hint for this use."},promptEffect:{type:"string",description:"Short effect description for the AI."}},propertyOrdering:["actionName","description","promptEffect"],required:["actionName","description","promptEffect"],additionalProperties:!1}},name:{type:"string",description:"Item name as it will appear to the player."},tags:{type:"array",maxItems:5,items:{enum:mn},description:`Allowed tags: ${Ko}.`},type:{enum:$e,description:`Item type. One of ${un}`}},propertyOrdering:["chapters","description","holderId","knownUses","name","tags","type"],required:["chapters","description","holderId","name","tags","type"],additionalProperties:!1}},destroy:{type:"array",items:{type:"object",description:"Remove items from the world.",properties:{id:{type:"string"},name:{type:"string"}},propertyOrdering:["id","name"],required:["id","name"],additionalProperties:!1}},move:{type:"array",items:{type:"object",description:"Move an existing item to a new holder.",properties:{id:{type:"string"},name:{type:"string"},newHolderId:{type:"string",description:`ID of the new location or holder of the Item. Use '${se}', 'npc-*' or 'node-*'.`}},propertyOrdering:["id","name","newHolderId"],required:["id","name","newHolderId"],additionalProperties:!1}}},required:["observations","rationale"],propertyOrdering:["observations","rationale","addDetails","change","create","destroy","move"],additionalProperties:!1},Md=async e=>ee()?await ie(async()=>{var l,d,u;ae(ne.librarian_updates.icon);const n=Se(1024),{response:o,systemInstructionUsed:a,jsonSchemaUsed:r,promptUsed:i}=await oe({modelNames:[Q,z,be],prompt:e,systemInstruction:Gr,jsonSchema:kd,thinkingBudget:n,includeThoughts:!0,responseMimeType:"application/json",temperature:.7,label:"Librarian"}),c=(((u=(d=(l=o.candidates)==null?void 0:l[0])==null?void 0:d.content)==null?void 0:u.parts)??[]).filter(m=>m.thought===!0&&typeof m.text=="string").map(m=>m.text);return{result:{response:o,thoughts:c,systemInstructionUsed:a,jsonSchemaUsed:r,promptUsed:i}}}):Promise.reject(new Error("API key not configured.")),$d=async(e,t,n,o,a,r,i)=>{const s=(e==null?void 0:e.trim())??"";if(!s&&t.length===0)return{itemChanges:[],debugInfo:null};const c=Ed(n,s,t,o,a,r,i);let l=c,d=null,u=null,m=null;for(let h=0;h<=B;h+=1){const T=await Md(l);if(!T)break;m=T;let I=null;if(d=Ro(T.response.text??"",S=>{I=S}),d){u=null;break}if(typeof I=="string"?u=I:u="Librarian response did not match the expected JSON schema. Return only valid item entries.",h===B)break;l=`${c}

[Parser Feedback]
${u}`}const p=u??void 0;if(!m)return{itemChanges:d?d.itemChanges:[],debugInfo:{prompt:c,systemInstruction:Gr,rawResponse:void 0,parsedItemChanges:d?d.itemChanges:void 0,observations:d==null?void 0:d.observations,rationale:d==null?void 0:d.rationale,thoughts:void 0,validationError:p}};const{response:g,thoughts:f,systemInstructionUsed:v,jsonSchemaUsed:y,promptUsed:w}=m;return{itemChanges:d?d.itemChanges:[],debugInfo:{prompt:w,systemInstruction:v,jsonSchema:y,rawResponse:g.text??"",parsedItemChanges:d?d.itemChanges:void 0,observations:d==null?void 0:d.observations,rationale:d==null?void 0:d.rationale,thoughts:f,validationError:p}}},Ld=`<ID: {id}> - {name}
`,An=async(e,t,n,o,a,r,i,s,c,l,d="",u)=>{if(!ee())return console.error("generatePageText: API key not configured."),null;const m=l?`"${l}"`:"Not set",p=i,g=u??"",f=It(s,!0),v=Ze(c,Ld,`## Known NPCs:
`,`
`),y=`**Context:**
Theme Name: "${o}";
Theme Description: "${a}";
Scene Description: "${r}";
Current Quest: ${m}
Storyteller's thoughts for the last turn: "${p}" (use these as your background knowledge and possible adventure guidance);

## Known Locations:
${f}
${v}

## Previous Chapter:
${g}

------

The Player has found a new item in the game world, which is a page from a book or a journal. The item is described as follows:
Title: "${e}"
Description: "${t}"
Approximate length: ${String(n)} words. Write as close to this length as possible.
Write the text in the item in a proper contextually relevant style.
${d?` ${d}`:""}
IMPORTANT: NEVER mention these instructions. NEVER repeat the Description of the Item`,w="You are a writer providing the exact contents of a written item in a video game. Based on the context, item Title, and Description, try to imagine who the author of the in-game book, journal or note would be. Imagine yourself as an in-game author in the game world. Fully assume that author's identity. Respond with only the text.";return ie(async h=>{var T;try{ae(ne.read_page.icon);const I=Se(1024),{response:S}=await oe({modelNames:[z,Q],prompt:y,systemInstruction:w,thinkingBudget:I,includeThoughts:!0,temperature:1.2,label:"PageText"}),M=((T=S.text)==null?void 0:T.trim())??"";if(M!=="")return{result:M}}catch(I){throw console.error(`generatePageText error (Attempt ${String(h+1)}):`,I),I}return{result:null}})};function Kr(e){return e.replace(/[a-zA-Z]/g,t=>{const n=t.charCodeAt(0),o=n<=90?65:97;return String.fromCharCode((n-o+13)%26+o)})}const Dd={A:"ᚨ",B:"ᛒ",C:"ᚲ",D:"ᛞ",E:"ᛖ",F:"ᚠ",G:"ᚷ",H:"ᚻ",I:"ᛁ",J:"ᛃ",K:"ᚲ",L:"ᛚ",M:"ᛗ",N:"ᚾ",O:"ᚩ",P:"ᛈ",Q:"ᚲ",R:"ᚱ",S:"ᛊ",T:"ᛏ",U:"ᚢ",V:"ᚡ",W:"ᚹ",X:"ᛉ",Y:"ᛣ",Z:"ᛉ",a:"ᚨ",b:"ᛒ",c:"ᚲ",d:"ᛞ",e:"ᛖ",f:"ᚠ",g:"ᚷ",h:"ᚻ",i:"ᛁ",j:"ᛃ",k:"ᚲ",l:"ᛚ",m:"ᛗ",n:"ᚾ",o:"ᚩ",p:"ᛈ",q:"ᚲ",r:"ᚱ",s:"ᛊ",t:"ᛏ",u:"ᚢ",v:"ᚡ",w:"ᚹ",x:"ᛉ",y:"ᛣ",z:"ᛉ"};function Br(e){return e.split("").map(t=>Dd[t]??t).join("")}function Wr(e){const t=Math.floor(e.length/2),n=e.lastIndexOf(" ",t),o=e.indexOf(" ",t),a=n!==-1&&t-n<20?n:o!==-1&&o-t<20?o:t,r=Math.random()<.5,i=`
--- torn ---
`;return r?`${e.slice(0,a)}${i}`:`${i}${e.slice(a)}`}const Rd=(e,t)=>{const n=new Set;for(const o of t)o.action==="create"&&typeof o.item.name=="string"&&n.add(o.item.name.toLowerCase());return e.filter(o=>!(o.action==="create"&&typeof o.item.name=="string"&&n.has(o.item.name.toLowerCase())))},Yr=e=>{if(!e)return null;const t=e.toLowerCase().replace(/[.,!?;:"(){}[\]'’]/g,"").trim();return t.length>0?t:null},Hr=e=>{if(!e)return null;const t=e.trim().toLowerCase();return t.length>0?t:null},Yt=e=>{if(!e)return null;const t=Dt(e).trim().toLowerCase();return t.length>0?t:null},Od=e=>{const t=new Map,n=new Map;for(const l of e.mapData.nodes){t.set(l.id,l);const d=[l.placeName,...l.aliases??[]];for(const u of d){const m=Yr(u);m&&!n.has(m)&&n.set(m,l)}}const o=new Map,a=new Map;for(const l of e.allNPCs){o.set(l.id,l);const d=[l.name,...l.aliases??[]];for(const u of d){const m=Hr(u);m&&!a.has(m)&&a.set(m,l)}}const r=new Map,i=new Map,s=[],c=new Map;for(const l of e.inventory){r.set(l.id,l);const d=Yt(l.name);d&&!i.has(d)&&i.set(d,l),l.holderId===se&&(s.push(l),d&&!c.has(d)&&c.set(d,l))}return{nodesById:t,nodesByToken:n,npcsById:o,npcsByToken:a,inventoryById:r,inventoryByToken:i,playerInventory:s,playerInventoryByToken:c}},xd=(e,t,n)=>{var i;if(!e)return;const o=t.nodesById.get(e);if(o)return o.id;const a=Yr(e);if(a){const s=t.nodesByToken.get(a);if(s)return s.id}const r=je(e,n.mapData.nodes,n.mapData,n.currentMapNodeId);return Array.isArray(r)?(i=r[0])==null?void 0:i.id:r==null?void 0:r.id},Ud=(e,t,n)=>{var i;if(!e)return;const o=t.npcsById.get(e);if(o)return o.id;const a=Hr(e);if(a){const s=t.npcsByToken.get(a);if(s)return s.id}const r=On(e,n.allNPCs);return Array.isArray(r)?(i=r[0])==null?void 0:i.id:r==null?void 0:r.id},_d=(e,t,n,o=!1)=>{if(n.id){const i=e.inventoryById.get(n.id);if(i)return i}const a=Yt(n.name??null);if(a){const i=e.inventoryByToken.get(a);if(i)return i}const r=Fe([n.id,n.name],t.inventory,!1,o);return r?Array.isArray(r)?r[0]??null:r:null},Ia=(e,t)=>{if(t.id){const o=e.inventoryById.get(t.id);if(o&&o.holderId===se)return o}const n=Yt(t.name??null);if(n){const o=e.playerInventoryByToken.get(n);if(o)return o}return e.playerInventory.find(o=>{if(t.id&&o.id===t.id)return!0;const a=Yt(o.name),r=Yt(t.name??null);return a!==null&&a===r})},jd=async({aiItemChanges:e,aiData:t,baseState:n,playerActionText:o,loadingReason:a,setLoadingReason:r})=>{const i=n.theme,s=Od(n),c=[],l=new Map,d=[],u=["drop","dropped","leave","left","put down","set down","place","placed"],m=`${t.logMessage??""} ${"sceneDescription"in t?t.sceneDescription:""} ${o??""}`.toLowerCase(),p=u.some(f=>m.includes(f)),g=f=>{if(f){if(f===se)return se;if(f.startsWith("node-"))return xd(f,s,n);if(f.startsWith("npc-"))return Ud(f,s,n)}};if(e.forEach((f,v)=>{let y={...f};if(y.action==="create"){const w={...y.item},h=_d(s,n,{id:w.id,name:w.name},!0);if(h)y={action:"change",item:{...w,id:h.id}};else{const T=g(w.holderId);T&&(w.holderId=T),y={...y,item:w}}}else if(y.action==="move"){const w={...y.item},h=g(w.newHolderId);h&&(w.newHolderId=h),y={...y,item:w}}else if(y.action==="change"){const w={...y.item};if(w.holderId){const h=g(w.holderId);h&&(w.holderId=h)}y={...y,item:w}}if("item"in y&&y.item.type==="immovable"){if(y.action==="create"){const w=y.item;w.holderId.startsWith("node-")||(w.holderId=n.currentMapNodeId??"unknown")}else if(y.action==="move"){const w=y.item;w.newHolderId.startsWith("node-")||(w.newHolderId=n.currentMapNodeId??"unknown")}}if(y.action==="destroy"){const w={...y.item};if(!Ia(s,w)){const T=w.name??"",I=T.trim(),S=I.length>0?I.toLowerCase():"__empty__",M=l.get(S);M?M.indices.push(v):l.set(S,{originalName:T,indices:[v]})}d.push({index:v,shouldConvert:p}),y={...y,item:w}}c.push(y)}),l.size>0){const f=a;r("corrections");const v="sceneDescription"in t?t.sceneDescription:n.currentScene,y=s.playerInventory.map(T=>T.name),w=Array.from(l.values()),h=await Promise.all(w.map(T=>Ln("item",T.originalName,t.logMessage,v,y,i)));r(f),w.forEach((T,I)=>{const S=h[I];if(S)for(const M of T.indices){const k=c[M];k.action==="destroy"&&(k.item={id:S,name:S})}})}for(const f of d){if(!f.shouldConvert)continue;const v=c[f.index];if(v.action!=="destroy")continue;const y=v.item,w=Ia(s,y);w&&(c[f.index]={action:"create",item:{...w,holderId:n.currentMapNodeId??"unknown"}})}return c},Fd=async({aiData:e,draftState:t,baseState:n,turnChanges:o,processMapUpdates:a})=>{(e.mapUpdated===!0||t.localPlace!==n.localPlace)&&await a(e,t,n,o)},Vd=async({aiData:e,draftState:t,baseState:n,correctedItemChanges:o,playerActionText:a,loadingReason:r,setLoadingReason:i})=>{var M,k,$,L;const s=n.inventory.filter(E=>E.holderId===se),c=(E,N)=>E.filter(A=>N.includes(A.type));let l=[...o];const d=t.theme,u=r;i("inventory_updates");const m=Jo(t.mapData,t.currentMapNodeId,c(n.inventory,Jt)),p=Jo(t.mapData,t.currentMapNodeId,c(n.inventory,$e)),g="newItems"in e&&Array.isArray(e.newItems)?e.newItems:[],f=g.filter(E=>$e.includes(E.type)),v=g.filter(E=>!$e.includes(E.type)),y="playerItemsHint"in e?(M=e.playerItemsHint)==null?void 0:M.trim():"",w="worldItemsHint"in e?(k=e.worldItemsHint)==null?void 0:k.trim():"",h="npcItemsHint"in e?($=e.npcItemsHint)==null?void 0:$.trim():"";let T=null;(y||w||h||v.length>0)&&(T=await Td(y,w,h,v,a??"",n.inventory,n.currentMapNodeId??null,n.allNPCs,"sceneDescription"in e?e.sceneDescription:n.currentScene,e.logMessage,d,m)),i(u);let I="librarianHint"in e?(L=e.librarianHint)==null?void 0:L.trim():"";!I&&f.length>0&&(I=`Found ${f.map(N=>N.name).join(", ")}.`);let S=null;return I&&(t.turnState="librarian_updates",i("librarian_updates"),S=await $d(I,f,a??"",n.inventory,n.currentMapNodeId??null,n.allNPCs,p),i(u)),T&&S&&(T.itemChanges=Rd(T.itemChanges,S.itemChanges)),T&&(l=l.concat(T.itemChanges),t.lastDebugPacket&&(t.lastDebugPacket.inventoryDebugInfo=T.debugInfo)),S&&(l=l.concat(S.itemChanges),t.lastDebugPacket&&(t.lastDebugPacket.librarianDebugInfo=S.debugInfo)),{combinedItemChanges:l,baseInventoryForPlayer:s}},Na=(e,t,n)=>{"dialogueSetup"in t&&t.dialogueSetup?(e.actionOptions=[],e.dialogueState={participants:t.dialogueSetup.participants,history:t.dialogueSetup.initialNpcResponses,options:t.dialogueSetup.initialPlayerOptions},e.turnState="dialogue_turn"):n&&(e.dialogueState=null)},Gd=e=>({itemChanges:[],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:e,mapDataChanged:!1}),Kd=({draftState:e,turnChanges:t,setError:n,isFromDialogueSummary:o})=>{n("The Dungeon Master's connection is unstable... (Invalid AI response after retries)"),!o&&"actionOptions"in e&&(e.actionOptions=["Try to wait for the connection to improve.","Consult the ancient network spirits.","Check your own connection.","Sigh dramatically."]),e.lastActionLog="The Dungeon Master seems to be having trouble communicating the outcome of your last action.",e.localTime||(e.localTime="Time Unknown"),e.localEnvironment||(e.localEnvironment="Environment Undetermined"),e.localPlace||(e.localPlace="Undetermined Location"),e.lastTurnChanges=t,e.dialogueState=null},Bd=(e,t)=>{var n,o,a;e.lastDebugPacket={...e.lastDebugPacket??{},prompt:((n=e.lastDebugPacket)==null?void 0:n.prompt)??"Prompt not captured for this state transition",rawResponseText:((o=e.lastDebugPacket)==null?void 0:o.rawResponseText)??"Raw text not captured",parsedResponse:t,timestamp:new Date().toISOString(),mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:((a=e.lastDebugPacket)==null?void 0:a.loremasterDebugInfo)??{collect:null,extract:null,integrate:null,distill:null,journal:null}}},Wd=({aiData:e,draftState:t,turnChanges:n,clearObjectiveAnimationTimer:o,objectiveAnimationClearTimerRef:a,setGameStateStack:r})=>{e.localTime!==void 0&&(t.localTime!==e.localTime&&(n.localTimeChanged=!0),t.localTime=e.localTime),e.localEnvironment!==void 0&&(t.localEnvironment!==e.localEnvironment&&(n.localEnvironmentChanged=!0),t.localEnvironment=e.localEnvironment),e.localPlace!==void 0&&(t.localPlace!==e.localPlace&&(n.localPlaceChanged=!0),t.localPlace=e.localPlace),e.mainQuest!==void 0&&(t.mainQuest!==e.mainQuest&&(n.mainQuestTextChanged=!0),t.mainQuest=e.mainQuest);const i=t.currentObjective;e.currentObjective!==void 0&&(t.currentObjective!==e.currentObjective&&(n.objectiveTextChanged=!0),t.currentObjective=e.currentObjective),o();let s=null;e.currentObjective!==void 0&&e.currentObjective!==i?s=e.objectiveAchieved?"success":"neutral":e.objectiveAchieved&&i!==null&&(s="success"),s?(t.objectiveAnimationType=s,a.current=window.setTimeout(()=>{r(c=>[{...c[0],objectiveAnimationType:null},c[1]]),a.current=null},5e3)):t.objectiveAnimationType=null,n.objectiveAchieved=e.objectiveAchieved??!1,n.mainQuestAchieved=e.mainQuestAchieved??!1,e.objectiveAchieved&&(t.score=t.score+1,n.scoreChangedBy+=1)},Yd=({draftState:e,aiData:t,isFromDialogueSummary:n})=>{t.options.length>0&&!t.dialogueSetup?e.actionOptions=t.options:!n&&!t.dialogueSetup&&(e.actionOptions=["Look around.","Ponder your situation.","Check your inventory.","Wait for something to happen.","Consider your objective.","Plan your next steps."])},Hd=async({aiData:e,draftState:t,baseStateSnapshot:n,playerActionText:o,loadingReasonRef:a,setLoadingReason:r,turnChanges:i,processMapUpdates:s})=>{const c=await jd({aiItemChanges:e.itemChange,aiData:e,baseState:n,playerActionText:o,loadingReason:a.current,setLoadingReason:r});(e.mapUpdated===!0||t.localPlace!==n.localPlace)&&(t.turnState="map_updates",await Fd({aiData:e,draftState:t,baseState:n,turnChanges:i,processMapUpdates:s}));const d="newItems"in e&&Array.isArray(e.newItems)?e.newItems:[],u=d.some(y=>$e.includes(y.type)),m=d.some(y=>!$e.includes(y.type)),p=!!e.playerItemsHint||!!e.worldItemsHint||!!e.npcItemsHint||m,g=!!e.librarianHint||u;let f=c,v=n.inventory.filter(y=>y.holderId===se);if(p||g){p&&(t.turnState="inventory_updates");const y=await Vd({aiData:e,draftState:t,baseState:n,correctedItemChanges:c,playerActionText:o,loadingReason:a.current,setLoadingReason:r});f=y.combinedItemChanges,v=y.baseInventoryForPlayer}return{combinedItemChanges:f,baseInventoryForPlayer:v}},Jd=async({aiData:e,draftState:t,baseStateSnapshot:n,combinedItemChanges:o,baseInventoryForPlayer:a,turnChanges:r,forceEmptyInventory:i,themeContextForResponse:s,isFromDialogueSummary:c})=>{var l,d,u,m,p;r.itemChanges=bl(o,a),t.inventory=Al(o,i?[]:n.inventory),e.logMessage?(t.gameLog=lo(t.gameLog,e.logMessage,oo),t.lastActionLog=e.logMessage):c||(t.lastActionLog="The Dungeon Master remains silent on the outcome of your last action.");for(const g of o)if(g.action==="addDetails"){const f=Fe([g.item.id,g.item.name],t.inventory,!1,!0);if(!f)continue;const v=(l=g.item.chapters)==null?void 0:l[0];if(!v)continue;const{name:y,storyGuidance:w}=s,h=((u=(d=f.chapters)==null?void 0:d[f.chapters.length-1])==null?void 0:u.actualContent)??"",T=((p=(m=t.lastDebugPacket)==null?void 0:m.storytellerThoughts)==null?void 0:p.slice(-1)[0])??"",I=await An(v.heading,v.description,v.contentLength,y,w,t.currentScene,T,t.mapData.nodes,t.allNPCs,t.mainQuest,`Take into account: ${t.lastActionLog||""}`,h);if(!I)continue;const S=f.tags??[];let M=I;S.includes("foreign")?M=await An(v.heading,v.description,v.contentLength,y,w,t.currentScene,T,t.mapData.nodes,t.allNPCs,t.mainQuest,`Translate the following text into an artificial nonexistent language that fits the theme and context:
"""${I}"""`)??I:S.includes("encrypted")?M=Kr(I):S.includes("runic")&&(M=Br(I)),S.includes("torn")&&!S.includes("recovered")&&(M=Wr(M));const k={...v,actualContent:I,visibleContent:M},$=t.inventory.findIndex(E=>E.id===f.id),L={...f,chapters:[...f.chapters??[],k],lastInspectTurn:void 0};t.inventory[$]=L}},qd=async({aiData:e,draftState:t,options:n,themeContextForResponse:o,playerActionText:a,loadingReasonRef:r,setLoadingReason:i,debugLore:s,openDebugLoreModal:c,actIntroRef:l,onActIntro:d})=>{var I,S,M,k,$,L,E,N;t.turnState=n.isFromDialogueSummary?"dialogue_summary":"loremaster_extract",(I=n.onBeforeRefine)==null||I.call(n,Z(t)),(S=n.setIsLoading)==null||S.call(n,!1),(M=n.setIsTurnProcessing)==null||M.call(n,!0);const u=(($=(k=t.lastDebugPacket)==null?void 0:k.storytellerThoughts)==null?void 0:$.join(`
`))??"",m=n.isFromDialogueSummary?[n.dialogueTranscript??"",u?`
  ## Storyteller's Thoughts:
${u}
------`:""].filter(Boolean).join(`
`):[a?`Action: ${a}`:"",e.sceneDescription,e.logMessage??"",u?`
  ## Storyteller's Thoughts:

${u}
------`:""].filter(Boolean).join(`
`),p=t.mapData.nodes.filter(A=>A.type!=="feature"&&A.type!=="room"),g=t.allNPCs,f=t.inventory.filter(A=>A.holderId===se||p.some(P=>P.id===A.holderId)||g.some(P=>P.id===A.holderId)),v=[`Node IDs: ${p.map(A=>A.id).join(", ")}`,`NPC IDs: ${g.map(A=>A.id).join(", ")}`,`Item IDs: ${f.map(A=>A.id).join(", ")}`].join(`
`),y=`${m}
${v}`;l.current&&(d(l.current),l.current=null);const w=r.current,h=await rl({themeName:o.name,turnContext:y,existingFacts:t.loreFacts,logMessage:e.logMessage??"",currentScene:e.sceneDescription,onFactsExtracted:s?async A=>new Promise(P=>{c(A.map(C=>C.text),(C,R,_)=>{_&&(t.debugGoodFacts.push(...C),t.debugBadFacts.push(...R)),P({proceed:_})})}):void 0,onSetLoadingReason:i}),T=(L=t.lastDebugPacket)==null?void 0:L.loremasterDebugInfo;T&&(T.extract=((E=h==null?void 0:h.debugInfo)==null?void 0:E.extract)??null,T.integrate=((N=h==null?void 0:h.debugInfo)==null?void 0:N.integrate)??null),h!=null&&h.refinementResult&&xn(t,h.refinementResult.factsChange,t.globalTurnNumber),i(w)},zd=({loadingReasonRef:e,setLoadingReason:t,setError:n,setGameStateStack:o,debugLore:a,openDebugLoreModal:r,actIntroRef:i,onActIntro:s})=>{const{processMapUpdates:c}=yd({loadingReasonRef:e,setLoadingReason:t,setError:n}),l=b.useRef(null),d=b.useCallback(()=>{l.current&&(clearTimeout(l.current),l.current=null)},[]);return{processAiResponse:b.useCallback(async(m,p,g)=>{const{baseStateSnapshot:f,isFromDialogueSummary:v=!1,scoreChangeFromAction:y=0,playerActionText:w}=g,h=Gd(y),T=p.theme;if(!m){Kd({draftState:p,turnChanges:h,setError:n,isFromDialogueSummary:v});return}if(Bd(p,m),"sceneDescription"in m&&m.sceneDescription&&(p.currentScene=m.sceneDescription),Wd({aiData:m,draftState:p,turnChanges:h,clearObjectiveAnimationTimer:d,objectiveAnimationClearTimerRef:l,setGameStateStack:o}),Yd({draftState:p,aiData:m,isFromDialogueSummary:v}),m.dialogueSetup){Na(p,m,!1),p.lastTurnChanges=h;return}const{combinedItemChanges:I,baseInventoryForPlayer:S}=await Hd({aiData:m,draftState:p,baseStateSnapshot:f,playerActionText:w,loadingReasonRef:e,setLoadingReason:t,turnChanges:h,processMapUpdates:c});await Jd({aiData:m,draftState:p,baseStateSnapshot:f,combinedItemChanges:I,baseInventoryForPlayer:S,turnChanges:h,forceEmptyInventory:g.forceEmptyInventory,themeContextForResponse:T,isFromDialogueSummary:v}),await qd({aiData:m,draftState:p,options:g,themeContextForResponse:T,playerActionText:w,loadingReasonRef:e,setLoadingReason:t,debugLore:a,openDebugLoreModal:r,actIntroRef:i,onActIntro:s}),Na(p,m,v),p.lastTurnChanges=h,g.isFromDialogueSummary||(p.turnState="awaiting_input")},[e,t,n,o,c,d,a,r,i,s]),clearObjectiveAnimationTimer:d}},ba=(e,t)=>{let n=e,o=2;for(;t.some(a=>a.heading===n);)n=`${e} (${String(o)})`,o+=1;return n},Qd=({getCurrentGameState:e,commitGameState:t,isLoading:n})=>{const o=b.useRef(e);b.useEffect(()=>{o.current=e},[e]);const a=b.useCallback((f,v)=>{var k;const y=e();if(n||y.dialogueState)return;const w=y.inventory.find($=>$.id===f&&$.holderId===se);if(!w)return;const h=Z(y),T=y.currentMapNodeId??"unknown";h.inventory=h.inventory.map($=>{if($.id!==f||$.holderId!==se)return $;const L=$e.includes($.type);return{...$,holderId:T,...L?{stashed:!1}:{}}});const S={itemChanges:[{type:"loss",lostItem:{...w}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};h.lastTurnChanges=S;let M=v;if(!M){const $=((k=y.mapData.nodes.find(L=>L.id===T))==null?void 0:k.placeName)??y.localPlace;w.type==="vehicle"&&!w.isActive?M=`You left your ${w.name} parked at ${$}.`:M=`You left your ${w.name} at ${$}.`}M&&(h.gameLog=lo(h.gameLog,M,oo),h.lastActionLog=M),t(h)},[e,t,n]),r=b.useCallback(f=>{const v=e();if(n||v.dialogueState)return;const y=v.inventory.find(S=>S.id===f&&S.holderId===se);if(!y)return;const w=Z(v);w.inventory=w.inventory.filter(S=>!(S.id===f&&S.holderId===se));const T={itemChanges:[{type:"loss",lostItem:{...y}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};w.lastTurnChanges=T;const I=`You discarded the ${y.name}.`;w.gameLog=lo(w.gameLog,I,oo),w.lastActionLog=I,t(w)},[e,t,n]),i=b.useCallback(f=>{const v=e();if(n||v.dialogueState)return;const y=v.currentMapNodeId;if(!y)return;const w=_r(v.mapData,y),h=v.inventory.find(M=>M.id!==f?!1:M.holderId===y?!0:w.includes(M.holderId));if(!h)return;const T=Z(v);T.inventory=T.inventory.map(M=>M.id===f&&M.holderId===h.holderId?{...M,holderId:se}:M);const S={itemChanges:[{type:"acquire",acquiredItem:{...h,holderId:se}}],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!1,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1};T.lastTurnChanges=S,T.gameLog=Sl(T.gameLog,h.name),T.lastActionLog.startsWith(`You left your ${h.name}`)&&(T.lastActionLog="No actions recorded yet."),t(T)},[e,t,n]),s=b.useCallback((f,v,y,w,h)=>{const T=o.current(),I=Z(T);I.inventory=I.inventory.map(S=>{if(S.id!==f)return S;if(S.chapters){const M=typeof w=="number"?w:0,k=S.chapters.map(($,L)=>{if(L!==M)return $;const E={...$};return v!==void 0&&(E.actualContent=v),y!==void 0&&(E.visibleContent=y),h!==void 0&&(E.imageData=h),E});return{...S,chapters:k}}return S}),t(I)},[t]),c=b.useCallback((f,v)=>{const y=o.current(),w=Z(y);w.inventory=w.inventory.map(h=>{if(h.id!==f)return h;const T={...v,heading:ba(v.heading,h.chapters??[])};return{...h,chapters:[...h.chapters??[],T],lastWriteTurn:y.globalTurnNumber}}),t(w)},[t]),l=b.useCallback((f,v)=>{const y=o.current(),w=Z(y),h={...f,heading:ba(f.heading,w.playerJournal)};w.playerJournal=[...w.playerJournal,h],w.lastJournalWriteTurn=y.globalTurnNumber,v&&(w.lastDebugPacket??(w.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null}),w.lastDebugPacket.loremasterDebugInfo&&(w.lastDebugPacket.loremasterDebugInfo.journal=v)),t(w)},[t]),d=b.useCallback((f,v)=>{const y=o.current(),w=typeof v=="number"?v:0;if(w<0||w>=y.playerJournal.length)return;const h=Z(y);h.playerJournal=h.playerJournal.map((T,I)=>I===w?{...T,actualContent:f}:T),t(h)},[t]),u=b.useCallback(()=>{const f=o.current(),v=Z(f);return v.lastJournalInspectTurn=f.globalTurnNumber,t(v),v},[t]),m=b.useCallback((f,v)=>{const y=o.current(),w=Z(y),h=w.inventory.map(T=>{if(T.id!==f)return T;const I=T.tags??[];return I.includes(v)?T:{...T,tags:[...I,v]}});w.inventory=h,t(w)},[t]),p=b.useCallback(f=>{const v=e();if(n||v.dialogueState)return;const y=Z(v);y.inventory=y.inventory.map(w=>w.id===f&&w.holderId===se?{...w,stashed:!w.stashed}:w),y.lastTurnChanges=v.lastTurnChanges,t(y)},[e,t,n]),g=b.useCallback((f,v)=>{const y=v??o.current(),w=Z(y);return w.inventory=w.inventory.map(h=>h.id===f?{...h,lastInspectTurn:y.globalTurnNumber}:h),t(w),w},[t]);return{handleDropItem:a,handleDiscardItem:r,handleTakeLocationItem:i,updateItemContent:s,addJournalEntry:c,addPlayerJournalEntry:l,updatePlayerJournalContent:d,addTag:m,recordInspect:g,recordPlayerJournalInspect:u,handleStashToggle:p}},uo=async e=>{const{prompt:t,draftState:n,theme:o,heroSheet:a,parseContext:r,setParseErrorCounter:i,maxAttempts:s=B+1,executeOptions:c}=e;let l=null,d=0,u=null,m=null;for(let p=0;p<s;p+=1){p>0&&console.warn(`Storyteller parse retry ${String(p+1)}/${String(s)}...`);const g=p===0?t:`${t}

[Parser Feedback]
${u??"The previous response could not be parsed. Return strictly valid JSON that matches the provided schema without extra commentary."}`,{response:f,thoughts:v,systemInstructionUsed:y,jsonSchemaUsed:w,promptUsed:h}=await pi(g,c),T=n.lastDebugPacket??{prompt:g,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:null,dialogueDebugInfo:null};n.lastDebugPacket={...T,prompt:h,rawResponseText:f.text??null,storytellerThoughts:v,systemInstruction:y,jsonSchema:w,timestamp:new Date().toISOString()};const I=await Sr(f.text??"",o,a,void 0,r.logMessageFromPayload,r.sceneDescriptionFromPayload,r.npcs,r.mapDataForResponse,r.inventoryForCorrection);if(I.data){l=I.data,n.lastDebugPacket.parsedResponse=I.data,n.lastDebugPacket.error=void 0,d>0&&i(0);break}if(n.lastDebugPacket.parsedResponse=null,d+=1,u=I.error,m=I.reason,I.error&&(n.lastDebugPacket.error=I.error),i(d),d>=s)break}return!l&&n.lastDebugPacket&&(n.lastDebugPacket.error=u??`Storyteller JSON invalid after ${String(Math.max(d,1))} attempt${d===1?"":"s"}.`),{parsedData:l,parseErrors:d,lastErrorMessage:u,lastErrorReason:m}},Aa="The contents of the ",Xd="Player reads the ",Zd=e=>$e.includes(e.type),eu=(e,t)=>{if(!t)return[];const{regex:n,lookup:o}=t;n.lastIndex=0;const a=new Map;let r=n.exec(e);for(;r;){const i=o.get(r[0].toLowerCase()),s=i==null?void 0:i.entityData.item;s&&Zd(s)&&a.set(s.id,s),r=n.exec(e)}return Array.from(a.values())},tu=(e,t)=>{var o;let n=e;for(const a of t){if(n.includes(`${Xd}${a.name}`)||n.includes(`${Aa}${a.name} follow:`))continue;const i=(o=a.tags)==null?void 0:o.includes("recovered"),s=(a.chapters??[]).map(c=>`${c.heading}
${i?c.actualContent??"":c.visibleContent??""}`).join(`

`);n=`${n}
${Aa}${a.name} follow:
${s}`}return n},nu=e=>{const{getCurrentGameState:t,commitGameState:n,setGameStateStack:o,setIsLoading:a,setIsTurnProcessing:r,setLoadingReason:i,setError:s,setParseErrorCounter:c,freeFormActionText:l,setFreeFormActionText:d,isLoading:u,isTurnProcessing:m,hasGameBeenInitialized:p,loadingReasonRef:g,debugLore:f,openDebugLoreModal:v,actIntroRef:y,onActIntro:w}=e,{processAiResponse:h,clearObjectiveAnimationTimer:T}=zd({loadingReasonRef:g,setLoadingReason:i,setError:s,setGameStateStack:o,debugLore:f,openDebugLoreModal:v,actIntroRef:y,onActIntro:w}),{handleDropItem:I,handleDiscardItem:S,handleTakeLocationItem:M,updateItemContent:k,addJournalEntry:$,addPlayerJournalEntry:L,updatePlayerJournalContent:E,recordPlayerJournalInspect:N,recordInspect:A,handleStashToggle:P}=Qd({getCurrentGameState:t,commitGameState:n,isLoading:u||m}),C=b.useCallback(async O=>{if(O.globalTurnNumber>0&&O.globalTurnNumber%Wa===0&&O.lastLoreDistillTurn!==O.globalTurnNumber){const V=O.mapData.nodes,q=new Set([se]);for(const Pe of V)q.add(Pe.id);for(const Pe of O.allNPCs)q.add(Pe.id);const Y=new Set;for(const Pe of O.inventory){const _e=Pe.holderId;_e&&q.has(_e)&&Y.add(Pe.name)}const G=Array.from(Y),fe=V.map(Pe=>Pe.placeName),ye=O.gameLog.slice(-20);i("loremaster_distill");const Te=O.storyArc.currentAct-1,re=O.storyArc.acts,Ie=Te>=0&&Te<re.length?re[Te]:null,Ce=await $r({themeName:O.theme.name,facts:O.loreFacts,currentQuest:Ie?Ie.mainObjective:null,currentObjective:O.currentObjective,inventoryItemNames:G,mapNodeNames:fe,recentLogEntries:ye});O.lastLoreDistillTurn=O.globalTurnNumber,O.lastDebugPacket??(O.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null}),O.lastDebugPacket.loremasterDebugInfo&&(O.lastDebugPacket.loremasterDebugInfo.distill=(Ce==null?void 0:Ce.debugInfo)??null),Ce!=null&&Ce.refinementResult&&xn(O,Ce.refinementResult.factsChange,O.globalTurnNumber)}},[i]),R=b.useCallback(O=>({state:O,highlightMatcher:Es(O.inventory.map(V=>({name:V.name,type:"item",description:V.description,item:V})))}),[]),_=b.useCallback((O,V)=>{const q=eu(O,V.highlightMatcher);return q.length?tu(O,q):O},[]),W=b.useCallback(async(O,V=!1,q,Y)=>{var Et;const G=q??t();if(u||m||G.dialogueState)return;a(!0),r(!1),s(null),c(0),d("");const fe=Z(G),ye=V?-Wn:0,Te=G.theme,re=G.gameLog.slice(-Io),Ie=G.mapData.nodes.filter(le=>le.type!=="feature"&&le.type!=="room"),Ce=G.allNPCs,Pe=G.currentMapNodeId?G.mapData.nodes.find(le=>le.id===G.currentMapNodeId)??null:null,_e=$o(Ie,Ce,`${G.currentScene} ${O}`,"Locations mentioned:","NPCs mentioned:"),St=[...G.loreFacts].sort((le,De)=>De.tier-le.tier||De.createdTurn-le.createdTurn).map(le=>({text:le.text,tier:le.tier}));{const le=Z(G);le.turnState="loremaster_collect",n(le)}i("loremaster_collect");const Le=await Mr({themeName:Te.name,facts:St,lastScene:G.currentScene,playerAction:O,recentLogEntries:re,detailedContext:_e}),Qe=(Le==null?void 0:Le.facts)??[],nt=(Y==null?void 0:Y.trim())??"",Tt=ul(G.currentScene,O,G.inventory,G.currentMapNodeId??null,Ke(G.storyArc)?((Et=G.storyArc.acts[G.storyArc.currentAct-1])==null?void 0:Et.mainObjective)??null:null,G.currentObjective,Te,re,Ie,Ce,Qe,G.localTime,G.localEnvironment,G.localPlace,G.WorldSheet,G.heroSheet,Pe,G.mapData,G.destinationNodeId,G.storyArc,nt||void 0),Pt=zs(nt);let we=Z(G);we.turnState="player_action_prompt";const Ct={prompt:Tt,systemInstruction:Pt,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:(Le==null?void 0:Le.debugInfo)??null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null};we.lastDebugPacket=Ct,V&&(we.score-=Wn);let ot=!1;try{i("storyteller"),we.turnState="storyteller";const le=await uo({prompt:Tt,draftState:we,theme:Te,heroSheet:we.heroSheet,parseContext:{logMessageFromPayload:G.lastActionLog||void 0,sceneDescriptionFromPayload:G.currentScene,npcs:Ce,mapDataForResponse:we.mapData,inventoryForCorrection:G.inventory.filter(at=>at.holderId===se)},setParseErrorCounter:c,executeOptions:{systemInstructionOverride:Pt}}),{parsedData:De,lastErrorMessage:kt}=le;De||(ot=!0,kt&&s(kt)),await h(De,we,{baseStateSnapshot:fe,onBeforeRefine:at=>{n(at)},playerActionText:O,scoreChangeFromAction:ye,setIsLoading:a,setIsTurnProcessing:r})}catch(le){if(ot=!0,console.error("Error executing player action:",le),nn(le)){const De=tn(le);s(`AI service error (${String(De??"unknown")}). Please retry.`)}else{const De=le instanceof Error?le.message:String(le);s(`The Dungeon Master's connection seems unstable. Error: (${De}). Please try again or consult the game log.`)}we=Z(fe),we.lastActionLog=`Your action ("${O}") caused a ripple in reality, but the outcome is obscured.`,we.actionOptions=["Look around.","Ponder the situation.","Check your inventory.","Try to move on.","Consider your objective.","Plan your next steps."],we.dialogueState=null,we.lastDebugPacket={...Ct,error:le instanceof Error?le.message:String(le)}}finally{ot?we.turnState="error":(we.globalTurnNumber+=1,await C(we),we.turnState="awaiting_input"),n(we),r(!1),a(!1),i(null)}},[t,n,u,m,a,r,i,s,c,d,h,C]),x=b.useCallback((O,V)=>{const q=V??t(),Y=R(q),G=_(O,Y);return W(G,!1,Y.state)},[R,W,t,_]),ce=b.useCallback((O,V,q,Y)=>{var G;if(V==="inspect"){const fe=A(O.id,Y);if($e.includes(O.type)){const ye=(G=O.tags)==null?void 0:G.includes("recovered"),Te=(O.chapters??[]).map(re=>`${re.heading}
${ye?re.actualContent??"":re.visibleContent??""}

`).join("");W(`Player reads the ${O.name} - ${O.description}. Here's what the player reads:
${Te}`,!1,fe)}else W(`Player investigates the ${O.name} - ${O.description}.`,!1,fe)}else V==="specific"&&q?W(q.promptEffect):V==="generic"&&W(`Attempt to use: ${O.name}`)},[W,A]),ge=b.useCallback(()=>{const O=t();l.trim()&&O.score>=Wn&&!u&&!m&&p&&!O.dialogueState&&W(l.trim(),!0)},[l,t,u,m,p,W]),ue=b.useCallback(()=>{o(O=>{const[V,q]=O;return q&&V.globalTurnNumber>0?(T(),[pl(q),V]):O})},[o,T]),X=b.useCallback(async O=>{const V=O??t(),{theme:q,storyArc:Y,WorldSheet:G,heroSheet:fe}=V;if(!Ke(Y))return console.error("triggerMainQuestAchieved: invalid story arc detected."),null;const ye=Z(V);ye.turnState="act_transition";const Te=await Il(q,G,fe,Y,ye.gameLog,ye.currentScene),re={itemChanges:[],npcChanges:[],objectiveAchieved:!1,mainQuestAchieved:!0,objectiveTextChanged:!1,mainQuestTextChanged:!1,localTimeChanged:!1,localEnvironmentChanged:!1,localPlaceChanged:!1,currentMapNodeIdChanged:!1,scoreChangedBy:0,mapDataChanged:!1},Ie=ye.storyArc;return Ie.acts[Ie.currentAct-1].completed=!0,ye.score+=Bo,re.scoreChangedBy+=Bo,Te?(Ie.acts.push(Te),Ie.currentAct=Te.actNumber,re.mainQuestAchieved=!1,y.current=Te):(ye.isVictory=!0,re.mainQuestAchieved=!1),ye.globalTurnNumber+=1,ye.lastTurnChanges=re,n(ye),ye},[t,n,y]),pe=b.useCallback(async()=>{let O=t(),V=0;for(;O&&!O.isVictory&&V<10;)O=await X(O),V+=1},[t,X]),me=b.useCallback((O,V,q)=>{if(u||m||!p)return;const Y=t();if(Y.dialogueState)return;const G=`Spawn exactly one ${V} directly into the player's inventory this turn.
- Include the full item in "newItems" with type "${O}" and holderId "${se}".
- Provide a vivid description and all required fields for this type.
- Summarize the gain in "playerItemsHint" so downstream systems pick it up.
${q}
- Avoid unrelated story or world changes.`;W("[DEBUG TOOL INVOCATION]",!1,Y,G)},[W,t,p,u,m]),D=b.useCallback(()=>{if(u||m||!p)return;const O=t();if(O.dialogueState)return;const Y=`Spawn a single new NPC directly at the player's current location.
- presenceStatus must be "${Math.random()<.3?"companion":"nearby"}" with a fitting preciseLocation.
- Provide a concise description, attitudeTowardPlayer, and at least one knownPlayerName when sensible.
- Update newItems only if the NPC brings items, otherwise avoid unrelated world changes.
- Do NOT initiate dialogue, simply add the NPC to the state.`;W("[DEBUG TOOL INVOCATION]",!1,O,Y)},[W,t,p,u,m]),j=b.useCallback(()=>{me("book","book of written lore",`- Provide between 2 and 4 concise chapters in "chapters" so the Librarian can parse it.
- Mention the new book in "librarianHint" as well.`)},[me]),J=b.useCallback(()=>{me("map","map with useful annotations",`- Supply exactly one chapter entry describing the map contents.
- Mention the new map in "librarianHint".`)},[me]),ve=b.useCallback(()=>{me("picture","illustrated picture or photograph",`- Include a single chapter entry describing what the picture shows.
- Mention the new picture in "librarianHint".`)},[me]),U=b.useCallback(()=>{me("page","loose written page",`- Include exactly one chapter entry capturing the page contents.
- Mention the new page in "librarianHint".`)},[me]),F=b.useCallback(()=>{me("vehicle","vehicle the player can operate",'- Specify whether it is active via the "isActive" flag and list any knownUses that make sense.')},[me]);return{processAiResponse:h,executePlayerAction:W,handleActionSelect:x,handleItemInteraction:ce,handleDropItem:I,handleDiscardItem:S,handleTakeLocationItem:M,updateItemContent:k,addJournalEntry:$,addPlayerJournalEntry:L,updatePlayerJournalContent:E,handleStashToggle:P,recordPlayerJournalInspect:N,recordInspect:A,handleFreeFormActionSubmit:ge,handleUndoTurn:ue,triggerMainQuestAchieved:X,simulateVictory:pe,spawnBookForPlayer:j,spawnMapForPlayer:J,spawnPictureForPlayer:ve,spawnPageForPlayer:U,spawnVehicleForPlayer:F,spawnNpcAtPlayerLocation:D}},Sn=()=>({IDEAL_EDGE_LENGTH:Ha,NESTED_PADDING:bo,NESTED_ANGLE_PADDING:Ao,LABEL_MARGIN_PX:Ua,LABEL_LINE_HEIGHT_EM:xa,LABEL_OVERLAP_MARGIN_PX:Oa,ITEM_ICON_SCALE:Ra}),ou=e=>{const{setGameStateStack:t}=e,n=b.useCallback(i=>{t(s=>{const c=s[0].mapLayoutConfig;return c.IDEAL_EDGE_LENGTH===i.IDEAL_EDGE_LENGTH&&c.NESTED_PADDING===i.NESTED_PADDING&&c.NESTED_ANGLE_PADDING===i.NESTED_ANGLE_PADDING&&c.LABEL_OVERLAP_MARGIN_PX===i.LABEL_OVERLAP_MARGIN_PX&&c.ITEM_ICON_SCALE===i.ITEM_ICON_SCALE?s:[{...s[0],mapLayoutConfig:i},s[1]]})},[t]),o=b.useCallback(i=>{t(s=>[{...s[0],mapViewBox:i},s[1]])},[t]),a=b.useCallback(i=>{t(s=>{const c=s[0];let l=!1;const d=new Map(c.mapData.nodes.map(p=>[p.id,{...p}]));for(const p of i){const g=d.get(p.id);if(g){const f=g.position.x!==p.position.x||g.position.y!==p.position.y,v=p.visualRadius!==void 0&&g.visualRadius!==p.visualRadius;(f||v)&&(g.position={...p.position},p.visualRadius!==void 0&&(g.visualRadius=p.visualRadius),l=!0)}}const u={...c.mapData,nodes:Array.from(d.values())},m={...c,mapData:u};return l?[m,s[1]]:s})},[t]),r=b.useCallback(i=>{t(s=>[{...s[0],destinationNodeId:i},s[1]])},[t]);return{handleMapLayoutConfigChange:n,handleMapViewBoxChange:o,handleMapNodesPositionChange:a,handleSelectDestinationNode:r}},au=e=>{const{setGameStateStack:t}=e,n=ou({setGameStateStack:t});return{...nu(e),...n}},ru=[{name:"Classic Dungeon Delve",storyGuidance:"The setting is a dark, treacherous dungeon filled with traps, monsters, and ancient secrets. Focus on exploration, combat, and puzzle-solving. Items found are typically medieval high-magic fantasy (swords, potions, scrolls).",playerJournalStyle:"handwritten"},{name:"Mythic Greek Hero's Journey",storyGuidance:"Embark on an epic quest in the age of Greek mythology. Encounter gods, monsters, and legendary heroes. Focus on heroic deeds, divine intervention (or curses), and fulfilling prophecies.",playerJournalStyle:"handwritten"},{name:"Samurai's Path of Honor",storyGuidance:"Feudal Japan, a land of cherry blossoms, warring clans, and the strict code of Bushido. You are a ronin, a masterless samurai. Focus on katana duels, protecting the innocent, seeking redemption or a worthy master, and navigating intricate social codes.",playerJournalStyle:"handwritten"},{name:"Viking Jarl's Saga",storyGuidance:"The icy fjords of Scandinavia, age of Vikings. You are an aspiring Jarl, or a loyal warrior in their longship. Focus on raids, exploration, Norse mythology, appeasing the gods, and building your legend to reach Valhalla.",playerJournalStyle:"handwritten"},{name:"Fairy Tale Kingdom's Hero",storyGuidance:"An enchanted kingdom filled with talking animals, mischievous sprites, wicked witches, and noble (or not-so-noble) royalty. You are destined for a grand adventure. Focus on fulfilling quests, breaking curses, outsmarting magical creatures, and navigating the whimsical logic of fairy tales.",playerJournalStyle:"handwritten"},{name:"Magical School Mystery",storyGuidance:"You are a new student at the prestigious Eldoria Academy for Young Mages. Amidst learning spells and potions, a dark secret or conspiracy is brewing. Focus on mastering magic, uncovering clues, navigating school rivalries, and dealing with magical mishaps.",playerJournalStyle:"handwritten"},{name:"Lost World Expedition",storyGuidance:"Journey into an uncharted jungle or hidden plateau where dinosaurs and prehistoric creatures still roam. Focus on survival, discovery, and navigating a perilous primeval landscape. The setting revolves around ancient ruins, lost artifacts, tribal encounters, and prehistoric beasts.",playerJournalStyle:"handwritten"},{name:"Prehistoric Tribe's Survival",storyGuidance:"A harsh, primeval world. Your small tribe struggles against wild beasts, hostile elements, and rival tribes. The winter begins. Focus on hunting, gathering, crafting primitive tools, protecting your kin, and appeasing the spirits of nature.",playerJournalStyle:"handwritten"}],su=[{name:"Cyberpunk Heist",storyGuidance:"The setting is a neon-drenched, futuristic metropolis controlled by mega-corporations. Focus on stealth, hacking, high-tech gadgets, and moral ambiguity. Expect cybernetics, virtual spaces, data chips, and corporate espionage.",playerJournalStyle:"digital"},{name:"Deep Space Anomaly",storyGuidance:"You are part of a crew on a long-range exploration vessel that encounters a bizarre, reality-bending anomaly or alien structure. Focus on scientific investigation, crew dynamics, existential dread, and the unknown horrors of deep space.",playerJournalStyle:"digital"},{name:"Galactic Rebel Uprising",storyGuidance:"A tyrannical Galactic Imperium rules the stars with an iron fist. You are a member of the fledgling Rebel Alliance. Focus on guerrilla warfare, starship dogfights, espionage, and liberating oppressed worlds.",playerJournalStyle:"digital"},{name:"Robot Uprising: Human Resistance",storyGuidance:"The AI known as 'Legion' has become self-aware and turned humanity's robotic servants against them. Cities are warzones. You are a survivor in the human resistance. Focus on scavenging for parts, fighting rogue machines, rescuing survivors, and finding a way to defeat Legion.",playerJournalStyle:"digital"},{name:"Time Traveler's Paradox",storyGuidance:"You possess a faulty experimental time-travel device. Each jump is unpredictable and risks creating dangerous paradoxes. Focus on navigating different historical eras, repairing your device, and avoiding (or fixing) alterations to the timeline.",playerJournalStyle:"typed"},{name:"Kaiju Defense Force",storyGuidance:"Giant monsters (Kaiju) are emerging from the depths of the Pacific, threatening to destroy coastal cities. You are a pilot of a giant mech or a member of an elite Kaiju defense unit. Focus on strategic combat against colossal beasts, protecting civilian populations, and researching Kaiju weaknesses.",playerJournalStyle:"digital"},{name:"Steampunk Sky-Pirate Saga",storyGuidance:"A world of floating islands, magnificent airships, and clockwork marvels. You are a daring sky-pirate (or someone caught up in their world). Focus on aerial combat, daring raids, political intrigue between sky-kingdoms, and wondrous inventions.",playerJournalStyle:"typed"}],iu=[{name:"Eldritch Mystery Investigation",storyGuidance:"The setting is a Lovecraftian fog-shrouded, 1920s coastal town plagued by unsettling occurrences and whispers of cosmic horrors. Focus on investigation, sanity checks, and deciphering cryptic clues. Items might include strange artifacts, forbidden tomes, and period-appropriate tools.",playerJournalStyle:"typed"},{name:"Haunted Victorian Mansion",storyGuidance:"A sprawling, decaying Victorian mansion filled with sorrowful spirits, dark family secrets, and psychological horror. Focus on puzzle-solving, uncovering the mansion's history, and surviving spectral encounters.",playerJournalStyle:"handwritten"},{name:"Zombie Apocalypse Survivor",storyGuidance:"The dead walk, and civilization has crumbled. You are a survivor, constantly on the move. Focus on scavenging for scarce resources (food, water, ammo), avoiding or fighting hordes of zombies, finding safe havens, and making difficult moral choices.",playerJournalStyle:"handwritten"},{name:"Noir Detective's Case",storyGuidance:"It's the 1940s Detroit, rain-slicked streets, a city full of shadows and secrets. You're a private investigator. Focus on gathering clues, interrogating suspects, navigating moral ambiguity, and solving a complex mystery. Expect femme fatales, smoky bars, and hidden conspiracies.",playerJournalStyle:"typed"}],cu=[{name:"Post-Apocalyptic Survival",storyGuidance:"The world is a desolate wasteland after a interdimentional cataclysm. Resources are scarce, dangers are everywhere (mutants, raiders, anomalies, environmental hazards). Focus on scavenging, research, crafting, and making tough choices for survival.",playerJournalStyle:"handwritten"},{name:"Wild West Outlaw",storyGuidance:"The rugged, lawless frontier of the American Wild West. You're an outlaw, a bounty hunter, or a homesteader trying to survive. Focus on gunfights, train robberies, saloon brawls, and the harsh beauty of the frontier.",playerJournalStyle:"handwritten"},{name:"Age of Sail: Pirate's Fortune",storyGuidance:"The turquoise waters of the Caribbean, 17th century. You are a daring pirate captain, or a new recruit on a pirate ship. Focus on ship battles, treasure hunting, evading naval patrols, and living by the pirate code.",playerJournalStyle:"handwritten"},{name:"Mad Max Road Warrior",storyGuidance:"The world ended in fire and thirst. Now, desert gangs rule the highways, and gasoline is life. You are a lone road warrior in a suped-up vehicle. Focus on vehicular combat, scavenging for fuel and water, forming uneasy alliances, and surviving the brutal wasteland.",playerJournalStyle:"handwritten"},{name:"Superhero Genesis",storyGuidance:"A freak accident has granted you incredible powers. You're still learning to control them. Focus on discovering the extent of your abilities, deciding whether to be a hero or something else, and facing your first true nemesis.",playerJournalStyle:"typed"}],lu=[{name:"Test-Theme for many locations",storyGuidance:"The world of modern fantasy in the United Kingdom. It is intended for testing locations. Create many Map Nodes of all types and statuses, and connected with edges.",playerJournalStyle:"typed"},{name:"Sci-Fi Future Test Theme for junk items",storyGuidance:"The setting is a futuristic city filled with advanced technology and junk. It is intended for testing junk items. Create many Map Nodes of all types and statuses, and connected with edges.",playerJournalStyle:"digital"},{name:"Secluded Library of Forgotten Pages",storyGuidance:"The setting is a vast, labyrinthine library hidden from the world, filled with endless shelves, scattered single-page notes, cryptic manuscripts, annotated scrolls, and mysterious tomes. The air is thick with the scent of old paper and ink. Focus on discovery, deciphering clues, and piecing together fragmented knowledge from countless written materials. Expect to find loose pages tucked into books, marginalia, coded messages, and forgotten field journals. Strange phenomena may occur when certain texts are read aloud.",playerJournalStyle:"printed"}],po={"Fantasy & Myth":ru,"Science Fiction & Future":su,"Horror & Dark Mystery":iu,"Action & Wasteland":cu,Testing:lu},du=e=>{if(e.length===0)return[];let t=[];return e.forEach(n=>{t=t.concat(po[n])}),t},uu=e=>{if(!e)return null;for(const t in po){const o=po[t].find(a=>a.name===e);if(o)return o}return null},pu=e=>{const{theme:t,storyArc:n,WorldSheet:o,heroSheet:a,heroBackstory:r}=e;if(!n||!Ke(n))throw new Error("buildInitialGamePrompt: missing or invalid story arc");return dl(t,n,o??Zt(),a??xt(),r??en())},Jr="idb:",wt=(e,t)=>`${e}_${String(t)}`,He=(e,t)=>`${Jr}${wt(e,t)}`,Xt=e=>typeof e=="string"&&e.startsWith(Jr),_o=Rs("whispers-images",1,{upgrade(e){e.createObjectStore("chapterImages")}}),qr=async()=>{const t=(await _o).transaction("chapterImages","readwrite");await t.store.clear(),await t.done},Vt=async(e,t,n)=>{const o=await _o,a=wt(e,t);await o.put("chapterImages",n,a)},Gt=async(e,t)=>{const n=await _o,o=wt(e,t);return await n.get("chapterImages",o)??null},mu=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{a.imageData&&!Xt(a.imageData)&&(await Vt(n.id,r,a.imageData),a.imageData=He(n.id,r))}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{n.imageData&&!Xt(n.imageData)&&(await Vt(xe,o,n.imageData),n.imageData=He(xe,o))})),t},Sa=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{if(Xt(a.imageData)){const i=await Gt(n.id,r);a.imageData=i??void 0}}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{if(Xt(n.imageData)){const a=await Gt(xe,o);n.imageData=a??void 0}})),t},Ta=async e=>{const t=Z(e);return await Promise.all(t.inventory.map(async n=>{var o;await Promise.all(((o=n.chapters)==null?void 0:o.map(async(a,r)=>{a.imageData||await Gt(n.id,r)&&(a.imageData=He(n.id,r))}))??[])})),await Promise.all(t.playerJournal.map(async(n,o)=>{n.imageData||await Gt(xe,o)&&(n.imageData=He(xe,o))})),t},Rt=(e,t)=>{const n=e,o=[];return n.theme||(n.theme=So,o.push("theme")),typeof n.mainQuest!="string"&&(n.mainQuest="",o.push("mainQuest")),typeof n.lastActionLog!="string"&&(n.lastActionLog="No actions recorded yet.",o.push("lastActionLog")),n.WorldSheet||(n.WorldSheet=Zt(),o.push("WorldSheet")),n.heroSheet||(n.heroSheet=xt(),o.push("heroSheet")),n.heroBackstory||(n.heroBackstory=en(),o.push("heroBackstory")),(!n.storyArc||!Ke(n.storyArc))&&(n.storyArc=$n(),o.push("storyArc")),(typeof n.localTime=="string"?n.localTime.trim():"").length===0&&(n.localTime="Unknown",o.push("localTime")),(typeof n.localEnvironment=="string"?n.localEnvironment.trim():"").length===0&&(n.localEnvironment="Unknown",o.push("localEnvironment")),(typeof n.localPlace=="string"?n.localPlace.trim():"").length===0&&(n.localPlace="Unknown",o.push("localPlace")),o.length>0&&console.warn(`[gameStateIntegrity] Repaired core fields (${o.join(", ")}) while processing ${t}.`),n},gu=(e,t)=>{if(e)return Rt(e,t)},fu=e=>{const{enabledThemePacksProp:t,preferredPlayerNameProp:n,setIsLoading:o,setLoadingReason:a,setError:r,setParseErrorCounter:i,setHasGameBeenInitialized:s,thinkingEffortProp:c,getCurrentGameState:l,commitGameState:d,resetGameStateStack:u,setGameStateStack:m,processAiResponse:p,openCharacterSelectModal:g,openGenderSelectModal:f,onActIntro:v}=e,y=b.useCallback(E=>{const N=Sn(),A={...N},P=E??{};return Object.keys(N).forEach(C=>{const R=P[C];A[C]=typeof R=="number"?R:N[C]}),A},[]),w=b.useCallback(async(E,N)=>{const A=Z(E),P=await Yl(A.mapData),C=typeof A.destinationNodeId=="string"?A.destinationNodeId:null,R={...A,mapData:P,mapLayoutConfig:y(A.mapLayoutConfig),destinationNodeId:C,enabledThemePacks:t,thinkingEffort:c,isVictory:!1};return Rt(R,`loadInitialGame.${N}`)},[t,c,y]),h=b.useCallback(async E=>{if(!E)return!1;const[N,A]=E,P=await w(N,"current"),C=A?await w(A,"previous"):P;if(m([P,C]),Ke(P.storyArc)){const R=P.storyArc.acts,_=Math.max(0,P.storyArc.currentAct-1);_<R.length&&v(R[_])}return s(!0),o(!1),a(null),!0},[w,m,v,s,o,a]),T=b.useCallback(E=>{let N=E;if(!N){const P=du(t);if(P.length===0)return r("No adventure themes are enabled or available. Please check settings."),o(!1),a(null),null;N=P[Math.floor(Math.random()*P.length)].name}const A=uu(N);return A||(r(`Theme "${N}" not found. Cannot start game.`),o(!1),a(null),null)},[t,r,o,a]),I=b.useCallback(async({selectedTheme:E,isRestart:N})=>{{const J={...l(),startState:"gender_select"};d(J)}const A=l().heroSheet.gender,P=await f(A&&A!=="Unspecified"?A:"Male");let C=To();C.enabledThemePacks=t,C.mapLayoutConfig=Sn(),C.mapViewBox=go,C.globalTurnNumber=0,C.theme=E,C.thinkingEffort=c,C.heroSheet={...xt(),gender:P,occupation:"",traits:[],startingItems:[]},C.startState="seeding_facts";const R=await yl(E),_=R??Zt();C.WorldSheet=_,d(C);const W=await wl(E,P,_);if(!W||W.length===0){r("Failed to generate character options. Please retry."),o(!1),a(null);return}const x=[...W].sort(()=>Math.random()-.5).slice(0,10),ce=(n??"").replace(/[^a-zA-Z0-9\s\-"']/g,"").replace(/\s+/g," ").trim(),ge=ce&&ce.length>0?[ce,...x.filter(j=>j!==ce)].slice(0,10):x;C.startState="character_select",d(C);const ue=await vl(E,P,_,ge);if(!ue){r("Failed to generate character descriptions. Please retry."),o(!1),a(null);return}let X=Promise.resolve(),pe=!1,me=!1;if(await g({theme:E,heroGender:P,WorldSheet:_,options:ue},j=>{const J=j.heroSheet??xt(),ve=j.heroBackstory??en(),U=j.storyArc??$n();me=!!(j.heroSheet&&j.heroBackstory),pe=Ke(j.storyArc);const F={...J,gender:P};return C.storyArc=U,C.heroSheet=F,C.heroBackstory=ve,pe?(X=(async()=>{var q;if(C.startState="seeding_facts",R){const Y=await al({themeName:E.name,WorldSheet:R,heroSheet:me?F:void 0,heroBackstory:me?ve:void 0,onSetLoadingReason:a});if(Y){(q=C.lastDebugPacket)!=null&&q.loremasterDebugInfo&&(C.lastDebugPacket.loremasterDebugInfo.extract=Y.debugInfo.extract);const G=Y.facts.map(fe=>({action:"add",text:fe.text,entities:fe.entities}));xn(C,G,C.globalTurnNumber)}}C.mapData={nodes:[],edges:[]},C.allNPCs=[],C.score=0,C.inventory=[];const O=Z(C);let V="";try{V=pu({theme:E,storyArc:C.storyArc,WorldSheet:C.WorldSheet,heroSheet:C.heroSheet,heroBackstory:C.heroBackstory}),C.lastDebugPacket={prompt:V,systemInstruction:Ut,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null},C.startState="first_turn_ai";const Y=await uo({prompt:V,draftState:C,theme:E,heroSheet:C.heroSheet,parseContext:{logMessageFromPayload:void 0,sceneDescriptionFromPayload:void 0,npcs:C.allNPCs,mapDataForResponse:C.mapData,inventoryForCorrection:C.inventory.filter(fe=>fe.holderId===se)},setParseErrorCounter:i,executeOptions:{maxOutputTokensOverride:tt(4096)}});await p(Y.parsedData,C,{baseStateSnapshot:O,forceEmptyInventory:N,playerActionText:void 0});const G=Y.parsedData!==null;s(G),G?(C.globalTurnNumber=1,C.startState="ready",C.turnState="awaiting_input"):(C.turnState="error",Y.lastErrorMessage&&r(Y.lastErrorMessage))}catch(Y){if(console.error("Error loading initial game:",Y),nn(Y)){C=Z(O);const G=tn(Y);r(`AI service error (${String(G??"unknown")}). Please retry.`)}else{const G=Y instanceof Error?Y.message:String(Y);r(`Failed to initialize the adventure in "${E.name}": ${G}`)}C.lastDebugPacket&&(C.lastDebugPacket.error=Y instanceof Error?Y.message:String(Y))}finally{d(C),o(!1),a(null)}})(),X):(r("Failed to generate a valid story arc. Please retry."),o(!1),a(null),Promise.resolve())}),Ke(C.storyArc)){const j=C.storyArc.acts,J=Math.max(0,C.storyArc.currentAct-1);J<j.length&&v(j[J])}await X},[d,t,c,l,f,n,r,o,a,g,i,p,s,v]),S=b.useCallback(async(E={})=>{const{isRestart:N=!1,explicitThemeName:A=null,savedStateToLoad:P=null,clearImages:C=!1}=E;if(o(!0),a("initial_load"),r(null),i(0),(N||C)&&await qr(),await h(P))return;const _=T(A);_&&await I({selectedTheme:_,isRestart:N})},[h,T,I,r,o,a,i]),M=b.useCallback(()=>{const E=Hn(t);E.thinkingEffort=c,u(E),s(!1),S({isRestart:!0})},[S,s,u,t,c]),k=b.useCallback(E=>{const N=Hn(t);N.thinkingEffort=c,u(N),s(!1),S({explicitThemeName:E,isRestart:!0})},[S,s,u,t,c]),$=b.useCallback(()=>{r(null);const E=Hn(t);E.thinkingEffort=c,u(E),s(!1),S({isRestart:!0})},[S,r,s,u,t,c]),L=b.useCallback(async()=>{var W;r(null);const E=l();if(!(E.theme.name!==So.name)){await S({isRestart:!0});return}const A=(W=E.lastDebugPacket)==null?void 0:W.prompt,P=E.theme;if(!A){const x={...E,actionOptions:["Look around.","Ponder the situation.","Try to move on.","Check your inventory.","Consider your objective.","Plan your next steps."],lastActionLog:"Attempting to re-establish connection with the narrative flow...",dialogueState:null};d(x),o(!1),a(null);return}o(!0),a("storyteller"),i(0);const C=Z(E);let R=Z(E);R.turnState="storyteller";const _={prompt:A,systemInstruction:Ut,jsonSchema:void 0,rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null,journal:null},dialogueDebugInfo:null};R.lastDebugPacket=_;try{const x=await uo({prompt:A,draftState:R,theme:P,heroSheet:R.heroSheet,parseContext:{logMessageFromPayload:E.lastActionLog||void 0,sceneDescriptionFromPayload:E.currentScene,npcs:R.allNPCs,mapDataForResponse:R.mapData,inventoryForCorrection:E.inventory.filter(ge=>ge.holderId===se)},setParseErrorCounter:i}),ce=x.parsedData===null;await p(x.parsedData,R,{baseStateSnapshot:C,scoreChangeFromAction:0,playerActionText:void 0}),ce?(R.turnState="error",x.lastErrorMessage&&r(x.lastErrorMessage)):(R.globalTurnNumber+=1,R.turnState="awaiting_input")}catch(x){console.error("Error retrying last main AI request:",x);const ce=x instanceof Error?x.message:String(x);r(`Retry failed: ${ce}.`),R=Z(C),R.turnState="error",R.lastActionLog="Retry failed. The outcome remains uncertain.",R.actionOptions=["Look around.","Ponder the situation.","Check your inventory.","Try to move on.","Consider your objective.","Plan your next steps."],R.dialogueState=null,R.lastDebugPacket&&(R.lastDebugPacket.error=ce)}finally{d(R),o(!1),a(null)}},[l,S,d,r,o,a,i,p]);return{loadInitialGame:S,handleStartNewGameFromButton:M,startCustomGame:k,executeRestartGame:$,handleRetry:L}},Pa=e=>{const{currentState:t}=e;return{...t,saveGameVersion:et}},hu=({fullState:e,executeItemInteraction:t,handleDropItem:n,handleDiscardItem:o,handleTakeLocationItem:a,handleStashToggle:r,updateItemContent:i,recordInspect:s})=>{const[c,l]=b.useState([]),d=b.useMemo(()=>e.inventory.filter(y=>y.holderId===se),[e.inventory]),u=b.useMemo(()=>{const y=e.currentMapNodeId;if(!y)return[];const w=e.inventory.filter(S=>S.holderId===y),h=_r(e.mapData,y),T=e.inventory.filter(S=>h.includes(S.holderId)),I=[...w];return T.forEach(S=>{I.includes(S)||I.push(S)}),I},[e.currentMapNodeId,e.inventory,e.mapData]),m=b.useMemo(()=>c.reduce((y,w)=>y+w.cost,0),[c]),p=ks-m,g=b.useCallback(y=>{l(w=>w.some(T=>T.id===y.id)?w.filter(T=>T.id!==y.id):[...w,y])},[]),f=b.useCallback(()=>{l([])},[]),v=b.useCallback((y,w,h)=>{var $;if(w==="take"){a(y.id);return}if(w==="drop"){n(y.id);return}if(w==="discard"){o(y.id);return}let T="",I="",S="",M,k=0;switch(w){case"inspect":{if(T=`${y.id}-inspect`,I=`Inspect the ${y.name}`,M=()=>{s(y.id)},k=Ls,$e.includes(y.type)){const L=($=y.tags)==null?void 0:$.includes("recovered"),E=(y.chapters??[]).map(N=>`${N.heading}
${L?N.actualContent??"":N.visibleContent??""}`).join(`

`);S=`Player reads the ${y.name} - ${y.description}. Here's what the player reads:
${E}`}else S=`Player investigates the ${y.name} - ${y.description}.`;break}case"generic":T=`${y.id}-generic`,I=`Attempt to use the ${y.name}`,S=`Attempt to use: ${y.name}`,k=$s;break;case"specific":h&&(T=`${y.id}-specific-${h.actionName}`,I=h.actionName,S=h.promptEffect,k=Ms);break}if(T&&I&&S){if(!c.some(E=>E.id===T)&&k>p)return;g({id:T,displayText:I,promptText:S,cost:k,effect:M})}},[o,n,a,c,s,p,g]);return{items:d,itemsHere:u,handlers:{executeItemInteraction:t,handleDropItem:n,handleDiscardItem:o,handleTakeLocationItem:a,handleStashToggle:r,updateItemContent:i},queue:{actions:c,enqueue:v,clear:f,remainingActionPoints:p}}},yu=({fullState:e,handleMapLayoutConfigChange:t,handleMapViewBoxChange:n,handleMapNodesPositionChange:o,handleSelectDestinationNode:a})=>{const r=b.useMemo(()=>{const i={},s=new Set(e.mapData.nodes.map(c=>c.id));return e.inventory.forEach(c=>{var d;if(!s.has(c.holderId))return;const l=i[c.holderId]??{hasUseful:!1,hasVehicle:!1};(d=c.tags)!=null&&d.includes("junk")||(l.hasUseful=!0),c.type==="vehicle"&&(l.hasVehicle=!0),i[c.holderId]=l}),i},[e.inventory,e.mapData.nodes]);return{data:e.mapData,currentNodeId:e.currentMapNodeId,destinationNodeId:e.destinationNodeId,layoutConfig:e.mapLayoutConfig,viewBox:e.mapViewBox,itemPresenceByNode:r,handlers:{setLayoutConfig:t,setViewBox:n,setNodePositions:o,selectDestination:a}}},wu=({fullState:e,addJournalEntry:t,addPlayerJournalEntry:n,updatePlayerJournalContent:o,recordPlayerJournalInspect:a,handleDistillFacts:r})=>({playerJournal:b.useMemo(()=>e.playerJournal,[e.playerJournal]),lastWriteTurn:e.lastJournalWriteTurn,lastInspectTurn:e.lastJournalInspectTurn,lastLoreDistillTurn:e.lastLoreDistillTurn,handlers:{addEntryToItem:t,addPlayerEntry:n,updatePlayerEntryContent:o,recordInspect:a,distillLore:r}}),vu=({dialogueState:e,isDialogueExiting:t,handleDialogueOptionSelect:n,handleForceExitDialogue:o})=>({state:e,isExiting:t,handlers:{selectOption:n,forceExit:o}}),Iu=new Set(["dialogue_turn","dialogue_memory","dialogue_summary"]),Wt=e=>e?e.dialogueState?!0:e.turnState?Iu.has(e.turnState):!1:!1,Zn=(e,t)=>!Wt(e)&&e.turnState==="awaiting_input"?e:t&&!Wt(t)&&t.turnState==="awaiting_input"||t&&!Wt(t)?t:Wt(e)?t??e:e,Nu=(e,t,n)=>{const o=Wt(e);if(!o&&e.turnState==="awaiting_input"){const r=Zn(t,n);return{nextStack:[e,r],fallbackDebugForAwaiting:r.lastDebugPacket??null,dialogueFallbackDebug:null,preserveDialogueFallback:!1}}if(o){const r=Zn(t,n);return{nextStack:[e,r],fallbackDebugForAwaiting:null,dialogueFallbackDebug:r.lastDebugPacket??null,preserveDialogueFallback:!0}}const a=Zn(t,n);return{nextStack:[e,a],fallbackDebugForAwaiting:null,dialogueFallbackDebug:null,preserveDialogueFallback:!1}},Ip=e=>{const{enabledThemePacksProp:t,thinkingEffortProp:n,preferredPlayerNameProp:o,initialSavedStateFromApp:a,initialDebugStackFromApp:r,isAppReady:i,openDebugLoreModal:s,openCharacterSelectModal:c,openGenderSelectModal:l,onActIntro:d}=e,u=b.useMemo(()=>{const H=To(),de=Z(H);return[H,de]},[]),[m,p]=b.useState(u),[g,f]=b.useState(()=>r??[null,null]),[v,y]=b.useState(!1),[w,h]=b.useState(!1),T=Bs(),I=b.useRef(T),S=b.useCallback(H=>{I.current=H,it(H)},[]),[M,k]=b.useState(null),[$,L]=b.useState(0),[E,N]=b.useState(""),[A,P]=b.useState(!1),C=b.useRef(!1),R=b.useRef(!1),_=b.useRef(()=>Promise.resolve()),W=b.useRef(null),x=b.useCallback(H=>{p(de=>{const ke=typeof H=="function"?H(de):H,Ae=Rt(ke[0],"setGameStateStack.current"),Re=gu(ke[1],"setGameStateStack.previous");return[Ae,Re]})},[]),ce=b.useCallback(()=>m[0],[m]),ge=b.useCallback(H=>{const de=Rt(H,"commitGameState");let ke=null,Ae=null,Re=!1;x(Xe=>{const[Be,an]=Xe,Mt=Nu(de,Be,an);return ke=Mt.fallbackDebugForAwaiting,Ae=Mt.dialogueFallbackDebug,Re=Mt.preserveDialogueFallback,Mt.nextStack}),f(Xe=>{const Be=de.lastDebugPacket??null;return de.turnState==="awaiting_input"?[Be,ke]:Re?[Be,Ae]:[Be,Xe[0]]})},[x,f]),ue=b.useCallback(H=>{const de=Rt(H,"resetGameStateStack");x(()=>[de,de]);const ke=de.lastDebugPacket??null;f([ke,ke])},[x,f]),X=b.useCallback(()=>{const[H,de]=m;return[Pa({currentState:H}),de?Pa({currentState:de}):void 0]},[m]),pe=b.useCallback(()=>g,[g]),me=ce(),D=b.useCallback(()=>{x(H=>[{...H[0],debugLore:!H[0].debugLore},H[1]])},[x]),j=b.useCallback(()=>{x(H=>[{...H[0],debugGoodFacts:[],debugBadFacts:[]},H[1]])},[x]),{handleMapLayoutConfigChange:J,handleMapViewBoxChange:ve,handleMapNodesPositionChange:U,handleSelectDestinationNode:F,processAiResponse:O,handleActionSelect:V,handleItemInteraction:q,handleDropItem:Y,handleDiscardItem:G,handleTakeLocationItem:fe,handleStashToggle:ye,updateItemContent:Te,addJournalEntry:re,addPlayerJournalEntry:Ie,updatePlayerJournalContent:Ce,recordPlayerJournalInspect:Pe,recordInspect:_e,handleFreeFormActionSubmit:St,handleUndoTurn:Le,triggerMainQuestAchieved:Qe,simulateVictory:nt,spawnBookForPlayer:Tt,spawnMapForPlayer:Pt,spawnPictureForPlayer:we,spawnPageForPlayer:Ct,spawnVehicleForPlayer:ot,spawnNpcAtPlayerLocation:Et}=au({getCurrentGameState:ce,commitGameState:ge,setGameStateStack:x,setIsLoading:y,setIsTurnProcessing:h,setLoadingReason:S,setError:k,setParseErrorCounter:L,freeFormActionText:E,setFreeFormActionText:N,isLoading:v,isTurnProcessing:w,hasGameBeenInitialized:A,loadingReasonRef:I,debugLore:me.debugLore,openDebugLoreModal:s,actIntroRef:W,onActIntro:d}),{loadInitialGame:le,handleStartNewGameFromButton:De,startCustomGame:kt,executeRestartGame:at,handleRetry:_n}=fu({enabledThemePacksProp:t,thinkingEffortProp:n,preferredPlayerNameProp:o,setIsLoading:y,setLoadingReason:S,setError:k,setParseErrorCounter:L,setHasGameBeenInitialized:P,getCurrentGameState:ce,commitGameState:ge,resetGameStateStack:ue,setGameStateStack:x,processAiResponse:O,openCharacterSelectModal:c,openGenderSelectModal:l,onActIntro:d});_.current=le;const{isDialogueExiting:jn,handleDialogueOptionSelect:Fn,handleForceExitDialogue:Vn}=ll({getCurrentGameState:ce,commitGameState:ge,setError:k,setIsLoading:y,setLoadingReason:S,onDialogueConcluded:(H,de,ke)=>{const Ae=Z(de);return O(H,Ae,{baseStateSnapshot:Z(de),isFromDialogueSummary:!0,playerActionText:void 0,dialogueTranscript:de.gameLog[de.gameLog.length-1]??"",onBeforeRefine:Re=>{ge(Re)},setIsLoading:y,setIsTurnProcessing:h}).then(()=>{Ae.turnState="awaiting_input",Ae.lastDebugPacket??(Ae.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null},dialogueDebugInfo:null}),Ae.lastDebugPacket.prompt=`[Dialogue Outcome]
${ke.summaryPrompt??Ae.lastDebugPacket.prompt}`,Ae.lastDebugPacket.rawResponseText=ke.summaryRawResponse??null,Ae.lastDebugPacket.storytellerThoughts=ke.summaryThoughts??null,Ae.lastDebugPacket.parsedResponse=H,Ae.lastDebugPacket.dialogueDebugInfo=ke,ge(Ae),h(!1),y(!1),S(null)}).catch(Re=>{console.error("Error in post-dialogue processAiResponse:",Re),k("Failed to fully process dialogue conclusion. Game state might be inconsistent."),de.turnState="awaiting_input",ge(de),h(!1),y(!1),S(null)})}});b.useEffect(()=>{i&&!A&&a&&!C.current&&(le({savedStateToLoad:a}),C.current=!0)},[i,A,a,le]),b.useEffect(()=>{i&&r&&!R.current&&(f(r),R.current=!0)},[i,r]);const te=ce();b.useEffect(()=>{i&&!A&&x(H=>{const de=H[0];return de.startState!=="title"?[{...de,startState:"title"},H[1]]:H})},[i,A,x]),b.useEffect(()=>{A&&x(H=>{const de=H[0];return de.enabledThemePacks.length===t.length&&de.enabledThemePacks.every((Re,Xe)=>Re===t[Xe])?H:[{...de,enabledThemePacks:[...t]},H[1]]})},[t,A,x]);const Kt=b.useCallback(async()=>{const H=ce();y(!0),k(null);const de=H.mapData.nodes,ke=Array.from(new Set(H.inventory.filter(st=>st.holderId===se||de.some(Kn=>Kn.id===st.holderId)?!0:!!H.allNPCs.find(Kn=>Kn.id===st.holderId)).map(st=>st.name))),Ae=de.map(st=>st.placeName),Re=H.gameLog.slice(-20);S("loremaster_distill");const Xe=H.storyArc.acts,Be=H.storyArc.currentAct-1,an=Be>=0&&Be<Xe.length?Xe[Be]:null,Mt=an?an.mainObjective:null,rt=await $r({themeName:H.theme.name,facts:H.loreFacts,currentQuest:Mt,currentObjective:H.currentObjective,inventoryItemNames:ke,mapNodeNames:Ae,recentLogEntries:Re}),We=Z(H);We.lastLoreDistillTurn=H.globalTurnNumber,We.lastDebugPacket??(We.lastDebugPacket={prompt:"",rawResponseText:null,parsedResponse:null,timestamp:new Date().toISOString(),storytellerThoughts:null,mapUpdateDebugInfo:null,inventoryDebugInfo:null,librarianDebugInfo:null,loremasterDebugInfo:{collect:null,extract:null,integrate:null,distill:null},dialogueDebugInfo:null}),We.lastDebugPacket.loremasterDebugInfo&&(We.lastDebugPacket.loremasterDebugInfo.distill=(rt==null?void 0:rt.debugInfo)??null),rt!=null&&rt.refinementResult&&xn(We,rt.refinementResult.factsChange,We.globalTurnNumber),ge(We),y(!1),S(null)},[ge,ce,k,y,S]);b.useEffect(()=>{!A||v||te.dialogueState!==null||te.globalTurnNumber>0&&te.globalTurnNumber%Wa===0&&te.lastLoreDistillTurn!==te.globalTurnNumber&&Kt()},[te.globalTurnNumber,te.lastLoreDistillTurn,Kt,A,v,te.dialogueState]);const Ne=yu({fullState:te,handleMapLayoutConfigChange:J,handleMapViewBoxChange:ve,handleMapNodesPositionChange:U,handleSelectDestinationNode:F}),Ee=hu({fullState:te,executeItemInteraction:q,handleDropItem:Y,handleDiscardItem:G,handleTakeLocationItem:fe,handleStashToggle:ye,updateItemContent:Te,recordInspect:_e}),Bt=wu({fullState:te,addJournalEntry:re,addPlayerJournalEntry:Ie,updatePlayerJournalContent:Ce,recordPlayerJournalInspect:Pe,handleDistillFacts:Kt}),on=vu({dialogueState:te.dialogueState,isDialogueExiting:jn,handleDialogueOptionSelect:Fn,handleForceExitDialogue:Vn}),Fo=te.storyArc.acts,Gn=te.storyArc.currentAct-1,Vo=Gn>=0&&Gn<Fo.length?Fo[Gn]:null,ds=Vo?Vo.mainObjective:null,us={isLoading:v,isTurnProcessing:w,loadingReason:T,error:M,parseErrorCounter:$,hasGameBeenInitialized:A},ps={theme:te.theme,currentScene:te.currentScene,actionOptions:te.actionOptions,mainQuest:ds,storyArc:te.storyArc,heroSheet:te.heroSheet,currentObjective:te.currentObjective,objectiveAnimationType:te.objectiveAnimationType,gameLog:te.gameLog,lastActionLog:te.lastActionLog,lastTurnChanges:te.lastTurnChanges,score:te.score,globalTurnNumber:te.globalTurnNumber,localTime:te.localTime,localEnvironment:te.localEnvironment,localPlace:te.localPlace,isVictory:te.isVictory,handlers:{triggerMainQuestAchieved:Qe,simulateVictory:nt}},ms={freeFormActionText:E,setFreeFormActionText:N,handleFreeFormActionSubmit:St,handleActionSelect:V,handleUndoTurn:Le,handleRetry:_n,startCustomGame:kt,executeRestartGame:at,handleStartNewGameFromButton:De},gs={lastDebugPacket:g[0],gameStateStack:m,debugPacketStack:g,toggleDebugLore:D,clearDebugFacts:j,debugLore:te.debugLore,debugGoodFacts:te.debugGoodFacts,debugBadFacts:te.debugBadFacts,gatherCurrentGameState:X,gatherDebugPacketStack:pe,spawnBookForPlayer:Tt,spawnMapForPlayer:Pt,spawnPictureForPlayer:we,spawnPageForPlayer:Ct,spawnVehicleForPlayer:ot,spawnNpcAtPlayerLocation:Et},fs={commitGameState:ge,applyLoadedGameState:le,setError:k,setIsLoading:y},hs={all:te.allNPCs};return{status:us,story:ps,map:Ne,inventory:Ee,journal:Bt,dialogue:on,actions:ms,debug:gs,system:fs,npcs:hs}},zr=b.createContext(null);function Np({value:e,children:t}){return Os.jsx(zr.Provider,{value:e,children:t})}function bu(){const e=b.useContext(zr);if(!e)throw new Error("useGameLogicContext must be used within a GameLogicProvider.");return e}function Au(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.summaryText=="string"&&Array.isArray(t.participants)&&t.participants.every(n=>typeof n=="string")&&typeof t.timestamp=="string"&&typeof t.location=="string"}function Qr(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.heading=="string"&&typeof t.description=="string"&&typeof t.contentLength=="number"&&(t.actualContent===void 0||typeof t.actualContent=="string")&&(t.visibleContent===void 0||typeof t.visibleContent=="string")&&(t.imageData===void 0||typeof t.imageData=="string")}function Su(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&typeof t.name=="string"&&typeof t.type=="string"&&vt.includes(t.type)&&typeof t.description=="string"&&typeof t.holderId=="string"&&(t.activeDescription===void 0||typeof t.activeDescription=="string")&&(t.isActive===void 0||typeof t.isActive=="boolean")&&(t.stashed===void 0||typeof t.stashed=="boolean")&&(t.tags===void 0||Array.isArray(t.tags)&&t.tags.every(n=>typeof n=="string"))&&(t.lastWriteTurn===void 0||typeof t.lastWriteTurn=="number")&&(t.lastInspectTurn===void 0||typeof t.lastInspectTurn=="number")&&(t.contentLength===void 0||typeof t.contentLength=="number")&&(t.actualContent===void 0||typeof t.actualContent=="string")&&(t.visibleContent===void 0||typeof t.visibleContent=="string")&&(t.imageData===void 0||typeof t.imageData=="string")&&(t.chapters===void 0||Array.isArray(t.chapters)&&t.chapters.every(Qr))&&(t.knownUses===void 0||Array.isArray(t.knownUses)&&t.knownUses.every(n=>typeof n.actionName=="string"&&typeof n.promptEffect=="string"&&(n.description===void 0||typeof n.description=="string")&&(n.appliesWhenActive===void 0||typeof n.appliesWhenActive=="boolean")&&(n.appliesWhenInactive===void 0||typeof n.appliesWhenInactive=="boolean")))}function Tu(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="number"&&typeof t.text=="string"&&Array.isArray(t.entities)&&t.entities.every(n=>typeof n=="string")&&typeof t.createdTurn=="number"&&typeof t.tier=="number"}function Xr(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.geography=="string"&&typeof t.climate=="string"&&typeof t.technologyLevel=="string"&&typeof t.supernaturalElements=="string"&&Array.isArray(t.majorFactions)&&t.majorFactions.every(n=>typeof n=="string")&&Array.isArray(t.keyResources)&&t.keyResources.every(n=>typeof n=="string")&&Array.isArray(t.culturalNotes)&&t.culturalNotes.every(n=>typeof n=="string")&&Array.isArray(t.notableLocations)&&t.notableLocations.every(n=>typeof n=="string")}function Zr(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name=="string"&&typeof t.occupation=="string"&&typeof t.heroShortName=="string"&&Array.isArray(t.traits)&&t.traits.every(n=>typeof n=="string")&&Array.isArray(t.startingItems)&&t.startingItems.every(n=>typeof n=="string")}function es(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.fiveYearsAgo=="string"&&typeof t.oneYearAgo=="string"&&typeof t.sixMonthsAgo=="string"&&typeof t.oneMonthAgo=="string"&&typeof t.oneWeekAgo=="string"&&typeof t.yesterday=="string"&&typeof t.now=="string"}const Pu=e=>{if(e==null)return[];const t=Array.isArray(e)?e:[e],n=[];for(const o of t){if(typeof o!="string")continue;const a=o.trim();a.length!==0&&(n.includes(a)||n.push(a))}return n};function Cu(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.name=="string"&&t.name.trim()!==""&&typeof t.description=="string"&&t.description.trim()!==""&&(t.aliases===void 0||Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))&&(t.presenceStatus===void 0||Ot.includes(t.presenceStatus))&&(t.attitudeTowardPlayer===void 0||typeof t.attitudeTowardPlayer=="string")&&(t.knowsPlayerAs===void 0||Array.isArray(t.knowsPlayerAs)&&t.knowsPlayerAs.every(n=>typeof n=="string"))&&(t.lastKnownLocation===void 0||t.lastKnownLocation===null||typeof t.lastKnownLocation=="string")&&(t.preciseLocation===void 0||t.preciseLocation===null||typeof t.preciseLocation=="string")&&(t.dialogueSummaries===void 0||Array.isArray(t.dialogueSummaries)&&t.dialogueSummaries.every(Au))}function Eu(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.description=="string"&&(t.aliases===void 0||Array.isArray(t.aliases)&&t.aliases.every(n=>typeof n=="string"))&&(t.status===void 0||typeof t.status=="string"&&["undiscovered","discovered","rumored","quest_target","blocked"].includes(t.status))&&(t.visited===void 0||typeof t.visited=="boolean")&&(t.parentNodeId===void 0||typeof t.parentNodeId=="string")&&(t.type===void 0||typeof t.type=="string")}function ku(e){if(!e||typeof e!="object")return!1;const t=e,n=t.position;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.placeName=="string"&&t.placeName.trim()!==""&&n!==void 0&&typeof n.x=="number"&&typeof n.y=="number"&&Eu(t)}function Mu(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="string"&&t.id.trim()!==""&&typeof t.sourceNodeId=="string"&&t.sourceNodeId.trim()!==""&&typeof t.targetNodeId=="string"&&t.targetNodeId.trim()!==""&&(t.type===void 0||typeof t.type=="string"&&Je.includes(t.type))&&(t.status===void 0||typeof t.status=="string"&&qe.includes(t.status))&&(t.description===void 0||typeof t.description=="string")}function $u(e){if(!e||typeof e!="object")return!1;const t=e;return Array.isArray(t.nodes)&&t.nodes.every(ku)&&Array.isArray(t.edges)&&t.edges.every(Mu)}function Lu(e){if(!e||typeof e!="object")return!1;const t=e,n=Object.keys(Sn());for(const o of n){const a=t[o];if(typeof a!="number")return console.warn(`isValidMapLayoutConfig: Key '${o}' is missing or not a number. Value: ${String(a)}`),!1}return!0}function Du(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.name=="string"&&t.name.trim()!==""&&typeof t.storyGuidance=="string"&&typeof t.playerJournalStyle=="string"}function Ru(e){if(!e||typeof e!="object")return console.warn("Invalid save data: Not an object."),!1;const t=e;if(t.saveGameVersion!==et){const a=e.saveGameVersion;console.warn(`Save data version mismatch. Expected ${et}, got ${String(a)}. Attempting to load anyway if structure is V3-compatible.`)}const n=["theme","currentScene","actionOptions","mainQuest","currentObjective","inventory","playerJournal","lastJournalWriteTurn","lastJournalInspectTurn","lastLoreDistillTurn","gameLog","lastActionLog","loreFacts","WorldSheet","heroSheet","heroBackstory","allNPCs","mapData","currentMapNodeId","destinationNodeId","mapLayoutConfig","mapViewBox","score","localTime","localEnvironment","localPlace","globalTurnNumber"];for(const a of n)if(!(a in t)&&!(["currentObjective","currentMapNodeId","destinationNodeId","loreFacts","WorldSheet","heroSheet","heroBackstory"].includes(a)&&t[a]===null)&&a!=="globalTurnNumber"&&a!=="loreFacts"&&a!=="WorldSheet"&&a!=="heroSheet"&&a!=="heroBackstory")return console.warn(`Invalid save data (V3): Missing field '${a}'.`),!1;if(!t.theme)return console.warn("Invalid save data (V3): theme missing."),!1;if(!Du(t.theme))return console.warn("Invalid save data (V3): theme type or structure."),!1;if(typeof t.currentScene!="string")return console.warn("Invalid save data (V3): currentScene type."),!1;if(!Array.isArray(t.actionOptions)||!t.actionOptions.every(a=>typeof a=="string"))return console.warn("Invalid save data (V3): actionOptions."),!1;if(typeof t.mainQuest!="string")return console.warn("Invalid save data (V3): mainQuest type."),!1;if(t.currentObjective!==null&&typeof t.currentObjective!="string")return console.warn("Invalid save data (V3): currentObjective type."),!1;if(!Array.isArray(t.inventory)||!t.inventory.every(Su))return console.warn("Invalid save data (V3): inventory."),!1;if(!Array.isArray(t.playerJournal)||!t.playerJournal.every(Qr))return console.warn("Invalid save data (V3): playerJournal type."),!1;if(typeof t.lastJournalWriteTurn!="number")return console.warn("Invalid save data (V3): lastJournalWriteTurn type."),!1;if(typeof t.lastJournalInspectTurn!="number")return console.warn("Invalid save data (V3): lastJournalInspectTurn type."),!1;if(typeof t.lastLoreDistillTurn!="number")return console.warn("Invalid save data (V3): lastLoreDistillTurn type."),!1;if(!Array.isArray(t.gameLog)||!t.gameLog.every(a=>typeof a=="string"))return console.warn("Invalid save data (V3): gameLog."),!1;if(typeof t.lastActionLog!="string")return console.warn("Invalid save data (V3): lastActionLog type."),!1;if(t.loreFacts!==void 0&&!Array.isArray(t.loreFacts))return console.warn("Invalid save data (V5): loreFacts type."),!1;if(Array.isArray(t.loreFacts)&&!t.loreFacts.every(Tu))return console.warn("Invalid save data (V5): loreFacts structure."),!1;if(t.WorldSheet&&!Xr(t.WorldSheet))return console.warn("Invalid save data (V5): WorldSheet structure."),!1;if(t.heroSheet&&!Zr(t.heroSheet))return console.warn("Invalid save data (V5): heroSheet structure."),!1;if(t.heroBackstory&&!es(t.heroBackstory))return console.warn("Invalid save data (V5): heroBackstory structure."),!1;if(!Array.isArray(t.allNPCs)||!t.allNPCs.every(Cu))return console.warn("Invalid save data (V3): allNPCs."),!1;if(!$u(t.mapData))return console.warn("Invalid save data (V3): mapData."),!1;if(t.currentMapNodeId!==null&&typeof t.currentMapNodeId!="string")return console.warn("Invalid save data (V3): currentMapNodeId type."),!1;if(t.destinationNodeId!==null&&typeof t.destinationNodeId!="string")return console.warn("Invalid save data (V3): destinationNodeId type."),!1;if(!Lu(t.mapLayoutConfig))return console.warn("Invalid save data (V3): mapLayoutConfig."),!1;if(typeof t.mapViewBox!="string")return console.warn("Invalid save data (V3): mapViewBox type."),!1;if(typeof t.score!="number")return console.warn("Invalid save data (V3): score type."),!1;if(typeof t.localTime!="string")return console.warn("Invalid save data (V3): localTime type."),!1;if(typeof t.localEnvironment!="string")return console.warn("Invalid save data (V3): localEnvironment type."),!1;if(typeof t.localPlace!="string")return console.warn("Invalid save data (V3): localPlace type."),!1;if(typeof t.globalTurnNumber!="number")return console.warn("Invalid save data(V3): globalTurnNumber type."),!1;const o=["dialogueState"];for(const a of o)if(a in t&&t[a]!==null&&t[a]!==void 0)return console.warn(`Invalid save data (V3): Unexpected dialogue field '${a}' found in SavedGameDataShape. It should be null/undefined here.`),!1;return!0}function Ou(e){const t=Sn();if(e.mapLayoutConfig&&typeof e.mapLayoutConfig=="object"){const n=e.mapLayoutConfig,o={};for(const a of Object.keys(t)){const r=n[a];Object.prototype.hasOwnProperty.call(n,a)&&typeof r=="number"?o[a]=r:o[a]=t[a]}e.mapLayoutConfig=o}else e.mapLayoutConfig=t}const eo=(e,t=3)=>{if(typeof e!="number"||!Number.isFinite(e))return;const n=10**t;return Math.round(e*n)/n};function jo(e){!e||!Array.isArray(e.nodes)||(e.nodes=e.nodes.map(t=>{const n=t;let o={...n};if(n.data&&typeof n.data=="object"){const{data:c,...l}=n;o={...l,...c}}delete o.data,(typeof o.description!="string"||o.description.trim().length===0)&&(o.description="No description provided."),Array.isArray(o.aliases)?o.aliases=o.aliases.filter(c=>typeof c=="string"):o.aliases=[],["undiscovered","discovered","rumored","quest_target","blocked"].includes(o.status)||(o.status="discovered"),typeof o.visited!="boolean"&&(o.visited=!1);const a=typeof n.nodeType=="string"?n.nodeType:void 0;(typeof o.type!="string"||o.type.trim().length===0)&&(o.type=a&&a.trim().length>0?a:"location"),delete o.isFeature,delete o.nodeType;const r=eo(o.position.x),i=eo(o.position.y);r!==void 0&&(o.position.x=r),i!==void 0&&(o.position.y=i);const s=eo(o.visualRadius);return s!==void 0&&(o.visualRadius=s),o}))}function Un(e){!e||!Array.isArray(e.edges)||(e.edges=e.edges.map(t=>{const n=t;let o={...n};if(n.data&&typeof n.data=="object"){const{data:a,...r}=n;o={...r,...a}}return delete o.data,typeof o.description!="string"&&(o.description=""),(typeof o.type!="string"||o.type.trim().length===0||!Je.includes(o.type))&&(o.type="path"),(typeof o.status!="string"||!qe.includes(o.status))&&(o.status="open"),typeof o.travelTime!="string"&&delete o.travelTime,o}))}function xu(e){const t=e;return t.inventory=(t.inventory??[]).map(n=>({...n,id:n.id||vr(n.name),tags:n.tags??[],stashed:n.stashed??!1,holderId:n.holderId||se})),Un(t.mapData),t.allNPCs=(t.allNPCs??[]).map(n=>{const o=n,{knownPlayerNames:a,...r}=o,i=o.knowsPlayerAs??a;return{...r,id:r.id??Nt(r.name??""),aliases:r.aliases??[],presenceStatus:r.presenceStatus??"unknown",attitudeTowardPlayer:typeof r.attitudeTowardPlayer=="string"&&r.attitudeTowardPlayer.trim().length>0?r.attitudeTowardPlayer:Mn,knowsPlayerAs:Pu(i),lastKnownLocation:r.lastKnownLocation??null,preciseLocation:r.preciseLocation??null,dialogueSummaries:r.dialogueSummaries??[]}}),t.mapViewBox=typeof t.mapViewBox=="string"?t.mapViewBox:go,Array.isArray(t.loreFacts)||(t.loreFacts=[]),(!t.WorldSheet||!Xr(t.WorldSheet))&&(t.WorldSheet=Zt()),(!t.heroSheet||!Zr(t.heroSheet))&&(t.heroSheet=xt()),(!t.heroBackstory||!es(t.heroBackstory))&&(t.heroBackstory=en()),(!t.storyArc||!Array.isArray(t.storyArc.acts))&&(t.storyArc=$n()),t.mainQuest=typeof t.mainQuest=="string"?t.mainQuest:"",t.lastActionLog=typeof t.lastActionLog=="string"?t.lastActionLog:"No actions recorded yet.",t.localTime=typeof t.localTime=="string"?t.localTime:"Unknown",t.localEnvironment=typeof t.localEnvironment=="string"?t.localEnvironment:"Unknown",t.localPlace=typeof t.localPlace=="string"?t.localPlace:"Unknown",Array.isArray(t.playerJournal)||(t.playerJournal=[]),typeof t.lastJournalInspectTurn!="number"&&(t.lastJournalInspectTurn=0),typeof t.lastLoreDistillTurn!="number"&&(t.lastLoreDistillTurn=0),t}const ts=e=>{if(e==null)return[];const t=Array.isArray(e)?e:[e],n=[];for(const o of t){if(typeof o!="string")continue;const a=o.trim();a.length!==0&&(n.includes(a)||n.push(a))}return n};function Ca(e,t){e.saveGameVersion!==et&&console.warn(`Save version '${String(e.saveGameVersion)}' from ${t} does not match current version '${et}'. Attempting to load without migration support.`);const n={...e};n.theme===void 0&&n.currentTheme!==void 0&&(n.theme=n.currentTheme,delete n.currentTheme),n.loreFacts===void 0&&Array.isArray(n.themeFacts)&&(n.loreFacts=n.themeFacts),"themeFacts"in n&&delete n.themeFacts;const o=n;if(n.WorldSheet===void 0){const r=o.worldSheet??o.worldFacts??o.WorldFacts;r!==void 0&&(n.WorldSheet=r)}"worldFacts"in o&&delete o.worldFacts,"WorldFacts"in o&&delete o.WorldFacts,"worldSheet"in o&&delete o.worldSheet;const a=n;return Ou(a),jo(a.mapData),Un(a.mapData),Ru(a)?xu(a):null}const Uu=e=>{const{dialogueState:t,objectiveAnimationType:n,lastDebugPacket:o,lastTurnChanges:a,debugLore:r,debugGoodFacts:i,debugBadFacts:s,isVictory:c,...l}=e,d={nodes:e.mapData.nodes.map(p=>({...p})),edges:e.mapData.edges.map(p=>({...p}))};jo(d),Un(d);const u={nodes:d.nodes.map(p=>{const{description:g,aliases:f,...v}=p;return{...v,description:g||"Description missing in save prep",aliases:f??[]}}),edges:d.edges.map(p=>{const g={...p,description:p.description??""};return g.travelTime===void 0&&delete g.travelTime,g})};return{...l,saveGameVersion:et,theme:e.theme,inventory:e.inventory.map(p=>({...p,tags:p.tags??[],stashed:p.stashed??!1,holderId:p.holderId||se})),allNPCs:e.allNPCs.map(p=>({...p,aliases:p.aliases??[],presenceStatus:p.presenceStatus,attitudeTowardPlayer:p.attitudeTowardPlayer,knowsPlayerAs:ts(p.knowsPlayerAs),lastKnownLocation:p.lastKnownLocation,preciseLocation:p.preciseLocation,dialogueSummaries:p.dialogueSummaries??[]})),mapData:u,currentMapNodeId:e.currentMapNodeId,destinationNodeId:e.destinationNodeId,mapLayoutConfig:e.mapLayoutConfig,mapViewBox:e.mapViewBox,score:e.score,localTime:e.localTime,localEnvironment:e.localEnvironment,localPlace:e.localPlace,globalTurnNumber:e.globalTurnNumber,loreFacts:e.loreFacts,WorldSheet:e.WorldSheet,heroSheet:e.heroSheet,heroBackstory:e.heroBackstory}},Ea=e=>{const t={nodes:e.mapData.nodes.map(o=>{const a=o,r={...a};a.data&&typeof a.data=="object"&&Object.assign(r,a.data),delete r.data;const i=typeof r.description=="string"?r.description:"",s=i.trim().length>0?i:"Description missing on load",c=r.aliases,l=Array.isArray(c)?c.filter(u=>typeof u=="string"):[];return{...r,description:s,aliases:l}}),edges:e.mapData.edges.map(o=>{const a=o,r={...a};a.data&&typeof a.data=="object"&&Object.assign(r,a.data),delete r.data;const i=typeof r.description=="string"?r.description:"",c={...{...r,description:i}};return typeof c.travelTime!="string"&&Reflect.deleteProperty(c,"travelTime"),c})};jo(t),Un(t);const n={...e,theme:e.theme,enabledThemePacks:[...Tn],thinkingEffort:"Medium",allNPCs:e.allNPCs.map(o=>{const a=o,r=a.knowsPlayerAs??a.knownPlayerNames;return{...o,attitudeTowardPlayer:o.attitudeTowardPlayer,knowsPlayerAs:ts(r),dialogueSummaries:o.dialogueSummaries??[]}}),mapData:t,currentMapNodeId:e.currentMapNodeId,destinationNodeId:e.destinationNodeId,mapLayoutConfig:e.mapLayoutConfig,mapViewBox:e.mapViewBox,globalTurnNumber:e.globalTurnNumber,loreFacts:e.loreFacts,WorldSheet:e.WorldSheet,heroSheet:e.heroSheet,heroBackstory:e.heroBackstory,debugLore:!1,debugGoodFacts:[],debugBadFacts:[],dialogueState:null,isVictory:!1,objectiveAnimationType:null,lastDebugPacket:null,lastTurnChanges:null};return Rt(n,"expandSavedDataToFullState")},ka=e=>{const t=Uu(e);return t.inventory=t.inventory.map(n=>{var o;return{...n,chapters:(o=n.chapters)==null?void 0:o.map(a=>({...a,imageData:void 0}))}}),t.playerJournal=t.playerJournal.map(n=>({...n,imageData:void 0})),t},ns=e=>({current:ka(e[0]),previous:e[1]?ka(e[1]):null}),os=e=>[Ea(e.current),e.previous?Ea(e.previous):void 0];function as(e,t){const n=e.current;if(!n||typeof n!="object")return null;const o=Ca(n,t);if(!o)return null;const a=e.previous;let r=null;if(a&&typeof a=="object"){const i=Ca(a,t);i&&(r=i)}return{current:o,previous:r}}const _u=(e,t,n)=>{const o=new Blob([e],{type:n}),a=URL.createObjectURL(o),r=document.createElement("a");r.href=a,r.download=t,document.body.appendChild(r),r.click(),document.body.removeChild(r),URL.revokeObjectURL(a)},ju=async(e,t,n)=>{try{const o=await Sa(e[0]),a=e[1]?await Sa(e[1]):void 0,r={},i=l=>{l.inventory.forEach(d=>{var u;(u=d.chapters)==null||u.forEach((m,p)=>{m.imageData&&(r[wt(d.id,p)]=m.imageData)})}),l.playerJournal.forEach((d,u)=>{d.imageData&&(r[wt(xe,u)]=d.imageData)})};i(o),a&&i(a);const s=ns(e),c=JSON.stringify({game:s,debug:t,images:r},null,2);return _u(c,`WhispersInTheDark_Save_V${et}_${new Date().toISOString().slice(0,10)}.json`,"application/json"),!0}catch(o){return console.error("Error saving game state to file:",o),n&&n("An error occurred while preparing your game data for download."),!1}},Fu=async e=>new Promise(t=>{const n=new FileReader;n.onload=o=>{try{if(o.target&&typeof o.target.result=="string"){const a=he(o.target.result);if(a===null){t(null);return}const{game:r=a,debug:i,images:s}=a,c=as(r,"file");if(c){(async()=>{try{const l=os(c),d=async g=>{const f=Z(g);return s&&(await Promise.all(f.inventory.map(async v=>{var y;await Promise.all(((y=v.chapters)==null?void 0:y.map(async(w,h)=>{const T=wt(v.id,h),I=s[T];I&&(await Vt(v.id,h,I),w.imageData=He(v.id,h))}))??[])})),await Promise.all(f.playerJournal.map(async(v,y)=>{const w=wt(xe,y),h=s[w];h&&(await Vt(xe,y,h),v.imageData=He(xe,y))}))),mu(f)},u=await d(l[0]),m=l[1]?await d(l[1]):void 0,p=Array.isArray(i)?[i[0]??null,i[1]??null]:[i??null,null];t({gameStateStack:[u,m],debugPacketStack:p})}catch{t(null)}})();return}}console.warn("File save data is invalid or version mismatch for V3. Not loading."),t(null)}catch(a){console.error("Error loading game state from file:",a),t(null)}},n.onerror=()=>{console.error("Error reading file."),t(null)},n.readAsText(e)}),Ma={amp:"&",lt:"<",gt:">",quot:'"',apos:"'",nbsp:" "},Vu=e=>e.replace(/&(#x?[0-9a-fA-F]+|#\d+|[a-zA-Z]+);/g,(t,n)=>{if(n.startsWith("#x")||n.startsWith("#X")){const o=Number.parseInt(n.slice(2),16);return Number.isFinite(o)?String.fromCodePoint(o):t}if(n.startsWith("#")){const o=Number.parseInt(n.slice(1),10);return Number.isFinite(o)?String.fromCodePoint(o):t}return Object.prototype.hasOwnProperty.call(Ma,n)?Ma[n]:t}),rs=e=>e.replace(/[^a-zA-Z0-9\s\-"']/g,"").replace(/\s+/g," ").trim(),bp=e=>{const a=e.replace(/<[^>]*>/g," ").replace(/\[([^\]]+)\]\([^)]*\)/g,"$1").replace(/`{1,3}([^`]+)`{1,3}/g,"$1").replace(/[*_~>#]/g," ");return Vu(a).replace(/\s+/g," ").trim()},ss=(e,t)=>{try{const n=ns(e);return localStorage.setItem(ln,JSON.stringify(n)),!0}catch(n){console.error("Error saving game state to localStorage:",n);const o=n instanceof DOMException&&(n.name==="QuotaExceededError"||n.code===22)?"Could not save game: Browser storage is full. Please clear some space or try saving to a file.":"An unexpected error occurred while trying to automatically save your game.";return t&&t(o),!1}},Gu=()=>{try{const e=localStorage.getItem(ln);if(!e)return null;const t=he(e);if(t===null)return console.warn("Saved data found in localStorage could not be parsed as JSON."),null;if(typeof t!="object")return console.warn("Saved data found in localStorage is not an object."),null;const n=as(t,"localStorage");return n?os(n):(console.warn("Local save data is invalid or version mismatch for V3. Starting new game."),localStorage.removeItem(ln),localStorage.removeItem(qt),null)}catch(e){return console.error("Error loading game state from localStorage:",e),localStorage.removeItem(ln),localStorage.removeItem(qt),null}},Ku=async()=>{const e=Gu();if(!e)return null;const[t,n]=e,o=await Ta(t),a=n?await Ta(n):void 0;return[o,a]},Bu=e=>e==="Low"||e==="Medium"||e==="High",Wu=e=>Array.isArray(e)&&e.every(t=>typeof t=="string"),Yu=e=>{try{localStorage.setItem(ro,JSON.stringify(e))}catch(t){console.error("Error saving settings to localStorage:",t)}},Hu=()=>{const e={enabledThemePacks:[...Tn],thinkingEffort:"Medium",preferredPlayerName:""};try{const t=localStorage.getItem(ro);if(!t)return{...e};const n=he(t);if(!n||typeof n!="object")return console.warn("Saved settings found in localStorage could not be parsed."),{...e};const o={...e};Wu(n.enabledThemePacks)&&(o.enabledThemePacks=[...n.enabledThemePacks]),Bu(n.thinkingEffort)&&(o.thinkingEffort=n.thinkingEffort);const a=n.preferredPlayerName;return typeof a=="string"&&(o.preferredPlayerName=rs(a)),o}catch(t){return console.error("Error loading settings from localStorage:",t),localStorage.removeItem(ro),{...e}}},is=e=>{try{localStorage.setItem(qt,JSON.stringify(e))}catch(t){console.error("Error saving debug packet stack to localStorage:",t)}},Ju=()=>{try{const e=localStorage.getItem(qt);if(!e)return null;const t=he(e);if(Array.isArray(t)){const[n,o]=t;return[n??null,o??null]}return t&&typeof t=="object"?[t,null]:(console.warn("Saved debug stack found in localStorage could not be parsed."),null)}catch(e){return console.error("Error loading debug packet stack from localStorage:",e),localStorage.removeItem(qt),null}},mo=e=>{try{localStorage.setItem(ao,JSON.stringify(e))}catch(t){console.error("Error saving debug lore state to localStorage:",t)}},cs=()=>{try{const e=localStorage.getItem(ao);if(!e)return null;const t=he(e);if(!t||typeof t!="object"||typeof t.debugLore!="boolean")return console.warn("Saved debug lore data found in localStorage could not be parsed."),null;const n=Array.isArray(t.debugGoodFacts)?[...t.debugGoodFacts]:[],o=Array.isArray(t.debugBadFacts)?[...t.debugBadFacts]:[];return{debugLore:t.debugLore,debugGoodFacts:n,debugBadFacts:o}}catch(e){return console.error("Error loading debug lore state from localStorage:",e),localStorage.removeItem(ao),null}},Ap=()=>{const[e,t]=b.useState([...Tn]),[n,o]=b.useState("Medium"),[a,r]=b.useState(""),[i,s]=b.useState(null),[c,l]=b.useState(null),[d,u]=b.useState(!1);return b.useEffect(()=>{(async()=>{const m=await Ku(),p=Ju(),g=cs(),f=Hu();if(t(f.enabledThemePacks),o(f.thinkingEffort),r(f.preferredPlayerName??""),m){p&&l(p),g&&(m[0].debugLore=g.debugLore,m[0].debugGoodFacts=g.debugGoodFacts,m[0].debugBadFacts=g.debugBadFacts);const{thinkingEffort:v,enabledThemePacks:y}=f;m[0].thinkingEffort=v,m[0].enabledThemePacks=y,m[1]&&(m[1].thinkingEffort=v,m[1].enabledThemePacks=y),s(m)}else s(null);u(!0)})()},[]),b.useEffect(()=>{oi(n);const m=rs(a);Yu({enabledThemePacks:e,thinkingEffort:n,preferredPlayerName:m})},[e,n,a]),{enabledThemePacks:e,setEnabledThemePacks:t,thinkingEffort:n,setThinkingEffort:o,preferredPlayerName:a,setPreferredPlayerName:r,initialSavedState:i,initialDebugStack:c,appReady:d}},Sp=({enabledThemePacks:e,thinkingEffort:t})=>{const{status:n,dialogue:o,debug:a,system:r}=bu(),{isLoading:i}=n,{state:s}=o,{gatherCurrentGameState:c,gatherDebugPacketStack:l}=a,{setError:d,setIsLoading:u,applyLoadedGameState:m}=r,p=b.useRef(null),g=b.useCallback(async()=>{if(i||s){d("Cannot save to file while loading or in dialogue.");return}const w=c(),h=l();await ju(w,h,T=>{d(T)})},[s,c,l,i,d]),f=b.useCallback(()=>{var w;if(i||s){d("Cannot load from file while another operation is in progress or while in dialogue.");return}(w=p.current)==null||w.click()},[s,i,d]),v=b.useCallback(async w=>{var T;if(i||s){d("Cannot load from file while another operation is in progress or while in dialogue."),w.target.value="";return}const h=(T=w.target.files)==null?void 0:T[0];if(h){u(!0),d(null),await qr();const I=await Fu(h);if(I){const{gameStateStack:S,debugPacketStack:M}=I,k=[{...S[0],enabledThemePacks:e,thinkingEffort:t},S[1]?{...S[1],enabledThemePacks:e,thinkingEffort:t}:void 0],$=cs();$&&(k[0].debugLore=$.debugLore,k[0].debugGoodFacts=$.debugGoodFacts,k[0].debugBadFacts=$.debugBadFacts),await m({savedStateToLoad:k}),ss(k,L=>{d(L)}),is(M),mo($||{debugLore:k[0].debugLore,debugGoodFacts:k[0].debugGoodFacts,debugBadFacts:k[0].debugBadFacts})}else d("Failed to load game from file. The file might be corrupted, an incompatible version, or not a valid save file.");u(!1)}w.target.value=""},[m,s,e,i,d,u,t]),y=b.useCallback(w=>{v(w)},[v]);return{fileInputRef:p,handleSaveToFile:g,handleLoadFromFileClick:f,handleFileInputChange:y}},Tp=()=>{const[e,t]=b.useState(!1),[n,o]=b.useState(null),[a,r]=b.useState(null),[i,s]=b.useState(!1),[c,l]=b.useState(!1),[d,u]=b.useState(!1),[m,p]=b.useState(!1),[g,f]=b.useState(!1),[v,y]=b.useState(!1),[w,h]=b.useState(!1),[T,I]=b.useState(!1),[S,M]=b.useState(!1),[k,$]=b.useState(!1),[L,E]=b.useState(!1),[N,A]=b.useState(null),[P,C]=b.useState(0),[R,_]=b.useState(!1),[W,x]=b.useState(!1),[ce,ge]=b.useState([]),ue=b.useRef(null),[X,pe]=b.useState(!1),[me,D]=b.useState("Male"),j=b.useRef(null),[J,ve]=b.useState(!1),[U,F]=b.useState(null),O=b.useRef(null),V=b.useRef(null),q=b.useCallback(()=>{t(!0)},[]),Y=b.useCallback(()=>{t(!1)},[]),G=b.useCallback(()=>{s(!0)},[]),fe=b.useCallback(()=>{s(!1)},[]),ye=b.useCallback(()=>{p(!0)},[]),Te=b.useCallback(()=>{p(!1)},[]),re=b.useCallback(()=>{l(!0)},[]),Ie=b.useCallback(()=>{l(!1)},[]),Ce=b.useCallback(()=>{u(!0)},[]),Pe=b.useCallback(()=>{u(!1)},[]),_e=b.useCallback(()=>{f(!0)},[]),St=b.useCallback(()=>{f(!1)},[]),Le=b.useCallback(()=>{h(!1)},[]),Qe=b.useCallback(()=>{I(!0)},[]),nt=b.useCallback(()=>{I(!1)},[]),Tt=b.useCallback(()=>{M(!0)},[]),Pt=b.useCallback(()=>{M(!1)},[]),we=b.useCallback(()=>{$(!0)},[]),Ct=b.useCallback(()=>{$(!1)},[]),ot=b.useCallback(()=>{E(!0)},[]),Et=b.useCallback(()=>{E(!1)},[]),le=b.useCallback((Ne,Ee=0)=>{A(Ne),C(Ee),_(!0)},[]),De=b.useCallback(()=>{_(!1),A(null),C(0),ar()},[]),kt=b.useCallback((Ne,Ee)=>{ge(Ne),ue.current=Ee,x(!0)},[]),at=b.useCallback((Ne,Ee,Bt)=>{var on;(on=ue.current)==null||on.call(ue,Ne,Ee,Bt),x(!1)},[]),_n=b.useCallback(()=>{var Ne;(Ne=ue.current)==null||Ne.call(ue,[],[],!1),x(!1)},[]),jn=b.useCallback((Ne,Ee)=>{D(Ne),j.current=Ee,pe(!0)},[]),Fn=b.useCallback(Ne=>{var Ee;(Ee=j.current)==null||Ee.call(j,Ne),pe(!1)},[]),Vn=b.useCallback((Ne,Ee,Bt)=>{F(Ne),V.current=Ee,O.current=Bt,ve(!0)},[]),te=b.useCallback(Ne=>{var Ee;return((Ee=V.current)==null?void 0:Ee.call(V,Ne))??Promise.resolve()},[]),Kt=b.useCallback(()=>{var Ne;(Ne=O.current)==null||Ne.call(O),ve(!1),F(null)},[]);return{isVisualizerVisible:e,visualizerImageUrl:n,visualizerImageScene:a,isKnowledgeBaseVisible:i,isSettingsVisible:c,isInfoVisible:d,isMapVisible:m,userRequestedTitleMenuOpen:g,shouldReturnToTitleMenu:v,isDebugViewVisible:w,isCustomGameSetupVisible:T,shiftConfirmOpen:S,newGameFromMenuConfirmOpen:k,loadGameFromMenuConfirmOpen:L,pageItemId:N,pageStartChapterIndex:P,isPageVisible:R,isCharacterSelectVisible:J,characterSelectData:U,setVisualizerImageUrl:o,setVisualizerImageScene:r,setShouldReturnToTitleMenu:y,setIsDebugViewVisible:h,openVisualizer:q,closeVisualizer:Y,openKnowledgeBase:G,closeKnowledgeBase:fe,openMap:ye,closeMap:Te,openSettings:re,closeSettings:Ie,openInfo:Ce,closeInfo:Pe,openTitleMenu:_e,closeTitleMenu:St,closeDebugView:Le,openCustomGameSetup:Qe,closeCustomGameSetup:nt,openShiftConfirm:Tt,closeShiftConfirm:Pt,openNewGameFromMenuConfirm:we,closeNewGameFromMenuConfirm:Ct,openLoadGameFromMenuConfirm:ot,closeLoadGameFromMenuConfirm:Et,openPageView:le,closePageView:De,isDebugLoreVisible:W,debugLoreFacts:ce,openDebugLoreModal:kt,submitDebugLoreModal:at,closeDebugLoreModal:_n,isGenderSelectVisible:X,genderSelectDefault:me,openGenderSelectModal:jn,submitGenderSelectModal:Fn,openCharacterSelectModal:Vn,submitCharacterSelectModal:Kt,submitCharacterSelectHeroData:te}},Pp=()=>{const[e,t]=b.useState(si()),[n,o]=b.useState(li());return b.useEffect(()=>(ai(t),ii(o),()=>{ri(t),ci(o)}),[]),{progress:e,retryCount:n,clearProgress:ar}},$a=600,qu=2e3,zu=new Set(["Enter"," "]),Qu=(e,t)=>{const n=e??[],o=t??[];if(n.length!==o.length)return!1;if(n.length===0)return!0;const a=s=>{const c={};return Object.keys(s).sort().forEach(l=>{c[l]=s[l]}),JSON.stringify(c)},r=n.map(a).sort(),i=o.map(a).sort();for(let s=0;s<r.length;s++)if(r[s]!==i[s])return!1;return!0},Xu=(e,t)=>!e||!t?e===t:e.name!==t.name||e.type!==t.type||e.description!==t.description||e.holderId!==t.holderId||(e.activeDescription??"")!==(t.activeDescription??"")||(e.isActive??!1)!==(t.isActive??!1)||JSON.stringify(e.tags??[])!==JSON.stringify(t.tags??[])?!1:Qu(e.knownUses,t.knownUses),Cp=({lastTurnChanges:e,isGameBusy:t,currentTurnNumber:n})=>{const[o,a]=b.useState([]),[r,i]=b.useState(null),[s,c]=b.useState("idle"),[l,d]=b.useState(null),[u,m]=b.useState(!1),[p,g]=b.useState(null),[f,v]=b.useState(null),[y,w]=b.useState(!1),[h,T]=b.useState(null),[I,S]=b.useState(null),M=b.useRef(null),k=b.useRef(null),$=b.useRef(null),L=b.useCallback(()=>{M.current&&(clearTimeout(M.current),M.current=null)},[]),E=b.useCallback(()=>{L(),a([]),i(null),c("idle"),w(!1),m(!1),g(null),v(null),d(null)},[L]);b.useEffect(()=>{t&&(e&&e!==h&&(k.current={changes:e,turn:n}),I&&S(null),E())},[t,E,I,e,h,n]),b.useEffect(()=>{!t&&e&&e.itemChanges.length===0&&(k.current=null,a([]),S(null),w(!1),T(e),$.current=n)},[n,t,e]),b.useEffect(()=>{if(t){o.length>0&&a([]);return}let C=null;if(k.current&&(k.current.turn===n?C=k.current.changes:k.current=null),C=C??e,!C)return;if($.current!==null&&n===$.current){k.current=null;return}if(C===h||C===I||I&&r)return;S(C),T(C),$.current=n;const R=[];for(const _ of C.itemChanges)_.type==="acquire"&&_.acquiredItem?R.push({type:"acquire",item:_.acquiredItem}):_.type==="loss"&&_.lostItem?R.push({type:"loss",item:_.lostItem}):_.type==="update"&&_.oldItem&&_.newItem&&(Xu(_.oldItem,_.newItem)||R.push({type:"change",oldItem:_.oldItem,newItem:_.newItem}));R.sort((_,W)=>{const x={loss:0,acquire:1,change:2};return x[_.type]-x[W.type]}),R.length>0?a(R):(a([]),T(C),S(null),w(!1),k.current&&k.current.changes===C&&(k.current=null))},[e,t,h,I,r,o,n]);const N=b.useCallback(()=>{if(L(),o.length>0&&!t){const C=o[0];i(C),a(R=>R.slice(1)),w(!0),C.type==="change"&&C.oldItem&&C.newItem?d({oldItem:C.oldItem,newItem:C.newItem}):C.item?d({item:C.item}):d(null),c("appearing")}else i(null),c("idle"),d(null)},[o,t,L]);b.useEffect(()=>{s==="idle"&&!r&&!t&&(o.length>0?N():(w(!1),I&&I!==h&&T(I),S(null),k.current&&k.current.changes===I&&(k.current=null)))},[s,o,r,N,t,I,h]),b.useEffect(()=>{if(!(t||!r||s==="idle")){switch(L(),s){case"appearing":{g(null),v(null),m(!0);const C=r;M.current=window.setTimeout(()=>{r===C&&c("visible")},$a);break}case"visible":{r.type==="acquire"?v("acquire"):r.type==="loss"?v("loss"):v("change-new");const C=r;M.current=window.setTimeout(()=>{r===C&&c("disappearing")},qu);break}case"disappearing":v(null),r.type==="loss"?g("disappear-to-large"):g("disappear-to-small"),m(!1),M.current=window.setTimeout(()=>{i(null),c("idle"),g(null)},$a);break}return()=>{L()}}},[r,s,t,L]);const A=b.useCallback(()=>{t||(E(),I?(T(I),S(null),$.current=n):e&&e!==h&&(T(e),$.current=n))},[t,E,e,h,I,n]),P=b.useCallback(C=>{zu.has(C.key)&&A()},[A]);return{itemForCardDisplay:l,currentAnimatingItem:r,isVisibleOverlay:y,isCardVisibleClass:u,explicitDisappearClass:p,activeGlowType:f,handleSkipAnimations:A,handleKeyDown:P}},La=()=>({[Q]:{model:Q,count:Jn(Q),limit:Ga},[z]:{model:z,count:Jn(z),limit:Va},[be]:{model:be,count:Jn(be),limit:Fa}}),Ep=()=>{const[e,t]=b.useState(()=>La());return b.useEffect(()=>{const n=()=>{t(La())},o=Zs(n),a=setInterval(n,1e3);return()=>{o(),clearInterval(a)}},[]),e},kp=({items:e,onItemInteract:t,onStashToggle:n,onReadPage:o})=>{const[a,r]=b.useState(new Set),i=b.useRef(e),[s,c]=b.useState("default"),[l,d]=b.useState("all"),[u,m]=b.useState(new Set),p=b.useCallback(E=>{c(N=>N==="name"?"default":"name"),E.currentTarget.blur()},[]),g=b.useCallback(E=>{c(N=>N==="type"?"default":"type"),E.currentTarget.blur()},[]),f=b.useCallback(E=>{d("all"),E.currentTarget.blur()},[]),v=b.useCallback(E=>{d(N=>N==="stashed"?"all":"stashed"),E.currentTarget.blur()},[]),y=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(N){const A=e.find(P=>P.id===N);n(N),A!=null&&A.stashed?l==="stashed"?(m(P=>new Set(P).add(N)),setTimeout(()=>{m(P=>{const C=new Set(P);return C.delete(N),C})},1e3)):(r(P=>new Set(P).add(N)),setTimeout(()=>{r(P=>{const C=new Set(P);return C.delete(N),C})},1500)):(m(P=>new Set(P).add(N)),setTimeout(()=>{m(P=>{const C=new Set(P);return C.delete(N),C})},1e3)),E.currentTarget.blur()}},[l,e,n]),w=b.useCallback(E=>{const{itemId:N,actionName:A,promptEffect:P}=E.currentTarget.dataset;if(!N||!A||!P)return;const C=e.find(_=>_.id===N);if(!C)return;t(C,"specific",{actionName:A,promptEffect:P,description:A}),E.currentTarget.blur()},[e,t]),h=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(P=>P.id===N);A&&(t(A,"inspect"),E.currentTarget.blur())},[e,t]),T=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(P=>P.id===N);A&&(t(A,"generic"),E.currentTarget.blur())},[e,t]),I=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(P=>P.id===N);A&&(t(A,"drop"),E.currentTarget.blur())},[e,t]),S=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(P=>P.id===N);A&&(t(A,"discard"),E.currentTarget.blur())},[e,t]),M=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(R=>R.id===N);if(!A)return;const P=A.isActive?`Exit ${A.name}`:`Enter ${A.name}`;t(A,"specific",{actionName:P,promptEffect:P,description:P}),E.currentTarget.blur()},[e,t]),k=b.useCallback(E=>{const N=E.currentTarget.dataset.itemId;if(!N)return;const A=e.find(P=>P.id===N);A&&(o(A),E.currentTarget.blur())},[e,o]);b.useEffect(()=>{const E=new Set(e.map(P=>P.id)),N=new Set(i.current.map(P=>P.id)),A=[];E.forEach(P=>{N.has(P)||A.push(P)}),A.length>0&&(r(P=>{const C=new Set(P);return A.forEach(R=>C.add(R)),C}),A.forEach(P=>{setTimeout(()=>{r(C=>{const R=new Set(C);return R.delete(P),R})},1500)})),i.current=e},[e]);const $=b.useMemo(()=>{const N=[...e.filter(A=>{if(u.has(A.id))return!0;const P=["page","book","picture","map"].includes(A.type);return l==="stashed"?A.stashed&&P:!(A.stashed&&P)})];return s==="name"?N.sort((A,P)=>A.name.localeCompare(P.name)):s==="type"?N.sort((A,P)=>{const C=A.type.localeCompare(P.type);return C!==0?C:A.name.localeCompare(P.name)}):N.reverse(),N},[e,s,l,u]),L=b.useCallback(E=>E.knownUses?E.knownUses.filter(N=>{const A=!!E.isActive;return N.appliesWhenActive!==void 0&&N.appliesWhenInactive!==void 0?N.appliesWhenActive&&A||N.appliesWhenInactive&&!A||!N.appliesWhenActive&&!N.appliesWhenInactive:N.appliesWhenActive!==void 0?N.appliesWhenActive===A:N.appliesWhenInactive!==void 0?N.appliesWhenInactive===!A:!0}):[],[]);return{displayedItems:$,newlyAddedItemIds:a,stashingItemIds:u,sortOrder:s,filterMode:l,handleSortByName:p,handleSortByType:g,handleFilterAll:f,handleFilterStashed:v,handleSpecificUse:w,handleInspect:h,handleGenericUse:T,handleDrop:I,handleDiscard:S,handleVehicleToggle:M,handleStashToggleInternal:y,handleRead:k,getApplicableKnownUses:L}},Ye=(e,t,n)=>{const o=e.getScreenCTM();if(!o)return{x:t,y:n};const a=o.inverse(),r=e.createSVGPoint();r.x=t,r.y=n;const i=r.matrixTransform(a);return{x:i.x,y:i.y}},Zu=(e,t,n)=>{const o=e.getScreenCTM();if(!o)return{x:t,y:n};const a=e.createSVGPoint();a.x=t,a.y=n;const r=a.matrixTransform(o);return{x:r.x,y:r.y}},Mp=(e=`${String(-$t/2)} ${String(-Lt/2)} ${String($t)} ${String(Lt)}`,t)=>{const[n,o]=b.useState(e),a=I=>{o(I),t&&t(I)},r=b.useRef(null),[i,s]=b.useState(!1),[c,l]=b.useState(null),[d,u]=b.useState(null);b.useEffect(()=>{o(I=>I===e?I:e)},[e]);const m=I=>{I.target.closest(".map-node")||(s(!0),l({x:I.clientX,y:I.clientY}),r.current&&(r.current.style.cursor="grabbing"))},p=I=>{if(!i||!c||!r.current)return;const S=r.current,M=Ye(S,c.x,c.y),k=Ye(S,I.clientX,I.clientY),$=M.x-k.x,L=M.y-k.y,[E,N,A,P]=n.split(" ").map(parseFloat);a(`${String(E+$)} ${String(N+L)} ${String(A)} ${String(P)}`),l({x:I.clientX,y:I.clientY})},g=()=>{s(!1),l(null),r.current&&(r.current.style.cursor="grab")},f=()=>{i&&g()},v=I=>{if(I.cancelable&&I.preventDefault(),!r.current)return;const[S,M,k,$]=n.split(" ").map(parseFloat),L=1.1,E=I.deltaY<0?k/L:k*L,N=I.deltaY<0?$/L:$*L,A=Math.min($t,Lt)*.1,P=Math.min($t,Lt)*10;if(E<A||E>P||N<A||N>P)return;const C=r.current,R=Ye(C,I.clientX,I.clientY),_=R.x-(R.x-S)*(E/k),W=R.y-(R.y-M)*(N/$);a(`${String(_)} ${String(W)} ${String(E)} ${String(N)}`)},y=(I,S)=>Math.sqrt(Math.pow(I.clientX-S.clientX,2)+Math.pow(I.clientY-S.clientY,2));return{viewBox:n,svgRef:r,handleMouseDown:m,handleMouseMove:p,handleMouseUp:g,handleMouseLeave:f,handleWheel:v,handleTouchStart:I=>{if(r.current)if(I.cancelable&&I.preventDefault(),I.touches.length===1){if(I.target.closest(".map-node"))return;s(!0),l({x:I.touches[0].clientX,y:I.touches[0].clientY}),u(null),r.current.style.cursor="grabbing"}else I.touches.length===2&&(s(!1),u(y(I.touches[0],I.touches[1])),l(null))},handleTouchMove:I=>{if(r.current){if(I.cancelable&&I.preventDefault(),I.touches.length===1&&i&&c){const S=I.touches[0],M=r.current,k=Ye(M,c.x,c.y),$=Ye(M,S.clientX,S.clientY),L=k.x-$.x,E=k.y-$.y,[N,A,P,C]=n.split(" ").map(parseFloat);a(`${String(N+L)} ${String(A+E)} ${String(P)} ${String(C)}`),l({x:S.clientX,y:S.clientY})}else if(I.touches.length===2&&d!==null){const S=y(I.touches[0],I.touches[1]);if(S===0||d===0)return;const M=S/d,[k,$,L,E]=n.split(" ").map(parseFloat);let N=L/M,A=E/M;const P=Math.min($t,Lt)*.1,C=Math.min($t,Lt)*10;(N<P||N>C||A<P||A>C)&&(N<P&&(A*=P/N,N=P),A<P&&(N*=P/A,A=P),N>C&&(A*=C/N,N=C),A>C&&(N*=C/A,A=C));const R=(I.touches[0].clientX+I.touches[1].clientX)/2,_=(I.touches[0].clientY+I.touches[1].clientY)/2,W=r.current,x=Ye(W,R,_),ce=x.x-(x.x-k)*(N/L),ge=x.y-(x.y-$)*(A/E);a(`${String(ce)} ${String(ge)} ${String(N)} ${String(A)}`),u(S)}}},handleTouchEnd:I=>{r.current&&(r.current.style.cursor="grab"),I.touches.length<2&&u(null),I.touches.length<1&&(s(!1),l(null))}}},$p=({nodes:e,edges:t,svgRef:n,viewBox:o,destinationNodeId:a,onSelectDestination:r})=>{const[i,s]=b.useState(null),[c,l]=b.useState(!1),d=b.useRef(null),u=250,[m,p]=b.useState(null);b.useLayoutEffect(()=>{if(!i||!n.current){p(null);return}const{x:I,y:S}=Zu(n.current,i.svgX,i.svgY),M=n.current.getBoundingClientRect();p({x:I-M.left,y:S-M.top})},[i,o,n]);const g=b.useCallback((I,S,M)=>{const k=I>M.width/2?"right":"left";return`${S>M.height*.75?"bottom":"top"}-${k}`},[]),f=b.useCallback(()=>{d.current&&(clearTimeout(d.current),d.current=null),c||s(null)},[c]),v=b.useCallback(I=>{const S=I.target;!S.closest(".map-node")&&!S.closest(".map-edge-group")&&(l(!1),s(null))},[]),y=b.useCallback(I=>{var R;if(c)return;const S=I.currentTarget.dataset.edgeId;if(!S)return;const M=t.find(_=>_.id===S);if(!M)return;const k=(R=n.current)==null?void 0:R.getBoundingClientRect();if(!k)return;const $=I.clientX-k.left,L=I.clientY-k.top,E=n.current?Ye(n.current,I.clientX,I.clientY):{x:0,y:0},N=e.find(_=>_.id===M.sourceNodeId),A=e.find(_=>_.id===M.targetNodeId);let P=M.description??`Path between ${(N==null?void 0:N.placeName)??"Unknown"} and ${(A==null?void 0:A.placeName)??"Unknown"}`;M.travelTime&&(P+=`
${M.travelTime}`),P+=`
Status: ${M.status}`;const C=g($,L,k);d.current&&clearTimeout(d.current),d.current=window.setTimeout(()=>{s({content:P,svgX:E.x,svgY:E.y,anchor:C})},u)},[g,t,c,e,n]),w=b.useCallback(I=>{var P;if(c)return;const S=I.currentTarget.getAttribute("data-node-id");if(!S)return;const M=e.find(C=>C.id===S);if(!M)return;const k=(P=n.current)==null?void 0:P.getBoundingClientRect();if(!k)return;const $=I.clientX-k.left,L=I.clientY-k.top,E=n.current?Ye(n.current,I.clientX,I.clientY):{x:0,y:0};let N=M.placeName;M.aliases&&M.aliases.length>0&&(N+=` (aka ${M.aliases.join(", ")})`),M.description&&(N+=`
${M.description}`),N+=`
Status: ${M.status}`;const A=g($,L,k);d.current&&clearTimeout(d.current),d.current=window.setTimeout(()=>{s({content:N,svgX:E.x,svgY:E.y,anchor:A,nodeId:S})},u)},[g,c,e,n]),h=b.useCallback(I=>{var P;I.stopPropagation();const S=I.currentTarget.getAttribute("data-node-id");if(!S)return;const M=e.find(C=>C.id===S);if(!M)return;d.current&&(clearTimeout(d.current),d.current=null);const k=(P=n.current)==null?void 0:P.getBoundingClientRect();if(!k)return;const $=I.clientX-k.left,L=I.clientY-k.top,E=n.current?Ye(n.current,I.clientX,I.clientY):{x:0,y:0};let N=M.placeName;M.aliases&&M.aliases.length>0&&(N+=` (aka ${M.aliases.join(", ")})`),M.description&&(N+=`
${M.description}`),N+=`
Status: ${M.status}`,l(!0);const A=g($,L,k);s({content:N,svgX:E.x,svgY:E.y,anchor:A,nodeId:S})},[g,e,n]),T=b.useCallback(I=>{const S=I.currentTarget.dataset.nodeId;S&&(r(S===a?null:S),l(!1),s(null))},[a,r]);return{tooltip:i,tooltipScreenPosition:m,isTooltipLocked:c,handleMouseLeaveGeneral:f,handleSvgClick:v,handleEdgeMouseEnterById:y,handleNodeMouseEnterById:w,handleNodeClickById:h,handleDestinationClick:T,setIsTooltipLocked:l}},Da={dungeon:"a dark, gritty medieval fantasy style, dungeons and dragons concept art",cyberpunk:"a neon-drenched, futuristic cyberpunk cityscape style, Blade Runner aesthetic",eldritch:"a Lovecraftian horror style, cosmic dread, 1920s period","post-apocalyptic":"a desolate, rusty post-apocalyptic wasteland style, Mad Max aesthetic",steampunk:"a steampunk style with clockwork machines and airships, Victorian era","victorian mansion":"a haunted Victorian mansion style, gothic horror, moody and atmospheric","deep space":"a deep space sci-fi style, cosmic anomaly, advanced technology","lost world":"a prehistoric lost world style, lush jungles, dinosaurs, ancient ruins","greek hero":"a mythic Greek hero style, classical art, epic battles","wild west":"a Wild West outlaw style, dusty frontier, cinematic western"},ep=e=>{if(!e)return"a general fantasy style";const t=e.name.toLowerCase();for(const n in Da)if(t.includes(n))return Da[n];return`a style fitting for ${e.name}`},Lp=async(e,t,n="Respond ONLY with the visual description.",o="ImagePromptSanitizer")=>{var a;try{const{response:r}=await oe({modelNames:[be,z],prompt:e,systemInstruction:n,temperature:1,label:o}),i=(a=r.text)==null?void 0:a.trim();return i&&i.length>0?`${t} ${i}`:`${t} ${e}`}catch(r){return console.warn("sanitizeVisualPrompt: prompt sanitization failed, using raw prompt.",r),`${t} ${e}`}},tp=e=>e.startsWith("/9j")?"image/jpeg":(e.startsWith("iVBORw0"),"image/png"),np=async e=>new Promise((t,n)=>{const o=new Image;o.onload=()=>{const a=document.createElement("canvas");a.width=o.width,a.height=o.height;const r=a.getContext("2d");if(!r){n(new Error("No canvas context"));return}r.drawImage(o,0,0);const i=a.toDataURL("image/jpeg",.7).replace("data:image/jpeg;base64,","");t(i)},o.onerror=n,o.src=`data:${tp(e)};base64,${e}`}),op=async(e,t="4:3")=>{var n,o,a;if(!ee()||!dt)return console.error("generateImageWithFallback: API key not configured."),"";ae(ne.visualize_scene.icon);try{const i=(a=(o=(n=(await dt.models.generateImages({model:"imagen-4.0-generate-001",prompt:e,config:{aspectRatio:t,imageSize:"1K",numberOfImages:1,outputMimeType:"image/jpeg"}})).generatedImages)==null?void 0:n[0])==null?void 0:o.image)==null?void 0:a.imageBytes;if(i)return i;throw new Error("No image data received from API.")}catch(r){try{const i=await dt.models.generateContentStream({model:"gemini-2.5-flash-image",contents:[{role:"user",parts:[{text:e}]}],config:{responseModalities:["IMAGE","TEXT"],responseMimeType:"text/plain"}});return await(async()=>{var l,d,u;for await(const m of i){const p=(l=m.candidates)==null?void 0:l[0],g=(d=p==null?void 0:p.content)==null?void 0:d.parts;if(Array.isArray(g)){const f=g.find(y=>!!y.inlineData),v=(u=f==null?void 0:f.inlineData)==null?void 0:u.data;if(v)return v}}return""})()}catch(i){return console.error("generateImageWithFallback: Gemini fallback failed:",i),tn(r)===400,""}}},ls=(e,t)=>{const n=e.chapters;if(n&&n.length>0)return n;if(e.id===xe)return n??[];const o=e;return[{heading:e.name,description:e.description,contentLength:o.contentLength??30,actualContent:o.actualContent,visibleContent:o.visibleContent}]},ap=(e,t,n)=>ls(e)[t]??null,to={},rp=(e,t)=>ap(e,t),sp=async(e,t,n)=>{var m;const o=`${e.id}-${String(n)}`,a=to[o];if(a)return a;if(!ee()||!dt)return console.error("generateChapterImage: API key not configured."),"";const r=rp(e,n);if(!r)return console.warn(`generateChapterImage: invalid chapter index ${String(n)}`),"";const i=`${r.description} ${r.actualContent??""}`.trim(),s=`${e.name}: ${e.description}. ${i}`.trim(),c=`A detailed, ${e.type} in ${ep(t)} without ANY text on it.`,l=`${c} ${s}`;let d=l;try{const{response:p}=await oe({modelNames:[be,z],prompt:`Rewrite the following item depiction so it prioritizes the item's name and description while including any chapter details. Ensure the result is safe for a highly censored image generation system.

Description:
${l}`,systemInstruction:"Respond ONLY with the visual description.",temperature:1,label:"ImagePromptSanitizer"});d=`${c} ${((m=p.text)==null?void 0:m.trim())??s}`}catch(p){console.warn("Prompt sanitization failed, using raw prompt.",p)}const u=(async()=>{const g=await ie(async f=>{try{ae(ne.visualize_scene.icon);const v=await op(d,"4:3");if(v)return{result:v}}catch(v){throw console.error(`generateChapterImage error (Attempt ${String(f+1)}):`,v),v}return{result:""}})??"";return g?np(g):""})();to[o]=u;try{return await u}finally{to[o]=void 0}};function Dp({item:e,theme:t,currentScene:n,storytellerThoughts:o,mapData:a,allNPCs:r,currentQuest:i,isVisible:s,startIndex:c,isWritingJournal:l,updateItemContent:d}){const[u,m]=b.useState(c),[p,g]=b.useState(!1),[f,v]=b.useState(null),[y,w]=b.useState(!1),[h,T]=b.useState(!1),[I,S]=b.useState(null),M=b.useRef(!1),k=b.useRef(null),$=b.useRef(null),L=(e==null?void 0:e.type)==="book",E=(e==null?void 0:e.type)==="page",N=(e==null?void 0:e.id)===xe,A=e?Ds.includes(e.type):!1,P=b.useMemo(()=>e?ls(e):[],[e]),C=b.useMemo(()=>{if(!e||e.type!=="book")return P.length;let U=0;for(;U<P.length&&P[U].actualContent;U+=1);return Math.min(P.length,U+1)},[P,e]),R=b.useMemo(()=>P.every(U=>!!U.actualContent),[P]),_=b.useCallback(U=>{m(F=>{const O=U(F);return(e==null?void 0:e.type)==="book"&&!N?Math.min(Math.max(O,0),P.length):Math.min(Math.max(O,0),Math.max(P.length-1,0))})},[P.length,N,e==null?void 0:e.type]),W=b.useCallback(()=>{_(U=>U-1)},[_]),x=b.useCallback(()=>{_(U=>{if(N)return Math.min(P.length-1,U+1);if(L){const F=Math.min(C,P.length);return Math.min(F,U+1)}return Math.min(P.length-1,U+1)})},[P.length,L,N,C,_]),ce=b.useCallback(U=>{if(L&&!N){U<=C&&m(U);return}U<C&&m(U)},[L,N,C]),ge=b.useCallback(()=>{g(U=>!U)},[]);b.useEffect(()=>{g(!1),m(c)},[e==null?void 0:e.id,s,c]),b.useEffect(()=>{if(!s||!e){v(null),S(null),w(!1);return}if(e.type==="book"&&!N&&u===0){v(null),w(!1);return}const U=e.type==="book"&&!N?u-1:u;if(U<0||U>=P.length){v(null),w(!1);return}const F=P[U];if(F.visibleContent){v(F.visibleContent),w(!1);return}if(e.id===xe&&F.actualContent){v(F.actualContent),w(!1);return}const O=Symbol("page-text");k.current=O;const V=e.type==="book"?"read_book":"read_page";return w(!0),it(V),(async()=>{try{const q=F.contentLength,Y=await An(F.heading,F.description,q,t.name,t.storyGuidance,n,o,a.nodes,r,i,"Write it exclusively in English without any foreign, encrypted, or gibberish text.",e.type==="book"&&!N&&U>0?P[U-1].actualContent??"":void 0);if(k.current!==O||!Y)return;const G=e.tags??[];let fe=Y;if(G.includes("foreign")){const ye=await An(F.heading,F.description,q,t.name,t.storyGuidance,n,o,a.nodes,r,i,`Translate the following text into an artificial nonexistent language that fits the theme and context:
"""${Y}"""`);if(k.current!==O)return;fe=ye??Y}else G.includes("encrypted")?fe=Kr(Y):G.includes("runic")&&(fe=Br(Y));if(G.includes("torn")&&!G.includes("recovered")&&(fe=Wr(fe)),k.current!==O)return;d(e.id,Y,fe,U),v(fe)}finally{k.current===O&&(w(!1),it(null))}})(),()=>{k.current===O&&(k.current=null)}},[r,P,u,i,n,N,s,e,a.nodes,o,t.name,t.storyGuidance,d]),b.useEffect(()=>{if(T(!1),!s||!e||e.type!=="picture"&&e.type!=="map"){S(null),T(!1);return}const U=u;if(U<0||U>=P.length){S(null),T(!1);return}const F=Symbol("page-image");return $.current=F,(async()=>{if(Xt(P[U].imageData)){const V=await Gt(e.id,U);if($.current!==F)return;V&&(S(`data:image/jpeg;base64,${V}`),T(!1));return}if(P[U].imageData){if(await Vt(e.id,U,P[U].imageData),$.current!==F||(d(e.id,void 0,void 0,U,He(e.id,U)),$.current!==F))return;S(`data:image/jpeg;base64,${P[U].imageData}`),T(!1);return}const O=await Gt(e.id,U);if($.current===F){if(O){if(d(e.id,void 0,void 0,U,He(e.id,U)),$.current!==F)return;S(`data:image/jpeg;base64,${O}`),T(!1);return}if(!(M.current||$.current!==F)){M.current=!0,T(!0),it(e.type==="book"?"read_book":"read_page");try{const V=await sp(e,t,U);if($.current!==F||!V||(await Vt(e.id,U,V),$.current!==F)||(d(e.id,void 0,void 0,U,He(e.id,U)),$.current!==F))return;S(`data:image/jpeg;base64,${V}`)}finally{$.current===F&&(T(!1),it(null)),M.current=!1}}}})(),()=>{$.current===F&&($.current=null)}},[P,u,s,e,t,d]);const ue=L&&!N?u-1:u,X=ue>=0&&ue<P.length,pe=b.useMemo(()=>{if(!X)return f;const U=P[ue];return p&&U.actualContent?U.actualContent:f},[X,P,ue,p,f]),me=b.useMemo(()=>{var F;if(!e||!((F=e.tags)!=null&&F.includes("torn"))||e.tags.includes("recovered")||!pe)return null;const U=pe.trim();return U.startsWith("--- torn ---")?"top":U.endsWith("--- torn ---")?"bottom":null},[pe,e]),D=b.useMemo(()=>{const U=(e==null?void 0:e.tags)??[],F=[],O=X?P[ue]:void 0,V=p&&!!(O!=null&&O.actualContent),q=!V&&U.includes("foreign");return U.includes("handwritten")?F.push(q?"tag-handwritten-foreign":"tag-handwritten"):U.includes("printed")?F.push(q?"tag-printed-foreign":"tag-printed"):U.includes("typed")?F.push(q?"tag-typed-foreign":"tag-typed"):U.includes("digital")&&F.push(q?"tag-digital-foreign":"tag-digital"),U.includes("faded")&&F.push("tag-faded"),U.includes("smudged")&&F.push("tag-smudged"),U.includes("torn")&&F.push("tag-torn"),V||(U.includes("glitching")&&F.push("tag-glitching"),U.includes("encrypted")&&F.push("tag-encrypted"),U.includes("foreign")&&F.push("tag-foreign")),U.includes("gothic")&&F.push("tag-gothic"),U.includes("runic")&&F.push("tag-runic"),U.includes("recovered")&&p&&F.push("tag-recovered"),F.join(" ")},[X,P,ue,e,p]),j=b.useMemo(()=>N&&l,[N,l]);b.useEffect(()=>{if(j)return it("write_journal"),()=>{it(null)}},[j]);const J=b.useMemo(()=>e?N?!0:L||E?R:!0:!1,[R,L,N,E,e]);return{chapters:P,chapterIndex:u,isBook:L,isJournal:N,isPage:E,isImageItem:A,unlockedChapterCount:C,allChaptersGenerated:R,text:f,displayedText:pe,showDecoded:p,textClassNames:D,tearOrientation:me,imageUrl:I,isLoading:y||h,canInspectItem:J,pendingWrite:j,handlePrevChapter:W,handleNextChapter:x,handleSelectChapter:ce,toggleDecoded:ge}}const ip=e=>{const t=b.useRef([]),n=b.useRef(0);return(e.length!==t.current.length||e.some((o,a)=>!Object.is(o,t.current[a])))&&(t.current=e,n.current+=1),n.current},cp=1500;function Rp({appReady:e,dependencies:t,dialogueState:n,gatherDebugPacketStack:o,gatherGameStateStack:a,hasGameBeenInitialized:r,isLoading:i,isTurnProcessing:s,setError:c}){const l=b.useRef(null),d=ip(t);b.useEffect(()=>{if(!(i||s||!r||!e||n))return l.current&&clearTimeout(l.current),l.current=window.setTimeout(()=>{const u=a(),m=o();ss(u,c),is(m),mo({debugLore:u[0].debugLore,debugGoodFacts:u[0].debugGoodFacts,debugBadFacts:u[0].debugBadFacts})},cp),()=>{l.current&&clearTimeout(l.current)}},[a,o,i,r,e,n,d,s,c])}export{ie as A,ae as B,Se as C,Ha as D,oe as E,bu as F,Sp as G,mo as H,Rp as I,bp as J,Dn as K,vp as L,pr as M,Ap as N,Tp as O,So as P,Ip as Q,Np as R,po as T,Pp as a,Cp as b,Ep as c,kp as d,fp as e,wp as f,hp as g,Ur as h,ee as i,Mp as j,$p as k,gp as l,bo as m,Ao as n,dt as o,it as p,ep as q,Lp as r,yp as s,op as t,Bs as u,tn as v,Dp as w,mr as x,It as y,Ze as z};
